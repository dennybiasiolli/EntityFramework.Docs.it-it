---
title: Valutazione tra client e server - EF Core
author: smitpatel
ms.date: 10/03/2019
ms.assetid: 8b6697cc-7067-4dc2-8007-85d80503d123
uid: core/querying/client-eval
ms.openlocfilehash: e01bd146c4dfe7a8d36b641cb52ae366fddd8239
ms.sourcegitcommit: 9b562663679854c37c05fca13d93e180213fb4aa
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 04/07/2020
ms.locfileid: "78417760"
---
# <a name="client-vs-server-evaluation"></a><span data-ttu-id="bea76-102">Client e valutazione del server</span><span class="sxs-lookup"><span data-stu-id="bea76-102">Client vs. Server Evaluation</span></span>

<span data-ttu-id="bea76-103">Come regola generale, Entity Framework Core tenta di valutare una query sul server il più possibile.</span><span class="sxs-lookup"><span data-stu-id="bea76-103">As a general rule, Entity Framework Core attempts to evaluate a query on the server as much as possible.</span></span> <span data-ttu-id="bea76-104">EF Core converte parti della query in parametri, che è possibile valutare sul lato client.</span><span class="sxs-lookup"><span data-stu-id="bea76-104">EF Core converts parts of the query into parameters, which it can evaluate on the client side.</span></span> <span data-ttu-id="bea76-105">Il resto della query (insieme ai parametri generati) viene assegnato al provider di database per determinare la query di database equivalente da valutare nel server.</span><span class="sxs-lookup"><span data-stu-id="bea76-105">The rest of the query (along with the generated parameters) is given to the database provider to determine the equivalent database query to evaluate on the server.</span></span> <span data-ttu-id="bea76-106">EF Core supporta la valutazione parziale del client nella proiezione `Select()`di primo livello (essenzialmente, l'ultima chiamata a ).</span><span class="sxs-lookup"><span data-stu-id="bea76-106">EF Core supports partial client evaluation in the top-level projection (essentially, the last call to `Select()`).</span></span> <span data-ttu-id="bea76-107">Se la proiezione di primo livello nella query non può essere convertita nel server, EF Core recupererà i dati necessari dal server e valuterà le parti rimanenti della query sul client.</span><span class="sxs-lookup"><span data-stu-id="bea76-107">If the top-level projection in the query can't be translated to the server, EF Core will fetch any required data from the server and evaluate remaining parts of the query on the client.</span></span> <span data-ttu-id="bea76-108">Se EF Core rileva un'espressione, in qualsiasi posizione diversa dalla proiezione di primo livello, che non può essere convertita nel server, viene generata un'eccezione di runtime.</span><span class="sxs-lookup"><span data-stu-id="bea76-108">If EF Core detects an expression, in any place other than the top-level projection, which can't be translated to the server, then it throws a runtime exception.</span></span> <span data-ttu-id="bea76-109">Vedere [come query funziona](xref:core/querying/how-query-works) per comprendere come EF Core determina ciò che non può essere convertito in server.</span><span class="sxs-lookup"><span data-stu-id="bea76-109">See [how query works](xref:core/querying/how-query-works) to understand how EF Core determines what can't be translated to server.</span></span>

> [!NOTE]
> <span data-ttu-id="bea76-110">Prima della versione 3.0, Entity Framework Core supportava la valutazione client in qualsiasi punto della query.</span><span class="sxs-lookup"><span data-stu-id="bea76-110">Prior to version 3.0, Entity Framework Core supported client evaluation anywhere in the query.</span></span> <span data-ttu-id="bea76-111">Per ulteriori informazioni, vedere la [sezione delle versioni precedenti.](#previous-versions)</span><span class="sxs-lookup"><span data-stu-id="bea76-111">For more information, see the [previous versions section](#previous-versions).</span></span>

> [!TIP]
> <span data-ttu-id="bea76-112">È possibile visualizzare l'[esempio](https://github.com/dotnet/EntityFramework.Docs/tree/master/samples/core/Querying) di questo articolo in GitHub.</span><span class="sxs-lookup"><span data-stu-id="bea76-112">You can view this article's [sample](https://github.com/dotnet/EntityFramework.Docs/tree/master/samples/core/Querying) on GitHub.</span></span>

## <a name="client-evaluation-in-the-top-level-projection"></a><span data-ttu-id="bea76-113">Valutazione del client nella proiezione di primo livello</span><span class="sxs-lookup"><span data-stu-id="bea76-113">Client evaluation in the top-level projection</span></span>

<span data-ttu-id="bea76-114">Nell'esempio seguente viene usato un metodo helper per standardizzare gli URL per i blog, che vengono restituiti da un database di SQL Server.In the following example, a helper method is used to standardize URLs for blogs, which are returned from a SQL Server database.</span><span class="sxs-lookup"><span data-stu-id="bea76-114">In the following example, a helper method is used to standardize URLs for blogs, which are returned from a SQL Server database.</span></span> <span data-ttu-id="bea76-115">Poiché il provider SQL Server non dispone di informazioni dettagliate su come viene implementato questo metodo, non è possibile convertirlo in SQL.</span><span class="sxs-lookup"><span data-stu-id="bea76-115">Since the SQL Server provider has no insight into how this method is implemented, it isn't possible to translate it into SQL.</span></span> <span data-ttu-id="bea76-116">Tutti gli altri aspetti della query vengono valutati nel `URL` database, ma il passaggio dell'oggetto restituito tramite questo metodo viene eseguito sul client.</span><span class="sxs-lookup"><span data-stu-id="bea76-116">All other aspects of the query are evaluated in the database, but passing the returned `URL` through this method is done on the client.</span></span>

[!code-csharp[Main](../../../samples/core/Querying/ClientEval/Sample.cs#ClientProjection)]

[!code-csharp[Main](../../../samples/core/Querying/ClientEval/Sample.cs#ClientMethod)]

## <a name="unsupported-client-evaluation"></a><span data-ttu-id="bea76-117">Valutazione client non supportata</span><span class="sxs-lookup"><span data-stu-id="bea76-117">Unsupported client evaluation</span></span>

<span data-ttu-id="bea76-118">Sebbene la valutazione del client sia utile, talvolta le prestazioni possono risultare scarse.</span><span class="sxs-lookup"><span data-stu-id="bea76-118">While client evaluation is useful, it can result in poor performance sometimes.</span></span> <span data-ttu-id="bea76-119">Si consideri la query seguente, in cui il metodo helper viene ora usato in un filtro where.</span><span class="sxs-lookup"><span data-stu-id="bea76-119">Consider the following query, in which the helper method is now used in a where filter.</span></span> <span data-ttu-id="bea76-120">Poiché il filtro non può essere applicato nel database, tutti i dati devono essere estratti in memoria per applicare il filtro sul client.</span><span class="sxs-lookup"><span data-stu-id="bea76-120">Because the filter can't be applied in the database, all the data needs to be pulled into memory to apply the filter on the client.</span></span> <span data-ttu-id="bea76-121">In base al filtro e alla quantità di dati sul server, la valutazione del client potrebbe comportare una riduzione delle prestazioni.</span><span class="sxs-lookup"><span data-stu-id="bea76-121">Based on the filter and the amount of data on the server, client evaluation could result in poor performance.</span></span> <span data-ttu-id="bea76-122">Così Entity Framework Core blocca tale valutazione del client e genera un'eccezione di runtime.</span><span class="sxs-lookup"><span data-stu-id="bea76-122">So Entity Framework Core blocks such client evaluation and throws a runtime exception.</span></span>

[!code-csharp[Main](../../../samples/core/Querying/ClientEval/Sample.cs#ClientWhere)]

## <a name="explicit-client-evaluation"></a><span data-ttu-id="bea76-123">Valutazione esplicita del cliente</span><span class="sxs-lookup"><span data-stu-id="bea76-123">Explicit client evaluation</span></span>

<span data-ttu-id="bea76-124">Potrebbe essere necessario forzare esplicitamente la valutazione del cliente in alcuni casi, ad esempio</span><span class="sxs-lookup"><span data-stu-id="bea76-124">You may need to force into client evaluation explicitly in certain cases like following</span></span>

- <span data-ttu-id="bea76-125">La quantità di dati è piccola in modo che la valutazione sul client non commichi un'enorme riduzione delle prestazioni.</span><span class="sxs-lookup"><span data-stu-id="bea76-125">The amount of data is small so that evaluating on the client doesn't incur a huge performance penalty.</span></span>
- <span data-ttu-id="bea76-126">L'operatore LINQ utilizzato non dispone di alcuna conversione sul lato server.</span><span class="sxs-lookup"><span data-stu-id="bea76-126">The LINQ operator being used has no server-side translation.</span></span>

<span data-ttu-id="bea76-127">In questi casi, è possibile rifiutare esplicitamente`AsAsyncEnumerable` `ToListAsync` la valutazione del client chiamando metodi come `AsEnumerable` o `ToList` (o per async).</span><span class="sxs-lookup"><span data-stu-id="bea76-127">In such cases, you can explicitly opt into client evaluation by calling methods like `AsEnumerable` or `ToList` (`AsAsyncEnumerable` or `ToListAsync` for async).</span></span> <span data-ttu-id="bea76-128">Utilizzando `AsEnumerable` si sarebbe lo streaming dei `ToList` risultati, ma utilizzando causerebbe buffering creando un elenco, che richiede anche memoria aggiuntiva.</span><span class="sxs-lookup"><span data-stu-id="bea76-128">By using `AsEnumerable` you would be streaming the results, but using `ToList` would cause buffering by creating a list, which also takes additional memory.</span></span> <span data-ttu-id="bea76-129">Anche se se si sta enumerando più volte, quindi l'archiviazione dei risultati in un elenco aiuta di più poiché c'è solo una query al database.</span><span class="sxs-lookup"><span data-stu-id="bea76-129">Though if you're enumerating multiple times, then storing results in a list helps more since there's only one query to the database.</span></span> <span data-ttu-id="bea76-130">A seconda dell'utilizzo specifico, è necessario valutare quale metodo è più utile per il caso.</span><span class="sxs-lookup"><span data-stu-id="bea76-130">Depending on the particular usage, you should evaluate which method is more useful for the case.</span></span>

[!code-csharp[Main](../../../samples/core/Querying/ClientEval/Sample.cs#ExplicitClientEval)]

## <a name="potential-memory-leak-in-client-evaluation"></a><span data-ttu-id="bea76-131">Potenziale perdita di memoria nella valutazione del client</span><span class="sxs-lookup"><span data-stu-id="bea76-131">Potential memory leak in client evaluation</span></span>

<span data-ttu-id="bea76-132">Poiché la conversione e la compilazione delle query sono costose, EF Core memorizza nella cache il piano di query compilato.</span><span class="sxs-lookup"><span data-stu-id="bea76-132">Since query translation and compilation are expensive, EF Core caches the compiled query plan.</span></span> <span data-ttu-id="bea76-133">Il delegato memorizzato nella cache può utilizzare il codice client durante la valutazione client della proiezione di primo livello.</span><span class="sxs-lookup"><span data-stu-id="bea76-133">The cached delegate may use client code while doing client evaluation of top-level projection.</span></span> <span data-ttu-id="bea76-134">EF Core genera parametri per le parti valutate dal client dell'albero e riutilizza il piano di query sostituendo i valori dei parametri.</span><span class="sxs-lookup"><span data-stu-id="bea76-134">EF Core generates parameters for the client-evaluated parts of the tree and reuses the query plan by replacing the parameter values.</span></span> <span data-ttu-id="bea76-135">Tuttavia, alcune costanti nell'albero delle espressioni non possono essere convertite in parametri.</span><span class="sxs-lookup"><span data-stu-id="bea76-135">But certain constants in the expression tree can't be converted into parameters.</span></span> <span data-ttu-id="bea76-136">Se il delegato memorizzato nella cache contiene tali costanti, tali oggetti non possono essere sottoposti a garbage collection poiché ne fanno ancora riferimento.</span><span class="sxs-lookup"><span data-stu-id="bea76-136">If the cached delegate contains such constants, then those objects can't be garbage collected since they're still being referenced.</span></span> <span data-ttu-id="bea76-137">Se tale oggetto contiene un oggetto DbContext o altri servizi in esso contenuti, l'utilizzo della memoria dell'app potrebbe aumentare nel tempo.</span><span class="sxs-lookup"><span data-stu-id="bea76-137">If such an object contains a DbContext or other services in it, then it could cause the memory usage of the app to grow over time.</span></span> <span data-ttu-id="bea76-138">Questo comportamento è in genere un segno di una perdita di memoria.</span><span class="sxs-lookup"><span data-stu-id="bea76-138">This behavior is generally a sign of a memory leak.</span></span> <span data-ttu-id="bea76-139">EF Core genera un'eccezione ogni volta che si imbatte in costanti di un tipo che non può essere mappato utilizzando il provider di database corrente.</span><span class="sxs-lookup"><span data-stu-id="bea76-139">EF Core throws an exception whenever it comes across constants of a type that can't be mapped using current database provider.</span></span> <span data-ttu-id="bea76-140">Le cause più comuni e le relative soluzioni sono le seguenti:</span><span class="sxs-lookup"><span data-stu-id="bea76-140">Common causes and their solutions are as follows:</span></span>

- <span data-ttu-id="bea76-141">**Utilizzo di un metodo**di istanza : quando si utilizzano metodi di istanza in una proiezione client, la struttura ad albero dell'espressione contiene una costante dell'istanza.</span><span class="sxs-lookup"><span data-stu-id="bea76-141">**Using an instance method**: When using instance methods in a client projection, the expression tree contains a constant of the instance.</span></span> <span data-ttu-id="bea76-142">Se il metodo non utilizza dati dall'istanza, è consigliabile rendere statico il metodo.</span><span class="sxs-lookup"><span data-stu-id="bea76-142">If your method doesn't use any data from the instance, consider making the method static.</span></span> <span data-ttu-id="bea76-143">Se sono necessari dati di istanza nel corpo del metodo, passare i dati specifici come argomento al metodo.</span><span class="sxs-lookup"><span data-stu-id="bea76-143">If you need instance data in the method body, then pass the specific data as an argument to the method.</span></span>
- <span data-ttu-id="bea76-144">**Passaggio di argomenti costanti al metodo** `this` : questo caso si verifica in genere utilizzando in un argomento al metodo client.</span><span class="sxs-lookup"><span data-stu-id="bea76-144">**Passing constant arguments to method**: This case arises generally by using `this` in an argument to client method.</span></span> <span data-ttu-id="bea76-145">Valutare la possibilità di suddividere l'argomento in più argomenti scalari, che possono essere mappati dal provider di database.</span><span class="sxs-lookup"><span data-stu-id="bea76-145">Consider splitting the argument in to multiple scalar arguments, which can be mapped by the database provider.</span></span>
- <span data-ttu-id="bea76-146">**Altre costanti**: Se una costante viene inqualsiasi caso, è possibile valutare se la costante è necessaria nell'elaborazione.</span><span class="sxs-lookup"><span data-stu-id="bea76-146">**Other constants**: If a constant is come across in any other case, then you can evaluate whether the constant is needed in processing.</span></span> <span data-ttu-id="bea76-147">Se è necessario avere la costante o se non è possibile usare una soluzione dai casi precedenti, creare una variabile locale per archiviare il valore e usare la variabile locale nella query.</span><span class="sxs-lookup"><span data-stu-id="bea76-147">If it's necessary to have the constant, or if you can't use a solution from the above cases, then create a local variable to store the value and use local variable in the query.</span></span> <span data-ttu-id="bea76-148">EF Core convertirà la variabile locale in un parametro.</span><span class="sxs-lookup"><span data-stu-id="bea76-148">EF Core will convert the local variable into a parameter.</span></span>

## <a name="previous-versions"></a><span data-ttu-id="bea76-149">Versioni precedenti</span><span class="sxs-lookup"><span data-stu-id="bea76-149">Previous versions</span></span>

<span data-ttu-id="bea76-150">La sezione seguente si applica alle versioni di EF Core precedenti alla 3.0.The following section applies to EF Core versions before 3.0.</span><span class="sxs-lookup"><span data-stu-id="bea76-150">The following section applies to EF Core versions before 3.0.</span></span>

<span data-ttu-id="bea76-151">Le versioni precedenti di EF Core supportavano la valutazione client in qualsiasi parte della query, non solo la proiezione di primo livello.</span><span class="sxs-lookup"><span data-stu-id="bea76-151">Older EF Core versions supported client evaluation in any part of the query--not just the top-level projection.</span></span> <span data-ttu-id="bea76-152">Ecco perché le query simili a una pubblicata nella sezione [Valutazione client non supportata](#unsupported-client-evaluation) hanno funzionato correttamente.</span><span class="sxs-lookup"><span data-stu-id="bea76-152">That's why queries similar to one posted under the [Unsupported client evaluation](#unsupported-client-evaluation) section worked correctly.</span></span> <span data-ttu-id="bea76-153">Poiché questo comportamento potrebbe causare problemi di prestazioni inosservati, EF Core registrato un avviso di valutazione del client.</span><span class="sxs-lookup"><span data-stu-id="bea76-153">Since this behavior could cause unnoticed performance issues, EF Core logged a client evaluation warning.</span></span> <span data-ttu-id="bea76-154">Per ulteriori informazioni sulla visualizzazione dell'output di registrazione, vedere [Registrazione](xref:core/miscellaneous/logging).</span><span class="sxs-lookup"><span data-stu-id="bea76-154">For more information on viewing logging output, see [Logging](xref:core/miscellaneous/logging).</span></span>

<span data-ttu-id="bea76-155">Facoltativamente, EF Core consente di modificare il comportamento predefinito per generare un'eccezione o non eseguire alcuna operazione quando si esegue la valutazione del client (ad eccezione della proiezione).</span><span class="sxs-lookup"><span data-stu-id="bea76-155">Optionally EF Core allowed you to change the default behavior to either throw an exception or do nothing when doing client evaluation (except for in the projection).</span></span> <span data-ttu-id="bea76-156">Il comportamento di generazione di eccezioni lo renderebbe simile al comportamento in 3.0.The exception throwing behavior would make it similar to the behavior in 3.0.</span><span class="sxs-lookup"><span data-stu-id="bea76-156">The exception throwing behavior would make it similar to the behavior in 3.0.</span></span> <span data-ttu-id="bea76-157">Per modificare il comportamento, è necessario configurare gli avvisi durante `DbContext.OnConfiguring`l'impostazione delle opzioni per il contesto, in genere in o in `Startup.cs` se si utilizza ASP.NET Core.</span><span class="sxs-lookup"><span data-stu-id="bea76-157">To change the behavior, you need to configure warnings while setting up the options for your context - typically in `DbContext.OnConfiguring`, or in `Startup.cs` if you're using ASP.NET Core.</span></span>

```csharp
protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
{
    optionsBuilder
        .UseSqlServer(@"Server=(localdb)\mssqllocaldb;Database=EFQuerying;Trusted_Connection=True;")
        .ConfigureWarnings(warnings => warnings.Throw(RelationalEventId.QueryClientEvaluationWarning));
}
```
