---
title: Considerazioni sulle prestazioni per EF4, EF5 ed EF6 - EF6Performance considerations for EF4, EF5, and EF6 - EF6
author: divega
ms.date: 10/23/2016
ms.assetid: d6d5a465-6434-45fa-855d-5eb48c61a2ea
ms.openlocfilehash: 0ece383bb5083b41c7a2636c009473333af6d3e2
ms.sourcegitcommit: 144edccf9b29a7ffad119c235ac9808ec1a46193
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 04/16/2020
ms.locfileid: "81434339"
---
# <a name="performance-considerations-for-ef-4-5-and-6"></a><span data-ttu-id="350e1-102">Considerazioni sulle prestazioni per EF 4, 5 e 6Performance considerations for EF 4, 5, and 6</span><span class="sxs-lookup"><span data-stu-id="350e1-102">Performance considerations for EF 4, 5, and 6</span></span>
<span data-ttu-id="350e1-103">Di David Obando, Eric Dettinger e altri</span><span class="sxs-lookup"><span data-stu-id="350e1-103">By David Obando, Eric Dettinger and others</span></span>

<span data-ttu-id="350e1-104">Pubblicato: aprile 2012</span><span class="sxs-lookup"><span data-stu-id="350e1-104">Published: April 2012</span></span>

<span data-ttu-id="350e1-105">Ultimo aggiornamento: maggio 2014</span><span class="sxs-lookup"><span data-stu-id="350e1-105">Last updated: May 2014</span></span>

------------------------------------------------------------------------

## <a name="1-introduction"></a><span data-ttu-id="350e1-106">1. Introduzione</span><span class="sxs-lookup"><span data-stu-id="350e1-106">1. Introduction</span></span>

<span data-ttu-id="350e1-107">I framework di mapping relazionale a oggetti sono un modo pratico per fornire un'astrazione per l'accesso ai dati in un'applicazione orientata agli oggetti.</span><span class="sxs-lookup"><span data-stu-id="350e1-107">Object-Relational Mapping frameworks are a convenient way to provide an abstraction for data access in an object-oriented application.</span></span> <span data-ttu-id="350e1-108">Per le applicazioni .NET, L'O/RM consigliato da Microsoft è Entity Framework.</span><span class="sxs-lookup"><span data-stu-id="350e1-108">For .NET applications, Microsoft's recommended O/RM is Entity Framework.</span></span> <span data-ttu-id="350e1-109">Con qualsiasi astrazione, tuttavia, le prestazioni possono diventare un problema.</span><span class="sxs-lookup"><span data-stu-id="350e1-109">With any abstraction though, performance can become a concern.</span></span>

<span data-ttu-id="350e1-110">Questo white paper è stato scritto per mostrare le considerazioni sulle prestazioni durante lo sviluppo di applicazioni che utilizzano Entity Framework, per fornire agli sviluppatori un'idea degli algoritmi interni di Entity Framework che possono influire sulle prestazioni e per fornire suggerimenti per l'analisi e il miglioramento delle prestazioni nelle applicazioni che utilizzano Entity Framework.</span><span class="sxs-lookup"><span data-stu-id="350e1-110">This whitepaper was written to show the performance considerations when developing applications using Entity Framework, to give developers an idea of the Entity Framework internal algorithms that can affect performance, and to provide tips for investigation and improving performance in their applications that use Entity Framework.</span></span> <span data-ttu-id="350e1-111">Ci sono una serie di buoni argomenti sulle prestazioni già disponibili sul web, e abbiamo anche provato a puntare a queste risorse dove possibile.</span><span class="sxs-lookup"><span data-stu-id="350e1-111">There are a number of good topics on performance already available on the web, and we've also tried pointing to these resources where possible.</span></span>

<span data-ttu-id="350e1-112">Le prestazioni sono un argomento difficile.</span><span class="sxs-lookup"><span data-stu-id="350e1-112">Performance is a tricky topic.</span></span> <span data-ttu-id="350e1-113">Questo white paper è inteso come una risorsa che consente di prendere decisioni relative alle prestazioni per le applicazioni che utilizzano Entity Framework.</span><span class="sxs-lookup"><span data-stu-id="350e1-113">This whitepaper is intended as a resource to help you make performance related decisions for your applications that use Entity Framework.</span></span> <span data-ttu-id="350e1-114">Sono state incluse alcune metriche di test per illustrare le prestazioni, ma queste metriche non sono intese come indicatori assoluti delle prestazioni che verranno visualizzate nell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="350e1-114">We have included some test metrics to demonstrate performance, but these metrics aren't intended as absolute indicators of the performance you will see in your application.</span></span>

<span data-ttu-id="350e1-115">Per scopi pratici, in questo documento si presuppone che Entity Framework 4 venga eseguito in .NET 4.0 e che Entity Framework 5 e 6 vengano eseguiti in .NET 4.5.</span><span class="sxs-lookup"><span data-stu-id="350e1-115">For practical purposes, this document assumes Entity Framework 4 is run under .NET 4.0 and Entity Framework 5 and 6 are run under .NET 4.5.</span></span> <span data-ttu-id="350e1-116">Molti dei miglioramenti delle prestazioni apportati per Entity Framework 5 risiedono all'interno dei componenti di base che vengono riprodotti con .NET 4.5.</span><span class="sxs-lookup"><span data-stu-id="350e1-116">Many of the performance improvements made for Entity Framework 5 reside within the core components that ship with .NET 4.5.</span></span>

<span data-ttu-id="350e1-117">Entity Framework 6 è una versione fuori banda e non dipende dai componenti di Entity Framework che vengono spediti con .NET.</span><span class="sxs-lookup"><span data-stu-id="350e1-117">Entity Framework 6 is an out of band release and does not depend on the Entity Framework components that ship with .NET.</span></span> <span data-ttu-id="350e1-118">Entity Framework 6 funziona sia su .NET 4.0 che su .NET 4.5 e può offrire un grande vantaggio in termini di prestazioni a coloro che non hanno eseguito l'aggiornamento da .NET 4.0 ma desiderano i bit di Entity Framework più recenti nell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="350e1-118">Entity Framework 6 work on both .NET 4.0 and .NET 4.5, and can offer a big performance benefit to those who haven’t upgraded from .NET 4.0 but want the latest Entity Framework bits in their application.</span></span> <span data-ttu-id="350e1-119">Quando questo documento menziona Entity Framework 6, si riferisce alla versione più recente disponibile al momento della stesura di questo articolo: versione 6.1.0.</span><span class="sxs-lookup"><span data-stu-id="350e1-119">When this document mentions Entity Framework 6, it refers to the latest version available at the time of this writing: version 6.1.0.</span></span>

## <a name="2-cold-vs-warm-query-execution"></a><span data-ttu-id="350e1-120">2. Esecuzione di query a freddo e a caldo</span><span class="sxs-lookup"><span data-stu-id="350e1-120">2. Cold vs. Warm Query Execution</span></span>

<span data-ttu-id="350e1-121">La prima volta che viene eseguita una query su un determinato modello, Entity Framework esegue molte operazioni dietro le quinte per caricare e convalidare il modello.</span><span class="sxs-lookup"><span data-stu-id="350e1-121">The very first time any query is made against a given model, the Entity Framework does a lot of work behind the scenes to load and validate the model.</span></span> <span data-ttu-id="350e1-122">Si fa spesso riferimento a questa prima query come a una query "fredda".</span><span class="sxs-lookup"><span data-stu-id="350e1-122">We frequently refer to this first query as a "cold" query.</span></span><span data-ttu-id="350e1-123">Ulteriori query su un modello già caricato sono note come query "calde" e sono molto più veloci.</span><span class="sxs-lookup"><span data-stu-id="350e1-123">  Further queries against an already loaded model are known as "warm" queries, and are much faster.</span></span>

<span data-ttu-id="350e1-124">Prendiamo una vista generale del punto in cui viene impiegato il tempo durante l'esecuzione di una query con Entity Framework e vediamo dove le cose stanno migliorando in Entity Framework 6.</span><span class="sxs-lookup"><span data-stu-id="350e1-124">Let’s take a high-level view of where time is spent when executing a query using Entity Framework, and see where things are improving in Entity Framework 6.</span></span>

<span data-ttu-id="350e1-125">**Prima esecuzione query - query a freddo**</span><span class="sxs-lookup"><span data-stu-id="350e1-125">**First Query Execution – cold query**</span></span>

| <span data-ttu-id="350e1-126">Scrittura utente codice</span><span class="sxs-lookup"><span data-stu-id="350e1-126">Code User Writes</span></span>                                                                                     | <span data-ttu-id="350e1-127">Azione</span><span class="sxs-lookup"><span data-stu-id="350e1-127">Action</span></span>                    | <span data-ttu-id="350e1-128">Impatto sulle prestazioni di EF4</span><span class="sxs-lookup"><span data-stu-id="350e1-128">EF4 Performance Impact</span></span>                                                                                                                                                                                                                                                                                                                                                                                                        | <span data-ttu-id="350e1-129">Impatto sulle prestazioni di EF5</span><span class="sxs-lookup"><span data-stu-id="350e1-129">EF5 Performance Impact</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                    | <span data-ttu-id="350e1-130">Impatto sulle prestazioni di EF6</span><span class="sxs-lookup"><span data-stu-id="350e1-130">EF6 Performance Impact</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
|:-----------------------------------------------------------------------------------------------------|:--------------------------|:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `using(var db = new MyContext())` <br/> `{`                                                          | <span data-ttu-id="350e1-131">Creazione di contesto</span><span class="sxs-lookup"><span data-stu-id="350e1-131">Context creation</span></span>          | <span data-ttu-id="350e1-132">Media</span><span class="sxs-lookup"><span data-stu-id="350e1-132">Medium</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                        | <span data-ttu-id="350e1-133">Media</span><span class="sxs-lookup"><span data-stu-id="350e1-133">Medium</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                    | <span data-ttu-id="350e1-134">Basso</span><span class="sxs-lookup"><span data-stu-id="350e1-134">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| `  var q1 = ` <br/> `    from c in db.Customers` <br/> `    where c.Id == id1` <br/> `    select c;` | <span data-ttu-id="350e1-135">Creazione di espressioni di query</span><span class="sxs-lookup"><span data-stu-id="350e1-135">Query expression creation</span></span> | <span data-ttu-id="350e1-136">Basso</span><span class="sxs-lookup"><span data-stu-id="350e1-136">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                           | <span data-ttu-id="350e1-137">Basso</span><span class="sxs-lookup"><span data-stu-id="350e1-137">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | <span data-ttu-id="350e1-138">Basso</span><span class="sxs-lookup"><span data-stu-id="350e1-138">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| `  var c1 = q1.First();`                                                                             | <span data-ttu-id="350e1-139">Esecuzione di query LINQ</span><span class="sxs-lookup"><span data-stu-id="350e1-139">LINQ query execution</span></span>      | <span data-ttu-id="350e1-140">- Caricamento dei metadati: alto ma memorizzato nella cache- Metadata loading: High but cached</span><span class="sxs-lookup"><span data-stu-id="350e1-140">- Metadata loading: High but cached</span></span> <br/> <span data-ttu-id="350e1-141">- Generazione della vista: potenzialmente molto alta ma memorizzata nella cache- View generation: Potentially very high but cached</span><span class="sxs-lookup"><span data-stu-id="350e1-141">- View generation: Potentially very high but cached</span></span> <br/> <span data-ttu-id="350e1-142">- Valutazione dei parametri: Media</span><span class="sxs-lookup"><span data-stu-id="350e1-142">- Parameter evaluation: Medium</span></span> <br/> <span data-ttu-id="350e1-143">- Traduzione di query: Medio</span><span class="sxs-lookup"><span data-stu-id="350e1-143">- Query translation: Medium</span></span> <br/> <span data-ttu-id="350e1-144">- Generazione di materializer: media ma memorizzata nella cache- Materialzer generation: Medium but cached</span><span class="sxs-lookup"><span data-stu-id="350e1-144">- Materializer generation: Medium but cached</span></span> <br/> <span data-ttu-id="350e1-145">- Esecuzione di query di database: potenzialmente elevata- Database query execution: Potentially high</span><span class="sxs-lookup"><span data-stu-id="350e1-145">- Database query execution: Potentially high</span></span> <br/> <span data-ttu-id="350e1-146">Connessione.Apri</span><span class="sxs-lookup"><span data-stu-id="350e1-146">+ Connection.Open</span></span> <br/> <span data-ttu-id="350e1-147">Comando.EsecuzioneReader</span><span class="sxs-lookup"><span data-stu-id="350e1-147">+ Command.ExecuteReader</span></span> <br/> <span data-ttu-id="350e1-148">DataReader.Read</span><span class="sxs-lookup"><span data-stu-id="350e1-148">+ DataReader.Read</span></span> <br/> <span data-ttu-id="350e1-149">Materializzazione dell'oggetto: Media</span><span class="sxs-lookup"><span data-stu-id="350e1-149">Object materialization: Medium</span></span> <br/> <span data-ttu-id="350e1-150">- Ricerca identità: Media</span><span class="sxs-lookup"><span data-stu-id="350e1-150">- Identity lookup: Medium</span></span> | <span data-ttu-id="350e1-151">- Caricamento dei metadati: alto ma memorizzato nella cache- Metadata loading: High but cached</span><span class="sxs-lookup"><span data-stu-id="350e1-151">- Metadata loading: High but cached</span></span> <br/> <span data-ttu-id="350e1-152">- Generazione della vista: potenzialmente molto alta ma memorizzata nella cache- View generation: Potentially very high but cached</span><span class="sxs-lookup"><span data-stu-id="350e1-152">- View generation: Potentially very high but cached</span></span> <br/> <span data-ttu-id="350e1-153">- Valutazione dei parametri: Bassa</span><span class="sxs-lookup"><span data-stu-id="350e1-153">- Parameter evaluation: Low</span></span> <br/> <span data-ttu-id="350e1-154">- Traduzione di query: media ma memorizzata nella cache- Query translation: Medium but cached</span><span class="sxs-lookup"><span data-stu-id="350e1-154">- Query translation: Medium but cached</span></span> <br/> <span data-ttu-id="350e1-155">- Generazione di materializer: media ma memorizzata nella cache- Materialzer generation: Medium but cached</span><span class="sxs-lookup"><span data-stu-id="350e1-155">- Materializer generation: Medium but cached</span></span> <br/> <span data-ttu-id="350e1-156">- Esecuzione di query di database: potenzialmente elevato (query migliori in alcune situazioni)- Database query execution: Potentially high (Better queries in some situations)</span><span class="sxs-lookup"><span data-stu-id="350e1-156">- Database query execution: Potentially high (Better queries in some situations)</span></span> <br/> <span data-ttu-id="350e1-157">Connessione.Apri</span><span class="sxs-lookup"><span data-stu-id="350e1-157">+ Connection.Open</span></span> <br/> <span data-ttu-id="350e1-158">Comando.EsecuzioneReader</span><span class="sxs-lookup"><span data-stu-id="350e1-158">+ Command.ExecuteReader</span></span> <br/> <span data-ttu-id="350e1-159">DataReader.Read</span><span class="sxs-lookup"><span data-stu-id="350e1-159">+ DataReader.Read</span></span> <br/> <span data-ttu-id="350e1-160">Materializzazione dell'oggetto: Media</span><span class="sxs-lookup"><span data-stu-id="350e1-160">Object materialization: Medium</span></span> <br/> <span data-ttu-id="350e1-161">- Ricerca identità: Media</span><span class="sxs-lookup"><span data-stu-id="350e1-161">- Identity lookup: Medium</span></span> | <span data-ttu-id="350e1-162">- Caricamento dei metadati: alto ma memorizzato nella cache- Metadata loading: High but cached</span><span class="sxs-lookup"><span data-stu-id="350e1-162">- Metadata loading: High but cached</span></span> <br/> <span data-ttu-id="350e1-163">- Generazione della vista: Media ma memorizzata nella cache- View generation: Medium but cached</span><span class="sxs-lookup"><span data-stu-id="350e1-163">- View generation: Medium but cached</span></span> <br/> <span data-ttu-id="350e1-164">- Valutazione dei parametri: Bassa</span><span class="sxs-lookup"><span data-stu-id="350e1-164">- Parameter evaluation: Low</span></span> <br/> <span data-ttu-id="350e1-165">- Traduzione di query: media ma memorizzata nella cache- Query translation: Medium but cached</span><span class="sxs-lookup"><span data-stu-id="350e1-165">- Query translation: Medium but cached</span></span> <br/> <span data-ttu-id="350e1-166">- Generazione di materializer: media ma memorizzata nella cache- Materialzer generation: Medium but cached</span><span class="sxs-lookup"><span data-stu-id="350e1-166">- Materializer generation: Medium but cached</span></span> <br/> <span data-ttu-id="350e1-167">- Esecuzione di query di database: potenzialmente elevato (query migliori in alcune situazioni)- Database query execution: Potentially high (Better queries in some situations)</span><span class="sxs-lookup"><span data-stu-id="350e1-167">- Database query execution: Potentially high (Better queries in some situations)</span></span> <br/> <span data-ttu-id="350e1-168">Connessione.Apri</span><span class="sxs-lookup"><span data-stu-id="350e1-168">+ Connection.Open</span></span> <br/> <span data-ttu-id="350e1-169">Comando.EsecuzioneReader</span><span class="sxs-lookup"><span data-stu-id="350e1-169">+ Command.ExecuteReader</span></span> <br/> <span data-ttu-id="350e1-170">DataReader.Read</span><span class="sxs-lookup"><span data-stu-id="350e1-170">+ DataReader.Read</span></span> <br/> <span data-ttu-id="350e1-171">Materializzazione dell'oggetto: Media (più veloce di EF5)</span><span class="sxs-lookup"><span data-stu-id="350e1-171">Object materialization: Medium (Faster than EF5)</span></span> <br/> <span data-ttu-id="350e1-172">- Ricerca identità: Media</span><span class="sxs-lookup"><span data-stu-id="350e1-172">- Identity lookup: Medium</span></span> |
| `}`                                                                                                  | <span data-ttu-id="350e1-173">Connection.Chiudi</span><span class="sxs-lookup"><span data-stu-id="350e1-173">Connection.Close</span></span>          | <span data-ttu-id="350e1-174">Basso</span><span class="sxs-lookup"><span data-stu-id="350e1-174">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                           | <span data-ttu-id="350e1-175">Basso</span><span class="sxs-lookup"><span data-stu-id="350e1-175">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | <span data-ttu-id="350e1-176">Basso</span><span class="sxs-lookup"><span data-stu-id="350e1-176">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |


<span data-ttu-id="350e1-177">**Seconda esecuzione query - query a caldo**</span><span class="sxs-lookup"><span data-stu-id="350e1-177">**Second Query Execution – warm query**</span></span>

| <span data-ttu-id="350e1-178">Scrittura utente codice</span><span class="sxs-lookup"><span data-stu-id="350e1-178">Code User Writes</span></span>                                                                                     | <span data-ttu-id="350e1-179">Azione</span><span class="sxs-lookup"><span data-stu-id="350e1-179">Action</span></span>                    | <span data-ttu-id="350e1-180">Impatto sulle prestazioni di EF4</span><span class="sxs-lookup"><span data-stu-id="350e1-180">EF4 Performance Impact</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | <span data-ttu-id="350e1-181">Impatto sulle prestazioni di EF5</span><span class="sxs-lookup"><span data-stu-id="350e1-181">EF5 Performance Impact</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | <span data-ttu-id="350e1-182">Impatto sulle prestazioni di EF6</span><span class="sxs-lookup"><span data-stu-id="350e1-182">EF6 Performance Impact</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
|:-----------------------------------------------------------------------------------------------------|:--------------------------|:--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `using(var db = new MyContext())` <br/> `{`                                                          | <span data-ttu-id="350e1-183">Creazione di contesto</span><span class="sxs-lookup"><span data-stu-id="350e1-183">Context creation</span></span>          | <span data-ttu-id="350e1-184">Media</span><span class="sxs-lookup"><span data-stu-id="350e1-184">Medium</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | <span data-ttu-id="350e1-185">Media</span><span class="sxs-lookup"><span data-stu-id="350e1-185">Medium</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | <span data-ttu-id="350e1-186">Basso</span><span class="sxs-lookup"><span data-stu-id="350e1-186">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| `  var q1 = ` <br/> `    from c in db.Customers` <br/> `    where c.Id == id1` <br/> `    select c;` | <span data-ttu-id="350e1-187">Creazione di espressioni di query</span><span class="sxs-lookup"><span data-stu-id="350e1-187">Query expression creation</span></span> | <span data-ttu-id="350e1-188">Basso</span><span class="sxs-lookup"><span data-stu-id="350e1-188">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | <span data-ttu-id="350e1-189">Basso</span><span class="sxs-lookup"><span data-stu-id="350e1-189">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | <span data-ttu-id="350e1-190">Basso</span><span class="sxs-lookup"><span data-stu-id="350e1-190">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| `  var c1 = q1.First();`                                                                             | <span data-ttu-id="350e1-191">Esecuzione di query LINQ</span><span class="sxs-lookup"><span data-stu-id="350e1-191">LINQ query execution</span></span>      | <span data-ttu-id="350e1-192">- Ricerca di caricamento dei metadati: ~~alta ma memorizzata nella cache~~ Bassa- Metadata ~~loading~~ lookup: High but cached Low</span><span class="sxs-lookup"><span data-stu-id="350e1-192">- Metadata ~~loading~~ lookup: ~~High but cached~~ Low</span></span> <br/> <span data-ttu-id="350e1-193">- Ricerca ~~generazione~~ vista: ~~potenzialmente molto alta ma memorizzata nella cache~~ Bassa</span><span class="sxs-lookup"><span data-stu-id="350e1-193">- View ~~generation~~ lookup: ~~Potentially very high but cached~~ Low</span></span> <br/> <span data-ttu-id="350e1-194">- Valutazione dei parametri: Media</span><span class="sxs-lookup"><span data-stu-id="350e1-194">- Parameter evaluation: Medium</span></span> <br/> <span data-ttu-id="350e1-195">- Ricerca ~~traduzione~~ query: Media</span><span class="sxs-lookup"><span data-stu-id="350e1-195">- Query ~~translation~~ lookup: Medium</span></span> <br/> <span data-ttu-id="350e1-196">- Ricerca ~~generation~~ generazione materializzatore: ~~media ma memorizzata nella cache~~ Bassa</span><span class="sxs-lookup"><span data-stu-id="350e1-196">- Materializer ~~generation~~ lookup: ~~Medium but cached~~ Low</span></span> <br/> <span data-ttu-id="350e1-197">- Esecuzione di query di database: potenzialmente elevata- Database query execution: Potentially high</span><span class="sxs-lookup"><span data-stu-id="350e1-197">- Database query execution: Potentially high</span></span> <br/> <span data-ttu-id="350e1-198">Connessione.Apri</span><span class="sxs-lookup"><span data-stu-id="350e1-198">+ Connection.Open</span></span> <br/> <span data-ttu-id="350e1-199">Comando.EsecuzioneReader</span><span class="sxs-lookup"><span data-stu-id="350e1-199">+ Command.ExecuteReader</span></span> <br/> <span data-ttu-id="350e1-200">DataReader.Read</span><span class="sxs-lookup"><span data-stu-id="350e1-200">+ DataReader.Read</span></span> <br/> <span data-ttu-id="350e1-201">Materializzazione dell'oggetto: Media</span><span class="sxs-lookup"><span data-stu-id="350e1-201">Object materialization: Medium</span></span> <br/> <span data-ttu-id="350e1-202">- Ricerca identità: Media</span><span class="sxs-lookup"><span data-stu-id="350e1-202">- Identity lookup: Medium</span></span> | <span data-ttu-id="350e1-203">- Ricerca di caricamento dei metadati: ~~alta ma memorizzata nella cache~~ Bassa- Metadata ~~loading~~ lookup: High but cached Low</span><span class="sxs-lookup"><span data-stu-id="350e1-203">- Metadata ~~loading~~ lookup: ~~High but cached~~ Low</span></span> <br/> <span data-ttu-id="350e1-204">- Ricerca ~~generazione~~ vista: ~~potenzialmente molto alta ma memorizzata nella cache~~ Bassa</span><span class="sxs-lookup"><span data-stu-id="350e1-204">- View ~~generation~~ lookup: ~~Potentially very high but cached~~ Low</span></span> <br/> <span data-ttu-id="350e1-205">- Valutazione dei parametri: Bassa</span><span class="sxs-lookup"><span data-stu-id="350e1-205">- Parameter evaluation: Low</span></span> <br/> <span data-ttu-id="350e1-206">- Ricerca ~~di traduzione~~ di query: ~~Media ma memorizzata nella cache~~ Bassa</span><span class="sxs-lookup"><span data-stu-id="350e1-206">- Query ~~translation~~ lookup: ~~Medium but cached~~ Low</span></span> <br/> <span data-ttu-id="350e1-207">- Ricerca ~~generation~~ generazione materializzatore: ~~media ma memorizzata nella cache~~ Bassa</span><span class="sxs-lookup"><span data-stu-id="350e1-207">- Materializer ~~generation~~ lookup: ~~Medium but cached~~ Low</span></span> <br/> <span data-ttu-id="350e1-208">- Esecuzione di query di database: potenzialmente elevato (query migliori in alcune situazioni)- Database query execution: Potentially high (Better queries in some situations)</span><span class="sxs-lookup"><span data-stu-id="350e1-208">- Database query execution: Potentially high (Better queries in some situations)</span></span> <br/> <span data-ttu-id="350e1-209">Connessione.Apri</span><span class="sxs-lookup"><span data-stu-id="350e1-209">+ Connection.Open</span></span> <br/> <span data-ttu-id="350e1-210">Comando.EsecuzioneReader</span><span class="sxs-lookup"><span data-stu-id="350e1-210">+ Command.ExecuteReader</span></span> <br/> <span data-ttu-id="350e1-211">DataReader.Read</span><span class="sxs-lookup"><span data-stu-id="350e1-211">+ DataReader.Read</span></span> <br/> <span data-ttu-id="350e1-212">Materializzazione dell'oggetto: Media</span><span class="sxs-lookup"><span data-stu-id="350e1-212">Object materialization: Medium</span></span> <br/> <span data-ttu-id="350e1-213">- Ricerca identità: Media</span><span class="sxs-lookup"><span data-stu-id="350e1-213">- Identity lookup: Medium</span></span> | <span data-ttu-id="350e1-214">- Ricerca di caricamento dei metadati: ~~alta ma memorizzata nella cache~~ Bassa- Metadata ~~loading~~ lookup: High but cached Low</span><span class="sxs-lookup"><span data-stu-id="350e1-214">- Metadata ~~loading~~ lookup: ~~High but cached~~ Low</span></span> <br/> <span data-ttu-id="350e1-215">- Ricerca ~~generazione~~ vista: ~~Media ma memorizzata nella cache~~ Bassa</span><span class="sxs-lookup"><span data-stu-id="350e1-215">- View ~~generation~~ lookup: ~~Medium but cached~~ Low</span></span> <br/> <span data-ttu-id="350e1-216">- Valutazione dei parametri: Bassa</span><span class="sxs-lookup"><span data-stu-id="350e1-216">- Parameter evaluation: Low</span></span> <br/> <span data-ttu-id="350e1-217">- Ricerca ~~di traduzione~~ di query: ~~Media ma memorizzata nella cache~~ Bassa</span><span class="sxs-lookup"><span data-stu-id="350e1-217">- Query ~~translation~~ lookup: ~~Medium but cached~~ Low</span></span> <br/> <span data-ttu-id="350e1-218">- Ricerca ~~generation~~ generazione materializzatore: ~~media ma memorizzata nella cache~~ Bassa</span><span class="sxs-lookup"><span data-stu-id="350e1-218">- Materializer ~~generation~~ lookup: ~~Medium but cached~~ Low</span></span> <br/> <span data-ttu-id="350e1-219">- Esecuzione di query di database: potenzialmente elevato (query migliori in alcune situazioni)- Database query execution: Potentially high (Better queries in some situations)</span><span class="sxs-lookup"><span data-stu-id="350e1-219">- Database query execution: Potentially high (Better queries in some situations)</span></span> <br/> <span data-ttu-id="350e1-220">Connessione.Apri</span><span class="sxs-lookup"><span data-stu-id="350e1-220">+ Connection.Open</span></span> <br/> <span data-ttu-id="350e1-221">Comando.EsecuzioneReader</span><span class="sxs-lookup"><span data-stu-id="350e1-221">+ Command.ExecuteReader</span></span> <br/> <span data-ttu-id="350e1-222">DataReader.Read</span><span class="sxs-lookup"><span data-stu-id="350e1-222">+ DataReader.Read</span></span> <br/> <span data-ttu-id="350e1-223">Materializzazione dell'oggetto: Media (più veloce di EF5)</span><span class="sxs-lookup"><span data-stu-id="350e1-223">Object materialization: Medium (Faster than EF5)</span></span> <br/> <span data-ttu-id="350e1-224">- Ricerca identità: Media</span><span class="sxs-lookup"><span data-stu-id="350e1-224">- Identity lookup: Medium</span></span> |
| `}`                                                                                                  | <span data-ttu-id="350e1-225">Connection.Chiudi</span><span class="sxs-lookup"><span data-stu-id="350e1-225">Connection.Close</span></span>          | <span data-ttu-id="350e1-226">Basso</span><span class="sxs-lookup"><span data-stu-id="350e1-226">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | <span data-ttu-id="350e1-227">Basso</span><span class="sxs-lookup"><span data-stu-id="350e1-227">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | <span data-ttu-id="350e1-228">Basso</span><span class="sxs-lookup"><span data-stu-id="350e1-228">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |


<span data-ttu-id="350e1-229">Esistono diversi modi per ridurre il costo delle prestazioni delle query a freddo e a caldo e verranno visualizzati nella sezione seguente.</span><span class="sxs-lookup"><span data-stu-id="350e1-229">There are several ways to reduce the performance cost of both cold and warm queries, and we'll take a look at these in the following section.</span></span> <span data-ttu-id="350e1-230">In particolare, si esaminerà la riduzione del costo del caricamento del modello nelle query a freddo utilizzando viste pregenerate, che dovrebbe contribuire ad alleviare i problemi di prestazioni riscontrati durante la generazione della visualizzazione.</span><span class="sxs-lookup"><span data-stu-id="350e1-230">Specifically, we'll look at reducing the cost of model loading in cold queries by using pre-generated views, which should help alleviate performance pains experienced during view generation.</span></span> <span data-ttu-id="350e1-231">Per le query a caldo, verranno illustrate la memorizzazione nella cache del piano di query, nessuna query di rilevamento e diverse opzioni di esecuzione delle query.</span><span class="sxs-lookup"><span data-stu-id="350e1-231">For warm queries, we'll cover query plan caching, no tracking queries, and different query execution options.</span></span>

### <a name="21-what-is-view-generation"></a><span data-ttu-id="350e1-232">2.1 Che cos'è la generazione di viste?</span><span class="sxs-lookup"><span data-stu-id="350e1-232">2.1 What is View Generation?</span></span>

<span data-ttu-id="350e1-233">Per comprendere che cos'è la generazione di viste, dobbiamo prima capire cosa sono le "Visualizzazioni di mapping".</span><span class="sxs-lookup"><span data-stu-id="350e1-233">In order to understand what view generation is, we must first understand what “Mapping Views” are.</span></span> <span data-ttu-id="350e1-234">Le visualizzazioni di mapping sono rappresentazioni eseguibili delle trasformazioni specificate nel mapping per ogni set di entità e associazione.</span><span class="sxs-lookup"><span data-stu-id="350e1-234">Mapping Views are executable representations of the transformations specified in the mapping for each entity set and association.</span></span> <span data-ttu-id="350e1-235">Internamente, queste visualizzazioni di mapping assumono la forma di CQT (alberi di query canonici).</span><span class="sxs-lookup"><span data-stu-id="350e1-235">Internally, these mapping views take the shape of CQTs (canonical query trees).</span></span> <span data-ttu-id="350e1-236">Esistono due tipi di viste di mapping:</span><span class="sxs-lookup"><span data-stu-id="350e1-236">There are two types of mapping views:</span></span>

-   <span data-ttu-id="350e1-237">Viste query: rappresentano la trasformazione necessaria per passare dallo schema del database al modello concettuale.</span><span class="sxs-lookup"><span data-stu-id="350e1-237">Query views: these represent the transformation necessary to go from the database schema to the conceptual model.</span></span>
-   <span data-ttu-id="350e1-238">Visualizzazioni di aggiornamento: rappresentano la trasformazione necessaria per passare dal modello concettuale allo schema del database.</span><span class="sxs-lookup"><span data-stu-id="350e1-238">Update views: these represent the transformation necessary to go from the conceptual model to the database schema.</span></span>

<span data-ttu-id="350e1-239">Tenere presente che il modello concettuale potrebbe differire dallo schema del database in vari modi.</span><span class="sxs-lookup"><span data-stu-id="350e1-239">Keep in mind that the conceptual model might differ from the database schema in various ways.</span></span> <span data-ttu-id="350e1-240">Ad esempio, una singola tabella può essere utilizzata per archiviare i dati per due tipi di entità diversi.</span><span class="sxs-lookup"><span data-stu-id="350e1-240">For example, one single table might be used to store the data for two different entity types.</span></span> <span data-ttu-id="350e1-241">Ereditarietà e mapping non banali svolgono un ruolo nella complessità delle visualizzazioni di mapping.</span><span class="sxs-lookup"><span data-stu-id="350e1-241">Inheritance and non-trivial mappings play a role in the complexity of the mapping views.</span></span>

<span data-ttu-id="350e1-242">Il processo di calcolo di queste visualizzazioni in base alla specifica del mapping è ciò che chiamiamo generazione di visualizzazioni.</span><span class="sxs-lookup"><span data-stu-id="350e1-242">The process of computing these views based on the specification of the mapping is what we call view generation.</span></span> <span data-ttu-id="350e1-243">La generazione della vista può avvenire in modo dinamico quando un modello viene caricato, o in fase di compilazione, utilizzando "viste pregenerate"; questi ultimi vengono serializzati sotto forma di istruzioni\# Entity SQL in un file C o VB.</span><span class="sxs-lookup"><span data-stu-id="350e1-243">View generation can either take place dynamically when a model is loaded, or at build time, by using "pre-generated views"; the latter are serialized in the form of Entity SQL statements to a C\# or VB file.</span></span>

<span data-ttu-id="350e1-244">Quando le visualizzazioni vengono generate, vengono convalidate anche.</span><span class="sxs-lookup"><span data-stu-id="350e1-244">When views are generated, they are also validated.</span></span> <span data-ttu-id="350e1-245">Dal punto di vista delle prestazioni, la maggior parte del costo della generazione della vista è in realtà la convalida delle viste che assicura che le connessioni tra le entità abbiano senso e abbiano la cardinalità corretta per tutte le operazioni supportate.</span><span class="sxs-lookup"><span data-stu-id="350e1-245">From a performance standpoint, the vast majority of the cost of view generation is actually the validation of the views which ensures that the connections between the entities make sense and have the correct cardinality for all the supported operations.</span></span>

<span data-ttu-id="350e1-246">Quando viene eseguita una query su un set di entità, la query viene combinata con la visualizzazione di query corrispondente e il risultato di questa composizione viene eseguito tramite il compilatore di piani per creare la rappresentazione della query che l'archivio di backup può comprendere.</span><span class="sxs-lookup"><span data-stu-id="350e1-246">When a query over an entity set is executed, the query is combined with the corresponding query view, and the result of this composition is run through the plan compiler to create the representation of the query that the backing store can understand.</span></span> <span data-ttu-id="350e1-247">Per SQL Server, il risultato finale di questa compilazione sarà un'istruzione T-SQL SELECT.</span><span class="sxs-lookup"><span data-stu-id="350e1-247">For SQL Server, the final result of this compilation will be a T-SQL SELECT statement.</span></span> <span data-ttu-id="350e1-248">La prima volta che viene eseguito un aggiornamento su un set di entità, la visualizzazione di aggiornamento viene eseguita tramite un processo simile per trasformarla in istruzioni DML per il database di destinazione.</span><span class="sxs-lookup"><span data-stu-id="350e1-248">The first time an update over an entity set is performed, the update view is run through a similar process to transform it into DML statements for the target database.</span></span>

### <a name="22-factors-that-affect-view-generation-performance"></a><span data-ttu-id="350e1-249">2.2 Fattori che influiscono sulle prestazioni di generazione della vista</span><span class="sxs-lookup"><span data-stu-id="350e1-249">2.2 Factors that affect View Generation performance</span></span>

<span data-ttu-id="350e1-250">Le prestazioni del passaggio di generazione della vista dipendono non solo dalle dimensioni del modello, ma anche da quanto è interconnesso il modello.</span><span class="sxs-lookup"><span data-stu-id="350e1-250">The performance of view generation step not only depends on the size of your model but also on how interconnected the model is.</span></span> <span data-ttu-id="350e1-251">Se due entità sono connesse tramite una catena di ereditarietà o un'associazione, si dice che siano connesse.</span><span class="sxs-lookup"><span data-stu-id="350e1-251">If two Entities are connected via an inheritance chain or an Association, they are said to be connected.</span></span> <span data-ttu-id="350e1-252">Analogamente, se due tabelle sono connesse tramite una chiave esterna, sono connesse.</span><span class="sxs-lookup"><span data-stu-id="350e1-252">Similarly if two tables are connected via a foreign key, they are connected.</span></span> <span data-ttu-id="350e1-253">Con l'aumento del numero di entità e tabelle connesse negli schemi, il costo di generazione della vista aumenta.</span><span class="sxs-lookup"><span data-stu-id="350e1-253">As the number of connected Entities and tables in your schemas increase, the view generation cost increases.</span></span>

<span data-ttu-id="350e1-254">L'algoritmo che usiamo per generare e convalidare le viste è esponenziale nel peggiore dei casi, anche se utilizziamo alcune ottimizzazioni per migliorare questo.</span><span class="sxs-lookup"><span data-stu-id="350e1-254">The algorithm that we use to generate and validate views is exponential in the worst case, though we do use some optimizations to improve this.</span></span> <span data-ttu-id="350e1-255">I fattori più importanti che sembrano influire negativamente sulle prestazioni sono:</span><span class="sxs-lookup"><span data-stu-id="350e1-255">The biggest factors that seem to negatively affect performance are:</span></span>

-   <span data-ttu-id="350e1-256">Dimensioni del modello, che fanno riferimento al numero di entità e alla quantità di associazioni tra queste entità.</span><span class="sxs-lookup"><span data-stu-id="350e1-256">Model size, referring to the number of entities and the amount of associations between these entities.</span></span>
-   <span data-ttu-id="350e1-257">Complessità del modello, in particolare l'ereditarietà che coinvolge un numero elevato di tipi.</span><span class="sxs-lookup"><span data-stu-id="350e1-257">Model complexity, specifically inheritance involving a large number of types.</span></span>
-   <span data-ttu-id="350e1-258">Utilizzo di associazioni indipendenti anziché di associazioni di chiavi esterne.</span><span class="sxs-lookup"><span data-stu-id="350e1-258">Using Independent Associations, instead of Foreign Key Associations.</span></span>

<span data-ttu-id="350e1-259">Per i modelli piccoli e semplici il costo può essere sufficientemente piccolo da non preoccuparsi di utilizzare viste pregenerate.</span><span class="sxs-lookup"><span data-stu-id="350e1-259">For small, simple models the cost may be small enough to not bother using pre-generated views.</span></span> <span data-ttu-id="350e1-260">Con l'aumento delle dimensioni e della complessità del modello, sono disponibili diverse opzioni per ridurre il costo della generazione e della convalida delle viste.</span><span class="sxs-lookup"><span data-stu-id="350e1-260">As model size and complexity increase, there are several options available to reduce the cost of view generation and validation.</span></span>

### <a name="23-using-pre-generated-views-to-decrease-model-load-time"></a><span data-ttu-id="350e1-261">2.3 Utilizzo di viste pregenerate per ridurre il tempo di caricamento del modello</span><span class="sxs-lookup"><span data-stu-id="350e1-261">2.3 Using Pre-Generated Views to decrease model load time</span></span>

<span data-ttu-id="350e1-262">Per informazioni dettagliate su come utilizzare le visualizzazioni pregenerate in Entity Framework 6, visitare le visualizzazioni di [mapping pregenerate](~/ef6/fundamentals/performance/pre-generated-views.md)</span><span class="sxs-lookup"><span data-stu-id="350e1-262">For detailed information on how to use pre-generated views on Entity Framework 6 visit [Pre-Generated Mapping Views](~/ef6/fundamentals/performance/pre-generated-views.md)</span></span>

#### <a name="231-pre-generated-views-using-the-entity-framework-power-tools-community-edition"></a><span data-ttu-id="350e1-263">2.3.1 Visualizzazioni pregenerate utilizzando Entity Framework Power Tools Community Edition</span><span class="sxs-lookup"><span data-stu-id="350e1-263">2.3.1 Pre-Generated views using the Entity Framework Power Tools Community Edition</span></span>

<span data-ttu-id="350e1-264">È possibile utilizzare [Entity Framework 6 Power Tools Community Edition](https://marketplace.visualstudio.com/items?itemName=ErikEJ.EntityFramework6PowerToolsCommunityEdition) per generare visualizzazioni dei modelli EDMX e Code First facendo clic con il pulsante destro del mouse sul file di classe del modello e utilizzando il menu Entity Framework per selezionare "Genera viste".</span><span class="sxs-lookup"><span data-stu-id="350e1-264">You can use the [Entity Framework 6 Power Tools Community Edition](https://marketplace.visualstudio.com/items?itemName=ErikEJ.EntityFramework6PowerToolsCommunityEdition) to generate views of EDMX and Code First models by right-clicking the model class file and using the Entity Framework menu to select “Generate Views”.</span></span> <span data-ttu-id="350e1-265">L'edizione della community di Entity Framework Power Tools funziona solo nei contesti derivati da DbContext.</span><span class="sxs-lookup"><span data-stu-id="350e1-265">The Entity Framework Power Tools Community Edition work only on DbContext-derived contexts.</span></span>

#### <a name="232-how-to-use-pre-generated-views-with-a-model-created-by-edmgen"></a><span data-ttu-id="350e1-266">2.3.2 Come utilizzare le viste pregenerate con un modello creato da EDMGen</span><span class="sxs-lookup"><span data-stu-id="350e1-266">2.3.2 How to use Pre-generated views with a model created by EDMGen</span></span>

<span data-ttu-id="350e1-267">EDMGen è un'utilità che viene fornita con .NET e funziona con Entity Framework 4 e 5, ma non con Entity Framework 6.</span><span class="sxs-lookup"><span data-stu-id="350e1-267">EDMGen is a utility that ships with .NET and works with Entity Framework 4 and 5, but not with Entity Framework 6.</span></span> <span data-ttu-id="350e1-268">EDMGen consente di generare un file di modello, il livello oggetto e le viste dalla riga di comando.</span><span class="sxs-lookup"><span data-stu-id="350e1-268">EDMGen allows you to generate a model file, the object layer and the views from the command line.</span></span> <span data-ttu-id="350e1-269">Uno degli output sarà un file Views nel linguaggio\#di scelta, VB o C .</span><span class="sxs-lookup"><span data-stu-id="350e1-269">One of the outputs will be a Views file in your language of choice, VB or C\#.</span></span> <span data-ttu-id="350e1-270">Si tratta di un file di codice contenente frammenti di Entity SQLEntity SQL per ogni set di entità.</span><span class="sxs-lookup"><span data-stu-id="350e1-270">This is a code file containing Entity SQL snippets for each entity set.</span></span> <span data-ttu-id="350e1-271">Per abilitare le visualizzazioni pregenerate, è sufficiente includere il file nel progetto.</span><span class="sxs-lookup"><span data-stu-id="350e1-271">To enable pre-generated views, you simply include the file in your project.</span></span>

<span data-ttu-id="350e1-272">Se si apportano manualmente modifiche ai file di schema per il modello, sarà necessario generare nuovamente il file delle viste.</span><span class="sxs-lookup"><span data-stu-id="350e1-272">If you manually make edits to the schema files for the model, you will need to re-generate the views file.</span></span> <span data-ttu-id="350e1-273">A tale scopo, eseguire EDMGen con il flag **/mode:ViewGeneration.**</span><span class="sxs-lookup"><span data-stu-id="350e1-273">You can do this by running EDMGen with the **/mode:ViewGeneration** flag.</span></span>

#### <a name="233-how-to-use-pre-generated-views-with-an-edmx-file"></a><span data-ttu-id="350e1-274">2.3.3 Come utilizzare le viste pre-generate con un file EDMX</span><span class="sxs-lookup"><span data-stu-id="350e1-274">2.3.3 How to use Pre-Generated Views with an EDMX file</span></span>

<span data-ttu-id="350e1-275">È inoltre possibile utilizzare EDMGen per generare visualizzazioni per un file EDMX - l'argomento MSDN a cui si fa riferimento in precedenza viene descritto come aggiungere un evento di pre-compilazione per eseguire questa operazione - ma questo è complicato e ci sono alcuni casi in cui non è possibile.</span><span class="sxs-lookup"><span data-stu-id="350e1-275">You can also use EDMGen to generate views for an EDMX file - the previously referenced MSDN topic describes how to add a pre-build event to do this - but this is complicated and there are some cases where it isn't possible.</span></span> <span data-ttu-id="350e1-276">In genere è più semplice usare un modello T4 per generare le viste quando il modello si trova in un file edmx.</span><span class="sxs-lookup"><span data-stu-id="350e1-276">It's generally easier to use a T4 template to generate the views when your model is in an edmx file.</span></span>

<span data-ttu-id="350e1-277">Il blog del team di ADO.NET contiene un post che descrive \< https://docs.microsoft.com/archive/blogs/adonet/how-to-use-a-t4-template-for-view-generation>)come utilizzare un modello T4 per la generazione di visualizzazioni ( .</span><span class="sxs-lookup"><span data-stu-id="350e1-277">The ADO.NET team blog has a post that describes how to use a T4 template for view generation ( \<https://docs.microsoft.com/archive/blogs/adonet/how-to-use-a-t4-template-for-view-generation>).</span></span> <span data-ttu-id="350e1-278">Questo post include un modello che può essere scaricato e aggiunto al progetto.</span><span class="sxs-lookup"><span data-stu-id="350e1-278">This post includes a template that can be downloaded and added to your project.</span></span> <span data-ttu-id="350e1-279">Il modello è stato scritto per la prima versione di Entity Framework, pertanto non è garantito che funzioni con le versioni più recenti di Entity Framework.</span><span class="sxs-lookup"><span data-stu-id="350e1-279">The template was written for the first version of Entity Framework, so they aren’t guaranteed to work with the latest versions of Entity Framework.</span></span> <span data-ttu-id="350e1-280">Tuttavia, è possibile scaricare un set più aggiornato di modelli di generazione della visualizzazione per Entity Framework 4 e 5 da Visual Studio Gallery:</span><span class="sxs-lookup"><span data-stu-id="350e1-280">However, you can download a more up-to-date set of view generation templates for Entity Framework 4 and 5from the Visual Studio Gallery:</span></span>

-   <span data-ttu-id="350e1-281">VB.NET:\<http://visualstudiogallery.msdn.microsoft.com/118b44f2-1b91-4de2-a584-7a680418941d></span><span class="sxs-lookup"><span data-stu-id="350e1-281">VB.NET: \<http://visualstudiogallery.msdn.microsoft.com/118b44f2-1b91-4de2-a584-7a680418941d></span></span>
-   <span data-ttu-id="350e1-282">C\#:\<http://visualstudiogallery.msdn.microsoft.com/ae7730ce-ddab-470f-8456-1b313cd2c44d></span><span class="sxs-lookup"><span data-stu-id="350e1-282">C\#: \<http://visualstudiogallery.msdn.microsoft.com/ae7730ce-ddab-470f-8456-1b313cd2c44d></span></span>

<span data-ttu-id="350e1-283">Se si utilizza Entity Framework 6 è possibile ottenere i modelli T4 di generazione della visualizzazione da Visual Studio Gallery all'indirizzo \< http://visualstudiogallery.msdn.microsoft.com/18a7db90-6705-4d19-9dd1-0a6c23d0751f>.</span><span class="sxs-lookup"><span data-stu-id="350e1-283">If you’re using Entity Framework 6 you can get the view generation T4 templates from the Visual Studio Gallery at \<http://visualstudiogallery.msdn.microsoft.com/18a7db90-6705-4d19-9dd1-0a6c23d0751f>.</span></span>

### <a name="24-reducing-the-cost-of-view-generation"></a><span data-ttu-id="350e1-284">2.4 Riduzione del costo di generazione della vista</span><span class="sxs-lookup"><span data-stu-id="350e1-284">2.4 Reducing the cost of view generation</span></span>

<span data-ttu-id="350e1-285">L'utilizzo di viste pregenerate sposta il costo della generazione della vista dal caricamento del modello (tempo di esecuzione) alla fase di progettazione.</span><span class="sxs-lookup"><span data-stu-id="350e1-285">Using pre-generated views moves the cost of view generation from model loading (run time) to design time.</span></span> <span data-ttu-id="350e1-286">Anche se questo migliora le prestazioni di avvio in fase di esecuzione, si verificherà ancora il dolore della generazione di visualizzazione durante lo sviluppo.</span><span class="sxs-lookup"><span data-stu-id="350e1-286">While this improves startup performance at runtime, you will still experience the pain of view generation while you are developing.</span></span> <span data-ttu-id="350e1-287">Esistono diversi trucchi aggiuntivi che consentono di ridurre il costo della generazione della visualizzazione, sia in fase di compilazione che in fase di esecuzione.</span><span class="sxs-lookup"><span data-stu-id="350e1-287">There are several additional tricks that can help reduce the cost of view generation, both at compile time and run time.</span></span>

#### <a name="241-using-foreign-key-associations-to-reduce-view-generation-cost"></a><span data-ttu-id="350e1-288">2.4.1 Utilizzo di associazioni di chiavi esterne per ridurre i costi di generazione della vista</span><span class="sxs-lookup"><span data-stu-id="350e1-288">2.4.1 Using Foreign Key Associations to reduce view generation cost</span></span>

<span data-ttu-id="350e1-289">Abbiamo visto un certo numero di casi in cui il passaggio delle associazioni nel modello da associazioni indipendenti ad associazioni di chiavi esterne ha migliorato notevolmente il tempo trascorso nella generazione della vista.</span><span class="sxs-lookup"><span data-stu-id="350e1-289">We have seen a number of cases where switching the associations in the model from Independent Associations to Foreign Key Associations dramatically improved the time spent in view generation.</span></span>

<span data-ttu-id="350e1-290">Per dimostrare questo miglioramento, abbiamo generato due versioni del modello Navision utilizzando EDMGen.</span><span class="sxs-lookup"><span data-stu-id="350e1-290">To demonstrate this improvement, we generated two versions of the Navision model by using EDMGen.</span></span> <span data-ttu-id="350e1-291">*Nota: vedere l'appendice C per una descrizione del modello Navision.*</span><span class="sxs-lookup"><span data-stu-id="350e1-291">*Note: see appendix C for a description of the Navision model.*</span></span> <span data-ttu-id="350e1-292">Il modello Navision è interessante per questo esercizio a causa della sua grande quantità di entità e delle relazioni tra di loro.</span><span class="sxs-lookup"><span data-stu-id="350e1-292">The Navision model is interesting for this exercise due to its very large amount of entities and relationships between them.</span></span>

<span data-ttu-id="350e1-293">Una versione di questo modello molto grande è stata generata con le associazioni di chiavi esterne e l'altra è stata generata con associazioni indipendenti.</span><span class="sxs-lookup"><span data-stu-id="350e1-293">One version of this very large model was generated with Foreign Keys Associations and the other was generated with Independent Associations.</span></span> <span data-ttu-id="350e1-294">Abbiamo quindi periodo il tempo necessario per generare le viste per ogni modello.</span><span class="sxs-lookup"><span data-stu-id="350e1-294">We then timed how long it took to generate the views for each model.</span></span> <span data-ttu-id="350e1-295">Il test di Entity Framework 5 ha utilizzato il metodo GenerateViews() della classe EntityViewGenerator per generare le visualizzazioni, mentre il test di Entity Framework 6 ha utilizzato il metodo GenerateViews() dalla classe StorageMappingItemCollection.</span><span class="sxs-lookup"><span data-stu-id="350e1-295">Entity Framework 5 test used the GenerateViews() method from class EntityViewGenerator to generate the views, while the Entity Framework 6 test used the GenerateViews() method from class StorageMappingItemCollection.</span></span> <span data-ttu-id="350e1-296">Ciò è dovuto alla ristrutturazione del codice che si è verificato nella codebase di Entity Framework 6.</span><span class="sxs-lookup"><span data-stu-id="350e1-296">This due to code restructuring that occurred in the Entity Framework 6 codebase.</span></span>

<span data-ttu-id="350e1-297">Utilizzando Entity Framework 5, la generazione di visualizzazioni per il modello con chiavi esterne ha richiesto 65 minuti in un computer lab.</span><span class="sxs-lookup"><span data-stu-id="350e1-297">Using Entity Framework 5, view generation for the model with Foreign Keys took 65 minutes in a lab machine.</span></span> <span data-ttu-id="350e1-298">Non è noto quanto tempo ci sarebbe voluto per generare le viste per il modello che utilizzava associazioni indipendenti.</span><span class="sxs-lookup"><span data-stu-id="350e1-298">It's unknown how long it would have taken to generate the views for the model that used independent associations.</span></span> <span data-ttu-id="350e1-299">Abbiamo lasciato il test in esecuzione per oltre un mese prima che la macchina è stato riavviato nel nostro laboratorio per installare gli aggiornamenti mensili.</span><span class="sxs-lookup"><span data-stu-id="350e1-299">We left the test running for over a month before the machine was rebooted in our lab to install monthly updates.</span></span>

<span data-ttu-id="350e1-300">Utilizzando Entity Framework 6, la generazione di visualizzazioni per il modello con chiavi esterne ha richiesto 28 secondi nello stesso computer lab.</span><span class="sxs-lookup"><span data-stu-id="350e1-300">Using Entity Framework 6, view generation for the model with Foreign Keys took 28 seconds in the same lab machine.</span></span> <span data-ttu-id="350e1-301">La generazione della vista per il modello che utilizza associazioni indipendenti ha richiesto 58 secondi.</span><span class="sxs-lookup"><span data-stu-id="350e1-301">View generation for the model that uses Independent Associations took 58 seconds.</span></span> <span data-ttu-id="350e1-302">I miglioramenti apportati a Entity Framework 6 nel codice di generazione della visualizzazione significano che molti progetti non avranno bisogno di visualizzazioni pregenerate per ottenere tempi di avvio più rapidi.</span><span class="sxs-lookup"><span data-stu-id="350e1-302">The improvements done to Entity Framework 6 on its view generation code mean that many projects won’t need pre-generated views to obtain faster startup times.</span></span>

<span data-ttu-id="350e1-303">È importante sottolineare che la pre-generazione di visualizzazioni in Entity Framework 4 e 5 può essere eseguita con EDMGen o Entity Framework Power Tools.</span><span class="sxs-lookup"><span data-stu-id="350e1-303">It’s important to remark that pre-generating views in Entity Framework 4 and 5 can be done with EDMGen or the Entity Framework Power Tools.</span></span> <span data-ttu-id="350e1-304">Per la generazione di visualizzazioni di Entity Framework 6 può essere eseguita tramite Entity Framework Power Tools o a livello di codice, come descritto in [Viste di mapping pre-generate](~/ef6/fundamentals/performance/pre-generated-views.md).</span><span class="sxs-lookup"><span data-stu-id="350e1-304">For Entity Framework 6 view generation can be done via the Entity Framework Power Tools or programmatically as described in [Pre-Generated Mapping Views](~/ef6/fundamentals/performance/pre-generated-views.md).</span></span>

##### <a name="2411-how-to-use-foreign-keys-instead-of-independent-associations"></a><span data-ttu-id="350e1-305">2.4.1.1 Utilizzo delle chiavi esterne anziché delle associazioni indipendenti</span><span class="sxs-lookup"><span data-stu-id="350e1-305">2.4.1.1 How to use Foreign Keys instead of Independent Associations</span></span>

<span data-ttu-id="350e1-306">Quando si usa EDMGen o Entity Designer in Visual Studio, si ottengono fKs per impostazione predefinita e accetta solo una singola casella di controllo o flag della riga di comando per passare tra FK e IA.</span><span class="sxs-lookup"><span data-stu-id="350e1-306">When using EDMGen or the Entity Designer in Visual Studio, you get FKs by default, and it only takes a single checkbox or command line flag to switch between FKs and IAs.</span></span>

<span data-ttu-id="350e1-307">Se si dispone di un modello Code First di grandi dimensioni, l'utilizzo di associazioni indipendenti avrà lo stesso effetto sulla generazione della vista.</span><span class="sxs-lookup"><span data-stu-id="350e1-307">If you have a large Code First model, using Independent Associations will have the same effect on view generation.</span></span> <span data-ttu-id="350e1-308">È possibile evitare questo impatto includendo le proprietà di chiave esterna nelle classi per gli oggetti dipendenti, anche se alcuni sviluppatori considereranno questo per inquinare il loro modello a oggetti.</span><span class="sxs-lookup"><span data-stu-id="350e1-308">You can avoid this impact by including Foreign Key properties on the classes for your dependent objects, though some developers will consider this to be polluting their object model.</span></span> <span data-ttu-id="350e1-309">È possibile trovare ulteriori informazioni \< http://blog.oneunicorn.com/2011/12/11/whats-the-deal-with-mapping-foreign-keys-using-the-entity-framework/>su questo argomento in .</span><span class="sxs-lookup"><span data-stu-id="350e1-309">You can find more information on this subject in \<http://blog.oneunicorn.com/2011/12/11/whats-the-deal-with-mapping-foreign-keys-using-the-entity-framework/>.</span></span>

| <span data-ttu-id="350e1-310">Quando si utilizza</span><span class="sxs-lookup"><span data-stu-id="350e1-310">When using</span></span>      | <span data-ttu-id="350e1-311">Procedere nel modo seguente</span><span class="sxs-lookup"><span data-stu-id="350e1-311">Do this</span></span>                                                                                                                                                                                                                                                                                                                              |
|:----------------|:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| <span data-ttu-id="350e1-312">Finestra di progettazione entità</span><span class="sxs-lookup"><span data-stu-id="350e1-312">Entity Designer</span></span> | <span data-ttu-id="350e1-313">Dopo aver aggiunto un'associazione tra due entità, assicurarsi di disporre di un vincolo referenziale.</span><span class="sxs-lookup"><span data-stu-id="350e1-313">After adding an association between two entities, make sure you have a referential constraint.</span></span> <span data-ttu-id="350e1-314">I vincoli referenziali indicano a Entity Framework di utilizzare le chiavi esterne anziché le associazioni indipendenti.</span><span class="sxs-lookup"><span data-stu-id="350e1-314">Referential constraints tell Entity Framework to use Foreign Keys instead of Independent Associations.</span></span> <span data-ttu-id="350e1-315">Per ulteriori \< https://docs.microsoft.com/archive/blogs/efdesign/foreign-keys-in-the-entity-framework>dettagli visita .</span><span class="sxs-lookup"><span data-stu-id="350e1-315">For additional details visit \<https://docs.microsoft.com/archive/blogs/efdesign/foreign-keys-in-the-entity-framework>.</span></span> |
| <span data-ttu-id="350e1-316">EDMGen</span><span class="sxs-lookup"><span data-stu-id="350e1-316">EDMGen</span></span>          | <span data-ttu-id="350e1-317">Quando si utilizza EDMGen per generare i file dal database, le chiavi esterne verranno rispettate e aggiunte al modello come tali.</span><span class="sxs-lookup"><span data-stu-id="350e1-317">When using EDMGen to generate your files from the database, your Foreign Keys will be respected and added to the model as such.</span></span> <span data-ttu-id="350e1-318">Per ulteriori informazioni sulle diverse opzioni esposte da EDMGen, visitare [http://msdn.microsoft.com/library/bb387165.aspx](https://msdn.microsoft.com/library/bb387165.aspx).</span><span class="sxs-lookup"><span data-stu-id="350e1-318">For more information on the different options exposed by EDMGen visit [http://msdn.microsoft.com/library/bb387165.aspx](https://msdn.microsoft.com/library/bb387165.aspx).</span></span>                           |
| <span data-ttu-id="350e1-319">Code First</span><span class="sxs-lookup"><span data-stu-id="350e1-319">Code First</span></span>      | <span data-ttu-id="350e1-320">Vedere la sezione "Convenzione sulle relazioni" dell'argomento [Convenzioni Code First](~/ef6/modeling/code-first/conventions/built-in.md) per informazioni su come includere le proprietà di chiave esterna negli oggetti dipendenti quando si utilizza Code First.</span><span class="sxs-lookup"><span data-stu-id="350e1-320">See the "Relationship Convention" section of the [Code First Conventions](~/ef6/modeling/code-first/conventions/built-in.md) topic for information on how to include foreign key properties on dependent objects when using Code First.</span></span>                                                                                              |

#### <a name="242-moving-your-model-to-a-separate-assembly"></a><span data-ttu-id="350e1-321">2.4.2 Spostamento del modello in un assieme separato</span><span class="sxs-lookup"><span data-stu-id="350e1-321">2.4.2 Moving your model to a separate assembly</span></span>

<span data-ttu-id="350e1-322">Quando il modello è incluso direttamente nel progetto dell'applicazione e si generano visualizzazioni tramite un evento di pre-compilazione o un modello T4, la generazione e la convalida della visualizzazione verranno eseguite ogni volta che il progetto viene ricompilato, anche se il modello non è stato modificato.</span><span class="sxs-lookup"><span data-stu-id="350e1-322">When your model is included directly in your application's project and you generate views through a pre-build event or a T4 template, view generation and validation will take place whenever the project is rebuilt, even if the model wasn't changed.</span></span> <span data-ttu-id="350e1-323">Se si sposta il modello in un assembly separato e vi si fa riferimento dal progetto dell'applicazione, è possibile apportare altre modifiche all'applicazione senza dover ricompilare il progetto contenente il modello.</span><span class="sxs-lookup"><span data-stu-id="350e1-323">If you move the model to a separate assembly and reference it from your application's project, you can make other changes to your application without needing to rebuild the project containing the model.</span></span>

<span data-ttu-id="350e1-324">*Nota:*  quando si sposta il modello in assembly separati ricordarsi di copiare le stringhe di connessione per il modello nel file di configurazione dell'applicazione del progetto client.</span><span class="sxs-lookup"><span data-stu-id="350e1-324">*Note:*  when moving your model to separate assemblies remember to copy the connection strings for the model into the application configuration file of the client project.</span></span>

#### <a name="243-disable-validation-of-an-edmx-based-model"></a><span data-ttu-id="350e1-325">2.4.3 Disabilitare la convalida di un modello basato su edmx</span><span class="sxs-lookup"><span data-stu-id="350e1-325">2.4.3 Disable validation of an edmx-based model</span></span>

<span data-ttu-id="350e1-326">I modelli EDMX vengono convalidati in fase di compilazione, anche se il modello è invariato.</span><span class="sxs-lookup"><span data-stu-id="350e1-326">EDMX models are validated at compile time, even if the model is unchanged.</span></span> <span data-ttu-id="350e1-327">Se il modello è già stato convalidato, è possibile eliminare la convalida in fase di compilazione impostando la proprietà "Convalida in fase di compilazione" su false nella finestra delle proprietà.</span><span class="sxs-lookup"><span data-stu-id="350e1-327">If your model has already been validated, you can suppress validation at compile time by setting the "Validate on Build" property to false in the properties window.</span></span> <span data-ttu-id="350e1-328">Quando si modifica il mapping o il modello, è possibile riattivare temporaneamente la convalida per verificare le modifiche.</span><span class="sxs-lookup"><span data-stu-id="350e1-328">When you change your mapping or model, you can temporarily re-enable validation to verify your changes.</span></span>

<span data-ttu-id="350e1-329">Si noti che sono stati apportati miglioramenti delle prestazioni a Entity Framework Designer per Entity Framework 6 e il costo di "Convalida in fase di compilazione" è molto inferiore rispetto alle versioni precedenti della finestra di progettazione.</span><span class="sxs-lookup"><span data-stu-id="350e1-329">Note that performance improvements were made to the Entity Framework Designer for Entity Framework 6, and the cost of the “Validate on Build” is much lower than in previous versions of the designer.</span></span>

## <a name="3-caching-in-the-entity-framework"></a><span data-ttu-id="350e1-330">3 Memorizzazione nella cache in Entity Framework</span><span class="sxs-lookup"><span data-stu-id="350e1-330">3 Caching in the Entity Framework</span></span>

<span data-ttu-id="350e1-331">Entity Framework dispone delle seguenti forme di memorizzazione nella cache incorporate:</span><span class="sxs-lookup"><span data-stu-id="350e1-331">Entity Framework has the following forms of caching built-in:</span></span>

1.  <span data-ttu-id="350e1-332">Memorizzazione nella cache degli oggetti: ObjectStateManager incorporato in un'istanza ObjectContext tiene traccia degli oggetti recuperati utilizzando tale istanza.</span><span class="sxs-lookup"><span data-stu-id="350e1-332">Object caching – the ObjectStateManager built into an ObjectContext instance keeps track in memory of the objects that have been retrieved using that instance.</span></span> <span data-ttu-id="350e1-333">Questa operazione è nota anche come cache di primo livello.</span><span class="sxs-lookup"><span data-stu-id="350e1-333">This is also known as first-level cache.</span></span>
2.  <span data-ttu-id="350e1-334">Memorizzazione nella cache del piano di query: riutilizzo del comando di archivio generato quando una query viene eseguita più di una volta.</span><span class="sxs-lookup"><span data-stu-id="350e1-334">Query Plan Caching - reusing the generated store command when a query is executed more than once.</span></span>
3.  <span data-ttu-id="350e1-335">Memorizzazione nella cache dei metadati: condivisione dei metadati per un modello tra connessioni diverse allo stesso modello.</span><span class="sxs-lookup"><span data-stu-id="350e1-335">Metadata caching - sharing the metadata for a model across different connections to the same model.</span></span>

<span data-ttu-id="350e1-336">Oltre alle cache fornite da Entity Framework, è possibile utilizzare anche un tipo speciale di provider di dati di ADO.NET noto come provider di wrapping per estendere Entity Framework con una cache per i risultati recuperati dal database, noto anche come memorizzazione nella cache di secondo livello.</span><span class="sxs-lookup"><span data-stu-id="350e1-336">Besides the caches that EF provides out of the box, a special kind of ADO.NET data provider known as a wrapping provider can also be used to extend Entity Framework with a cache for the results retrieved from the database, also known as second-level caching.</span></span>

### <a name="31-object-caching"></a><span data-ttu-id="350e1-337">3.1 Memorizzazione nella cache degli oggetti</span><span class="sxs-lookup"><span data-stu-id="350e1-337">3.1 Object Caching</span></span>

<span data-ttu-id="350e1-338">Per impostazione predefinita, quando un'entità viene restituita nei risultati di una query, appena prima che Entity Framework la materializzi, ObjectContext controllerà se un'entità con la stessa chiave è già stata caricata nel relativo ObjectStateManager.By default when an entity is returned in the results of a query, just before EF materializes, the ObjectContext will check if an entity with the same key has already been loaded into its ObjectStateManager.</span><span class="sxs-lookup"><span data-stu-id="350e1-338">By default when an entity is returned in the results of a query, just before EF materializes it, the ObjectContext will check if an entity with the same key has already been loaded into its ObjectStateManager.</span></span> <span data-ttu-id="350e1-339">Se un'entità con le stesse chiavi è già presente Entity Framework includerà nei risultati della query.</span><span class="sxs-lookup"><span data-stu-id="350e1-339">If an entity with the same keys is already present EF will include it in the results of the query.</span></span> <span data-ttu-id="350e1-340">Anche se Entity Framework emetterà comunque la query sul database, questo comportamento può ignorare gran parte del costo di materializzazione dell'entità più volte.</span><span class="sxs-lookup"><span data-stu-id="350e1-340">Although EF will still issue the query against the database, this behavior can bypass much of the cost of materializing the entity multiple times.</span></span>

#### <a name="311-getting-entities-from-the-object-cache-using-dbcontext-find"></a><span data-ttu-id="350e1-341">3.1.1 Recupero di entità dalla cache degli oggetti tramite La ricerca DbContext</span><span class="sxs-lookup"><span data-stu-id="350e1-341">3.1.1 Getting entities from the object cache using DbContext Find</span></span>

<span data-ttu-id="350e1-342">A differenza di una query normale, il metodo Find in DbSet (API incluse per la prima volta in EF 4.1) eseguirà una ricerca in memoria prima ancora di eseguire la query sul database.</span><span class="sxs-lookup"><span data-stu-id="350e1-342">Unlike a regular query, the Find method in DbSet (APIs included for the first time in EF 4.1) will perform a search in memory before even issuing the query against the database.</span></span> <span data-ttu-id="350e1-343">È importante notare che due diverse istanze ObjectContext avranno due diverse istanze di ObjectStateManager, ovvero hanno cache degli oggetti separate.</span><span class="sxs-lookup"><span data-stu-id="350e1-343">It’s important to note that two different ObjectContext instances will have two different ObjectStateManager instances, meaning that they have separate object caches.</span></span>

<span data-ttu-id="350e1-344">Find usa il valore della chiave primaria per tentare di trovare un'entità rilevata dal contesto.</span><span class="sxs-lookup"><span data-stu-id="350e1-344">Find uses the primary key value to attempt to find an entity tracked by the context.</span></span> <span data-ttu-id="350e1-345">Se l'entità non si trova nel contesto, verrà eseguita una query e valutata sul database e viene restituito null se l'entità non viene trovata nel contesto o nel database.</span><span class="sxs-lookup"><span data-stu-id="350e1-345">If the entity is not in the context then a query will be executed and evaluated against the database, and null is returned if the entity is not found in the context or in the database.</span></span> <span data-ttu-id="350e1-346">Si noti che Find restituisce anche le entità che sono state aggiunte al contesto ma non sono ancora state salvate nel database.</span><span class="sxs-lookup"><span data-stu-id="350e1-346">Note that Find also returns entities that have been added to the context but have not yet been saved to the database.</span></span>

<span data-ttu-id="350e1-347">C'è una considerazione delle prestazioni da prendere quando si utilizza Find.</span><span class="sxs-lookup"><span data-stu-id="350e1-347">There is a performance consideration to be taken when using Find.</span></span> <span data-ttu-id="350e1-348">Le chiamate a questo metodo per impostazione predefinita attiveranno una convalida della cache degli oggetti per rilevare le modifiche ancora in attesa di commit nel database.</span><span class="sxs-lookup"><span data-stu-id="350e1-348">Invocations to this method by default will trigger a validation of the object cache in order to detect changes that are still pending commit to the database.</span></span> <span data-ttu-id="350e1-349">Questo processo può essere molto costoso se è presente un numero molto elevato di oggetti nella cache degli oggetti o in un oggetto grafico di grandi dimensioni aggiunto alla cache degli oggetti, ma può anche essere disabilitato.</span><span class="sxs-lookup"><span data-stu-id="350e1-349">This process can be very expensive if there are a very large number of objects in the object cache or in a large object graph being added to the object cache, but it can also be disabled.</span></span> <span data-ttu-id="350e1-350">In alcuni casi, è possibile percepire l'ordine di grandezza della differenza nella chiamata al metodo Find quando si disabilita il rilevamento automatico delle modifiche.</span><span class="sxs-lookup"><span data-stu-id="350e1-350">In certain cases, you may perceive over an order of magnitude of difference in calling the Find method when you disable auto detect changes.</span></span> <span data-ttu-id="350e1-351">Tuttavia, un secondo ordine di grandezza viene percepito quando l'oggetto si trova effettivamente nella cache rispetto a quando l'oggetto deve essere recuperato dal database.</span><span class="sxs-lookup"><span data-stu-id="350e1-351">Yet a second order of magnitude is perceived when the object actually is in the cache versus when the object has to be retrieved from the database.</span></span> <span data-ttu-id="350e1-352">Ecco un grafico di esempio con misure effettuate utilizzando alcuni dei nostri microbenchmark, espressi in millisecondi, con un carico di 5000 entità:</span><span class="sxs-lookup"><span data-stu-id="350e1-352">Here is an example graph with measurements taken using some of our microbenchmarks, expressed in milliseconds, with a load of 5000 entities:</span></span>

<span data-ttu-id="350e1-353">![Scala logaritmica .NET 4.5](~/ef6/media/net45logscale.png ".NET 4.5 - scala logaritmica")</span><span class="sxs-lookup"><span data-stu-id="350e1-353">![.NET 4.5 logarithmic scale](~/ef6/media/net45logscale.png ".NET 4.5 - logarithmic scale")</span></span>

<span data-ttu-id="350e1-354">Esempio di ricerca con rilevamento automatico delle modifiche disabilitato:</span><span class="sxs-lookup"><span data-stu-id="350e1-354">Example of Find with auto-detect changes disabled:</span></span>

``` csharp
    context.Configuration.AutoDetectChangesEnabled = false;
    var product = context.Products.Find(productId);
    context.Configuration.AutoDetectChangesEnabled = true;
    ...
```

<span data-ttu-id="350e1-355">Quello che dovete considerare quando si utilizza il Find metodo è:</span><span class="sxs-lookup"><span data-stu-id="350e1-355">What you have to consider when using the Find method is:</span></span>

1.  <span data-ttu-id="350e1-356">Se l'oggetto non è nella cache, i vantaggi di Find vengono negati, ma la sintassi è ancora più semplice di una query per chiave.</span><span class="sxs-lookup"><span data-stu-id="350e1-356">If the object is not in the cache the benefits of Find are negated, but the syntax is still simpler than a query by key.</span></span>
2.  <span data-ttu-id="350e1-357">Se il rilevamento automatico delle modifiche è abilitato, il costo del metodo Find può aumentare di un ordine di grandezza o anche di più a seconda della complessità del modello e della quantità di entità nella cache degli oggetti.</span><span class="sxs-lookup"><span data-stu-id="350e1-357">If auto detect changes is enabled the cost of the Find method may increase by one order of magnitude, or even more depending on the complexity of your model and the amount of entities in your object cache.</span></span>

<span data-ttu-id="350e1-358">Inoltre, tenere presente che Find restituisce solo l'entità che si sta cercando e non carica automaticamente le entità associate se non sono già presenti nella cache degli oggetti.</span><span class="sxs-lookup"><span data-stu-id="350e1-358">Also, keep in mind that Find only returns the entity you are looking for and it does not automatically loads its associated entities if they are not already in the object cache.</span></span> <span data-ttu-id="350e1-359">Se è necessario recuperare le entità associate, è possibile usare una query con la chiave con caricamento eager.</span><span class="sxs-lookup"><span data-stu-id="350e1-359">If you need to retrieve associated entities, you can use a query by key with eager loading.</span></span> <span data-ttu-id="350e1-360">Per ulteriori informazioni, vedere **8.1 Caricamento lazy e caricamento eager**.</span><span class="sxs-lookup"><span data-stu-id="350e1-360">For more information see **8.1 Lazy Loading vs. Eager Loading**.</span></span>

#### <a name="312-performance-issues-when-the-object-cache-has-many-entities"></a><span data-ttu-id="350e1-361">3.1.2 Problemi di prestazioni quando la cache degli oggetti ha molte entità</span><span class="sxs-lookup"><span data-stu-id="350e1-361">3.1.2 Performance issues when the object cache has many entities</span></span>

<span data-ttu-id="350e1-362">La cache degli oggetti consente di aumentare la velocità di risposta complessiva di Entity Framework.</span><span class="sxs-lookup"><span data-stu-id="350e1-362">The object cache helps to increase the overall responsiveness of Entity Framework.</span></span> <span data-ttu-id="350e1-363">Tuttavia, quando la cache degli oggetti ha una grande quantità di entità caricate può influire su determinate operazioni, ad esempio Add, Remove, Find, Entry, SaveChanges e altro ancora.</span><span class="sxs-lookup"><span data-stu-id="350e1-363">However, when the object cache has a very large amount of entities loaded it may affect certain operations such as Add, Remove, Find, Entry, SaveChanges and more.</span></span> <span data-ttu-id="350e1-364">In particolare, le operazioni che attivano una chiamata a DetectChanges saranno influenzate negativamente da cache di oggetti molto grandi.</span><span class="sxs-lookup"><span data-stu-id="350e1-364">In particular, operations that trigger a call to DetectChanges will be negatively affected by very large object caches.</span></span> <span data-ttu-id="350e1-365">DetectChanges sincronizza l'oggetto grafico con il gestore dello stato degli oggetti e le relative prestazioni verranno determinate direttamente dalle dimensioni dell'oggetto grafico.</span><span class="sxs-lookup"><span data-stu-id="350e1-365">DetectChanges synchronizes the object graph with the object state manager and its performance will determined directly by the size of the object graph.</span></span> <span data-ttu-id="350e1-366">Per ulteriori informazioni su DetectChanges, vedere [Rilevamento delle modifiche nelle entità POCO](https://msdn.microsoft.com/library/dd456848.aspx).</span><span class="sxs-lookup"><span data-stu-id="350e1-366">For more information about DetectChanges, see [Tracking Changes in POCO Entities](https://msdn.microsoft.com/library/dd456848.aspx).</span></span>

<span data-ttu-id="350e1-367">Quando si usa Entity Framework 6, gli sviluppatori sono in grado di chiamare AddRange e RemoveRange direttamente su un DbSet, anziché scorrere su una raccolta e chiamare Add una volta per istanza.</span><span class="sxs-lookup"><span data-stu-id="350e1-367">When using Entity Framework 6, developers are able to call AddRange and RemoveRange directly on a DbSet, instead of iterating on a collection and calling Add once per instance.</span></span> <span data-ttu-id="350e1-368">Il vantaggio dell'utilizzo dei metodi di intervallo è che il costo di DetectChanges viene pagato una sola volta per l'intero set di entità anziché una volta per ogni entità aggiunta.</span><span class="sxs-lookup"><span data-stu-id="350e1-368">The advantage of using the range methods is that the cost of DetectChanges is only paid once for the entire set of entities as opposed to once per each added entity.</span></span>

### <a name="32-query-plan-caching"></a><span data-ttu-id="350e1-369">3.2 Memorizzazione nella cache del piano di query</span><span class="sxs-lookup"><span data-stu-id="350e1-369">3.2 Query Plan Caching</span></span>

<span data-ttu-id="350e1-370">La prima volta che viene eseguita una query, passa attraverso il compilatore piano interno per convertire la query concettuale nel comando store (ad esempio, il T-SQL che viene eseguito quando viene eseguito su SQL Server).</span><span class="sxs-lookup"><span data-stu-id="350e1-370">The first time a query is executed, it goes through the internal plan compiler to translate the conceptual query into the store command (for example, the T-SQL which is executed when run against SQL Server).</span></span><span data-ttu-id="350e1-371">Se la memorizzazione nella cache del piano di query è abilitata, la volta successiva che la query viene eseguita il comando di archivio viene recuperato direttamente dalla cache del piano di query per l'esecuzione, ignorando il compilatore del piano.</span><span class="sxs-lookup"><span data-stu-id="350e1-371">  If query plan caching is enabled, the next time the query is executed the store command is retrieved directly from the query plan cache for execution, bypassing the plan compiler.</span></span>

<span data-ttu-id="350e1-372">The query plan cache is shared across ObjectContext instances within the same AppDomain.</span><span class="sxs-lookup"><span data-stu-id="350e1-372">The query plan cache is shared across ObjectContext instances within the same AppDomain.</span></span> <span data-ttu-id="350e1-373">Non è necessario mantenere un'istanza ObjectContext per trarre vantaggio dalla memorizzazione nella cache del piano di query.</span><span class="sxs-lookup"><span data-stu-id="350e1-373">You don't need to hold onto an ObjectContext instance to benefit from query plan caching.</span></span>

#### <a name="321-some-notes-about-query-plan-caching"></a><span data-ttu-id="350e1-374">3.2.1 Alcune note sulla memorizzazione nella cache del piano di query</span><span class="sxs-lookup"><span data-stu-id="350e1-374">3.2.1 Some notes about Query Plan Caching</span></span>

-   <span data-ttu-id="350e1-375">La cache del piano di query è condivisa per tutti i tipi di query: Entity SQLEntity SQL, LINQ to Entities e CompiledQuery oggetti.</span><span class="sxs-lookup"><span data-stu-id="350e1-375">The query plan cache is shared for all query types: Entity SQL, LINQ to Entities, and CompiledQuery objects.</span></span>
-   <span data-ttu-id="350e1-376">Per impostazione predefinita, la memorizzazione nella cache del piano di query è abilitata per le query Entity SQLEntity SQL, sia eseguite tramite un EntityCommand o tramite objectQuery.By default, query plan caching is enabled for Entity SQL queries, whether executed through a EntityCommand or through an ObjectQuery.</span><span class="sxs-lookup"><span data-stu-id="350e1-376">By default, query plan caching is enabled for Entity SQL queries, whether executed through an EntityCommand or through an ObjectQuery.</span></span> <span data-ttu-id="350e1-377">È inoltre abilitato per impostazione predefinita per le query LINQ to Entities in Entity Framework in .NET 4.5 e in Entity Framework 6</span><span class="sxs-lookup"><span data-stu-id="350e1-377">It is also enabled by default for LINQ to Entities queries in Entity Framework on .NET 4.5, and in Entity Framework 6</span></span>
    -   <span data-ttu-id="350e1-378">La memorizzazione nella cache del piano di query può essere disabilitata impostando la proprietà EnablePlanCaching (in EntityCommand o ObjectQuery) su false.</span><span class="sxs-lookup"><span data-stu-id="350e1-378">Query plan caching can be disabled by setting the EnablePlanCaching property (on EntityCommand or ObjectQuery) to false.</span></span> <span data-ttu-id="350e1-379">Ad esempio:</span><span class="sxs-lookup"><span data-stu-id="350e1-379">For example:</span></span>
``` csharp
                    var query = from customer in context.Customer
                                where customer.CustomerId == id
                                select new
                                {
                                    customer.CustomerId,
                                    customer.Name
                                };
                    ObjectQuery oQuery = query as ObjectQuery;
                    oQuery.EnablePlanCaching = false;
```
-   <span data-ttu-id="350e1-380">Per le query con parametri, la modifica del valore del parametro colpirà comunque la query memorizzata nella cache.</span><span class="sxs-lookup"><span data-stu-id="350e1-380">For parameterized queries, changing the parameter's value will still hit the cached query.</span></span> <span data-ttu-id="350e1-381">Tuttavia, la modifica dei facet di un parametro (ad esempio, dimensioni, precisione o scala) raggiungerà una voce diversa nella cache.</span><span class="sxs-lookup"><span data-stu-id="350e1-381">But changing a parameter's facets (for example, size, precision, or scale) will hit a different entry in the cache.</span></span>
-   <span data-ttu-id="350e1-382">Quando si usa Entity SQLEntity SQL, la stringa di query fa parte della chiave.</span><span class="sxs-lookup"><span data-stu-id="350e1-382">When using Entity SQL, the query string is part of the key.</span></span> <span data-ttu-id="350e1-383">La modifica della query comporterà voci della cache diverse, anche se le query sono equivalenti dal punto di lavoro.</span><span class="sxs-lookup"><span data-stu-id="350e1-383">Changing the query at all will result in different cache entries, even if the queries are functionally equivalent.</span></span> <span data-ttu-id="350e1-384">Sono incluse le modifiche alle maiuscole e minuscole o agli spazi vuoti.</span><span class="sxs-lookup"><span data-stu-id="350e1-384">This includes changes to casing or whitespace.</span></span>
-   <span data-ttu-id="350e1-385">Quando si usa LINQ, la query viene elaborata per generare una parte della chiave.</span><span class="sxs-lookup"><span data-stu-id="350e1-385">When using LINQ, the query is processed to generate a part of the key.</span></span> <span data-ttu-id="350e1-386">La modifica dell'espressione LINQ genererà pertanto una chiave diversa.</span><span class="sxs-lookup"><span data-stu-id="350e1-386">Changing the LINQ expression will therefore generate a different key.</span></span>
-   <span data-ttu-id="350e1-387">Possono essere applicate altre limitazioni tecniche; Per ulteriori dettagli, vedere Query compilate automaticamente.</span><span class="sxs-lookup"><span data-stu-id="350e1-387">Other technical limitations may apply; see Autocompiled Queries for more details.</span></span>

#### <a name="322-cache-eviction-algorithm"></a><span data-ttu-id="350e1-388">3.2.2 Algoritmo di sfratto della cache</span><span class="sxs-lookup"><span data-stu-id="350e1-388">3.2.2      Cache eviction algorithm</span></span>

<span data-ttu-id="350e1-389">Comprendere il funzionamento dell'algoritmo interno consente di capire quando abilitare o disabilitare la memorizzazione nella cache del piano di query.</span><span class="sxs-lookup"><span data-stu-id="350e1-389">Understanding how the internal algorithm works will help you figure out when to enable or disable query plan caching.</span></span> <span data-ttu-id="350e1-390">L'algoritmo di pulizia è il seguente:The cleanup algorithm is as follows:</span><span class="sxs-lookup"><span data-stu-id="350e1-390">The cleanup algorithm is as follows:</span></span>

1.  <span data-ttu-id="350e1-391">Una volta che la cache contiene un numero impostato di voci (800), viene avviato un timer che periodicamente (una volta al minuto) spazza la cache.</span><span class="sxs-lookup"><span data-stu-id="350e1-391">Once the cache contains a set number of entries (800), we start a timer that periodically (once-per-minute) sweeps the cache.</span></span>
2.  <span data-ttu-id="350e1-392">Durante gli sweep della cache, le voci vengono rimosse dalla cache su base LFRU (meno frequentemente - utilizzati di recente).</span><span class="sxs-lookup"><span data-stu-id="350e1-392">During cache sweeps, entries are removed from the cache on a LFRU (Least frequently – recently used) basis.</span></span> <span data-ttu-id="350e1-393">Questo algoritmo prende in considerazione sia il numero di hit che l'età quando si decide quali voci vengono espulse.</span><span class="sxs-lookup"><span data-stu-id="350e1-393">This algorithm takes both hit count and age into account when deciding which entries are ejected.</span></span>
3.  <span data-ttu-id="350e1-394">Alla fine di ogni sweep della cache, la cache contiene nuovamente 800 voci.</span><span class="sxs-lookup"><span data-stu-id="350e1-394">At the end of each cache sweep, the cache again contains 800 entries.</span></span>

<span data-ttu-id="350e1-395">Tutte le voci della cache vengono trattate allo stesso modo quando si determina quali voci rimuovere.</span><span class="sxs-lookup"><span data-stu-id="350e1-395">All cache entries are treated equally when determining which entries to evict.</span></span> <span data-ttu-id="350e1-396">Ciò significa che il comando store per un oggetto CompiledQuery ha le stesse probabilità di rimozione del comando store per una query Entity SQL.</span><span class="sxs-lookup"><span data-stu-id="350e1-396">This means the store command for a CompiledQuery has the same chance of eviction as the store command for an Entity SQL query.</span></span>

<span data-ttu-id="350e1-397">Si noti che il timer di rimozione della cache viene avviato quando sono presenti 800 entità nella cache, ma la cache viene sottoposta a sweep solo da 60 secondi dopo l'avvio del timer.</span><span class="sxs-lookup"><span data-stu-id="350e1-397">Note that the cache eviction timer is kicked in when there are 800 entities in the cache, but the cache is only swept 60 seconds after this timer is started.</span></span> <span data-ttu-id="350e1-398">Ciò significa che per un massimo di 60 secondi la cache può aumentare fino a diventare piuttosto grande.</span><span class="sxs-lookup"><span data-stu-id="350e1-398">That means that for up to 60 seconds your cache may grow to be quite large.</span></span>

#### <a name="323-test-metrics-demonstrating-query-plan-caching-performance"></a><span data-ttu-id="350e1-399">3.2.3 Metriche di test che illustrano le prestazioni di memorizzazione nella cache del piano di query</span><span class="sxs-lookup"><span data-stu-id="350e1-399">3.2.3       Test Metrics demonstrating query plan caching performance</span></span>

<span data-ttu-id="350e1-400">Per illustrare l'effetto della memorizzazione nella cache del piano di query sulle prestazioni dell'applicazione, è stato eseguito un test in cui sono state eseguite numerose query Entity SQLEntity SQL sul modello Navision.</span><span class="sxs-lookup"><span data-stu-id="350e1-400">To demonstrate the effect of query plan caching on your application's performance, we performed a test where we executed a number of Entity SQL queries against the Navision model.</span></span> <span data-ttu-id="350e1-401">Vedere l'appendice per una descrizione del modello Navision e i tipi di query che sono state eseguite.</span><span class="sxs-lookup"><span data-stu-id="350e1-401">See the appendix for a description of the Navision model and the types of queries which were executed.</span></span> <span data-ttu-id="350e1-402">In questo test, per prima cosa scorriamo l'elenco delle query ed eseguiamo ognuna una volta per aggiungerle alla cache (se la memorizzazione nella cache è abilitata).</span><span class="sxs-lookup"><span data-stu-id="350e1-402">In this test, we first iterate through the list of queries and execute each one once to add them to the cache (if caching is enabled).</span></span> <span data-ttu-id="350e1-403">Questo passaggio non è temporizzato.</span><span class="sxs-lookup"><span data-stu-id="350e1-403">This step is untimed.</span></span> <span data-ttu-id="350e1-404">Successivamente, dormiamo il filo conduttore per oltre 60 secondi per consentire lo sweep della cache; infine, scorriamo l'elenco una seconda volta per eseguire le query memorizzate nella cache.</span><span class="sxs-lookup"><span data-stu-id="350e1-404">Next, we sleep the main thread for over 60 seconds to allow cache sweeping to take place; finally, we iterate through the list a 2nd time to execute the cached queries.</span></span> <span data-ttu-id="350e1-405">Inoltre, la cache dei piani di SQL Server viene scaricata prima dell'esecuzione di ogni set di query in modo che gli orari ottenuti riflettano in modo accurato il vantaggio offerto dalla cache del piano di query.</span><span class="sxs-lookup"><span data-stu-id="350e1-405">Additionally, the SQL Server plan cache is flushed before each set of queries is executed so that the times we obtain accurately reflect the benefit given by the query plan cache.</span></span>

##### <a name="3231-test-results"></a><span data-ttu-id="350e1-406">3.2.3.1 Risultati dei test</span><span class="sxs-lookup"><span data-stu-id="350e1-406">3.2.3.1       Test Results</span></span>

| <span data-ttu-id="350e1-407">Test</span><span class="sxs-lookup"><span data-stu-id="350e1-407">Test</span></span>                                                                   | <span data-ttu-id="350e1-408">EF5 nessuna cache</span><span class="sxs-lookup"><span data-stu-id="350e1-408">EF5 no cache</span></span> | <span data-ttu-id="350e1-409">EF5 memorizzato nella cache</span><span class="sxs-lookup"><span data-stu-id="350e1-409">EF5 cached</span></span> | <span data-ttu-id="350e1-410">EF6 nessuna cache</span><span class="sxs-lookup"><span data-stu-id="350e1-410">EF6 no cache</span></span> | <span data-ttu-id="350e1-411">EF6 memorizzato nella cache</span><span class="sxs-lookup"><span data-stu-id="350e1-411">EF6 cached</span></span> |
|:-----------------------------------------------------------------------|:-------------|:-----------|:-------------|:-----------|
| <span data-ttu-id="350e1-412">Enumerazione di tutte le query 18723</span><span class="sxs-lookup"><span data-stu-id="350e1-412">Enumerating all 18723 queries</span></span>                                          | <span data-ttu-id="350e1-413">124</span><span class="sxs-lookup"><span data-stu-id="350e1-413">124</span></span>          | <span data-ttu-id="350e1-414">125.4</span><span class="sxs-lookup"><span data-stu-id="350e1-414">125.4</span></span>      | <span data-ttu-id="350e1-415">124.3</span><span class="sxs-lookup"><span data-stu-id="350e1-415">124.3</span></span>        | <span data-ttu-id="350e1-416">125.3</span><span class="sxs-lookup"><span data-stu-id="350e1-416">125.3</span></span>      |
| <span data-ttu-id="350e1-417">Evitare lo sweep (solo le prime query 800, indipendentemente dalla complessità)</span><span class="sxs-lookup"><span data-stu-id="350e1-417">Avoiding sweep (just the first 800 queries, regardless of complexity)</span></span>  | <span data-ttu-id="350e1-418">41.7</span><span class="sxs-lookup"><span data-stu-id="350e1-418">41.7</span></span>         | <span data-ttu-id="350e1-419">5.5</span><span class="sxs-lookup"><span data-stu-id="350e1-419">5.5</span></span>        | <span data-ttu-id="350e1-420">40.5</span><span class="sxs-lookup"><span data-stu-id="350e1-420">40.5</span></span>         | <span data-ttu-id="350e1-421">5.4</span><span class="sxs-lookup"><span data-stu-id="350e1-421">5.4</span></span>        |
| <span data-ttu-id="350e1-422">Solo le query Aggregating Subtotalis (178 in totale - che evita sweep)</span><span class="sxs-lookup"><span data-stu-id="350e1-422">Just the AggregatingSubtotals queries (178 total - which avoids sweep)</span></span> | <span data-ttu-id="350e1-423">39.5</span><span class="sxs-lookup"><span data-stu-id="350e1-423">39.5</span></span>         | <span data-ttu-id="350e1-424">4.5</span><span class="sxs-lookup"><span data-stu-id="350e1-424">4.5</span></span>        | <span data-ttu-id="350e1-425">38.1</span><span class="sxs-lookup"><span data-stu-id="350e1-425">38.1</span></span>         | <span data-ttu-id="350e1-426">4.6</span><span class="sxs-lookup"><span data-stu-id="350e1-426">4.6</span></span>        |

<span data-ttu-id="350e1-427">*Tutti i tempi in pochi secondi.*</span><span class="sxs-lookup"><span data-stu-id="350e1-427">*All times in seconds.*</span></span>

<span data-ttu-id="350e1-428">Morale: quando si eseguono molte query distinte (ad esempio, query create dinamicamente), la memorizzazione nella cache non consente di risolvere il contenuto e lo svuotamento risultante della cache può mantenere le query che trarrebbero il massimo vantaggio dal piano di memorizzazione nella cache dall'utilizzo effettiva.</span><span class="sxs-lookup"><span data-stu-id="350e1-428">Moral - when executing lots of distinct queries (for example,  dynamically created queries), caching doesn't help and the resulting flushing of the cache can keep the queries that would benefit the most from plan caching from actually using it.</span></span>

<span data-ttu-id="350e1-429">Le query AggregngSubtotals sono la più complessa delle query testate con.</span><span class="sxs-lookup"><span data-stu-id="350e1-429">The AggregatingSubtotals queries are the most complex of the queries we tested with.</span></span> <span data-ttu-id="350e1-430">Come previsto, quanto più complessa è la query, maggiore sarà il vantaggio che si vedrà dalla memorizzazione nella cache del piano di query.</span><span class="sxs-lookup"><span data-stu-id="350e1-430">As expected, the more complex the query is, the more benefit you will see from query plan caching.</span></span>

<span data-ttu-id="350e1-431">Poiché un oggetto CompiledQuery è in realtà una query LINQ con il piano memorizzato nella cache, il confronto di un oggetto CompiledQuery con la query Entity SQL equivalente deve avere risultati simili.</span><span class="sxs-lookup"><span data-stu-id="350e1-431">Because a CompiledQuery is really a LINQ query with its plan cached, the comparison of a CompiledQuery versus the equivalent Entity SQL query should have similar results.</span></span> <span data-ttu-id="350e1-432">Infatti, se un'app dispone di molte query Entity SQL dinamiche, riempire la cache con le query causerà anche CompiledQueries per "decompilare" quando vengono scaricati dalla cache.</span><span class="sxs-lookup"><span data-stu-id="350e1-432">In fact, if an app has lots of dynamic Entity SQL queries, filling the cache with queries will also effectively cause CompiledQueries to “decompile” when they are flushed from the cache.</span></span> <span data-ttu-id="350e1-433">In questo scenario, le prestazioni possono essere migliorate disabilitando la memorizzazione nella cache nelle query dinamiche per assegnare priorità a CompiledQueries.</span><span class="sxs-lookup"><span data-stu-id="350e1-433">In this scenario, performance may be improved by disabling caching on the dynamic queries to prioritize the CompiledQueries.</span></span> <span data-ttu-id="350e1-434">Meglio ancora, naturalmente, sarebbe quello di riscrivere l'applicazione per utilizzare query con parametri anziché query dinamiche.</span><span class="sxs-lookup"><span data-stu-id="350e1-434">Better yet, of course, would be to rewrite the app to use parameterized queries instead of dynamic queries.</span></span>

### <a name="33-using-compiledquery-to-improve-performance-with-linq-queries"></a><span data-ttu-id="350e1-435">3.3 Utilizzo di CompiledQuery per migliorare le prestazioni con le query LINQ</span><span class="sxs-lookup"><span data-stu-id="350e1-435">3.3 Using CompiledQuery to improve performance with LINQ queries</span></span>

<span data-ttu-id="350e1-436">I test indicano che l'utilizzo di CompiledQuery può portare un vantaggio del 7% rispetto alle query LINQ autocompilate; ciò significa che si spenderà il 7% in meno di tempo per l'esecuzione di codice dallo stack di Entity Framework; non significa che l'applicazione sarà 7% più veloce.</span><span class="sxs-lookup"><span data-stu-id="350e1-436">Our tests indicate that using CompiledQuery can bring a benefit of 7% over autocompiled LINQ queries; this means that you’ll spend 7% less time executing code from the Entity Framework stack; it does not mean your application will be 7% faster.</span></span> <span data-ttu-id="350e1-437">In generale, il costo di scrittura e gestione di oggetti CompiledQuery in EF 5.0 potrebbe non valere la pena rispetto ai vantaggi.</span><span class="sxs-lookup"><span data-stu-id="350e1-437">Generally speaking, the cost of writing and maintaining CompiledQuery objects in EF 5.0 may not be worth the trouble when compared to the benefits.</span></span> <span data-ttu-id="350e1-438">Il chilometraggio può variare, quindi esercita questa opzione se il tuo progetto richiede la spinta aggiuntiva.</span><span class="sxs-lookup"><span data-stu-id="350e1-438">Your mileage may vary, so exercise this option if your project requires the extra push.</span></span> <span data-ttu-id="350e1-439">Si noti che CompiledQueries sono compatibili solo con i modelli derivati da ObjectContext e non compatibili con i modelli derivati da DbContext.Note that CompiledQueries are only compatible with ObjectContext-derived models, and not compatible with DbContext-derived models.</span><span class="sxs-lookup"><span data-stu-id="350e1-439">Note that CompiledQueries are only compatible with ObjectContext-derived models, and not compatible with DbContext-derived models.</span></span>

<span data-ttu-id="350e1-440">Per ulteriori informazioni sulla creazione e la chiamata di un oggetto CompiledQuery, vedere [Query compilate (LINQ to Entities)](https://msdn.microsoft.com/library/bb896297.aspx).</span><span class="sxs-lookup"><span data-stu-id="350e1-440">For more information on creating and invoking a CompiledQuery, see [Compiled Queries (LINQ to Entities)](https://msdn.microsoft.com/library/bb896297.aspx).</span></span>

<span data-ttu-id="350e1-441">Ci sono due considerazioni che è necessario prendere quando si utilizza un CompiledQuery, vale a dire il requisito di utilizzare le istanze statiche e i problemi che hanno con la componibilità.</span><span class="sxs-lookup"><span data-stu-id="350e1-441">There are two considerations you have to take when using a CompiledQuery, namely the requirement to use static instances and the problems they have with composability.</span></span> <span data-ttu-id="350e1-442">Di seguito è riportata una spiegazione approfondita di queste due considerazioni.</span><span class="sxs-lookup"><span data-stu-id="350e1-442">Here follows an in-depth explanation of these two considerations.</span></span>

#### <a name="331-use-static-compiledquery-instances"></a><span data-ttu-id="350e1-443">3.3.1 Utilizzare istanze compiledQuery statiche</span><span class="sxs-lookup"><span data-stu-id="350e1-443">3.3.1       Use static CompiledQuery instances</span></span>

<span data-ttu-id="350e1-444">Poiché la compilazione di una query LINQ è un processo che richiede molto tempo, non vogliamo farlo ogni volta che è necessario recuperare i dati dal database.</span><span class="sxs-lookup"><span data-stu-id="350e1-444">Since compiling a LINQ query is a time-consuming process, we don’t want to do it every time we need to fetch data from the database.</span></span> <span data-ttu-id="350e1-445">Le istanze CompiledQuery consentono di compilare una sola volta ed eseguire più volte, ma è necessario prestare attenzione e procurarsi per riutilizzare la stessa istanza CompiledQuery ogni volta che invece di compilarla più e più volte.</span><span class="sxs-lookup"><span data-stu-id="350e1-445">CompiledQuery instances allow you to compile once and run multiple times, but you have to be careful and procure to re-use the same CompiledQuery instance every time instead of compiling it over and over again.</span></span> <span data-ttu-id="350e1-446">L'utilizzo di membri statici per archiviare il CompiledQuery istanze diventa necessario; in caso contrario non si vedrà alcun beneficio.</span><span class="sxs-lookup"><span data-stu-id="350e1-446">The use of static members to store the CompiledQuery instances becomes necessary; otherwise you won’t see any benefit.</span></span>

<span data-ttu-id="350e1-447">Si supponga, ad esempio, che la pagina disponga del seguente corpo del metodo per gestire la visualizzazione dei prodotti per la categoria selezionata:</span><span class="sxs-lookup"><span data-stu-id="350e1-447">For example, suppose your page has the following method body to handle displaying the products for the selected category:</span></span>

``` csharp
    // Warning: this is the wrong way of using CompiledQuery
    using (NorthwindEntities context = new NorthwindEntities())
    {
        string selectedCategory = this.categoriesList.SelectedValue;

        var productsForCategory = CompiledQuery.Compile<NorthwindEntities, string, IQueryable<Product>>(
            (NorthwindEntities nwnd, string category) =>
                nwnd.Products.Where(p => p.Category.CategoryName == category)
        );

        this.productsGrid.DataSource = productsForCategory.Invoke(context, selectedCategory).ToList();
        this.productsGrid.DataBind();
    }

    this.productsGrid.Visible = true;
```

<span data-ttu-id="350e1-448">In questo caso, si creerà una nuova istanza CompiledQuery in tempo reale ogni volta che viene chiamato il metodo.</span><span class="sxs-lookup"><span data-stu-id="350e1-448">In this case, you will create a new CompiledQuery instance on the fly every time the method is called.</span></span> <span data-ttu-id="350e1-449">Invece di visualizzare i vantaggi in termini di prestazioni recuperando il comando store dalla cache del piano di query, CompiledQuery passerà attraverso il compilatore di piani ogni volta che viene creata una nuova istanza.</span><span class="sxs-lookup"><span data-stu-id="350e1-449">Instead of seeing performance benefits by retrieving the store command from the query plan cache, the CompiledQuery will go through the plan compiler every time a new instance is created.</span></span> <span data-ttu-id="350e1-450">Infatti, si inquinerà la cache del piano di query con una nuova voce CompiledQuery ogni volta che viene chiamato il metodo.</span><span class="sxs-lookup"><span data-stu-id="350e1-450">In fact, you will be polluting your query plan cache with a new CompiledQuery entry every time the method is called.</span></span>

<span data-ttu-id="350e1-451">Si desidera invece creare un'istanza statica della query compilata, in modo da richiamare la stessa query compilata ogni volta che viene chiamato il metodo.</span><span class="sxs-lookup"><span data-stu-id="350e1-451">Instead, you want to create a static instance of the compiled query, so you are invoking the same compiled query every time the method is called.</span></span> <span data-ttu-id="350e1-452">Un modo per questo è aggiungendo il CompiledQuery istanza come membro del contesto dell'oggetto.</span><span class="sxs-lookup"><span data-stu-id="350e1-452">One way to so this is by adding the CompiledQuery instance as a member of your object context.</span></span><span data-ttu-id="350e1-453">È quindi possibile rendere le cose un po ' più pulito accedendo a CompiledQuery tramite un metodo helper:You can then make things a little cleaner by accessing the CompiledQuery through a helper method:</span><span class="sxs-lookup"><span data-stu-id="350e1-453">  You can then make things a little cleaner by accessing the CompiledQuery through a helper method:</span></span>

``` csharp
    public partial class NorthwindEntities : ObjectContext
    {
        private static readonly Func<NorthwindEntities, string, IEnumerable<Product>> productsForCategoryCQ = CompiledQuery.Compile(
            (NorthwindEntities context, string categoryName) =>
                context.Products.Where(p => p.Category.CategoryName == categoryName)
            );

        public IEnumerable<Product> GetProductsForCategory(string categoryName)
        {
            return productsForCategoryCQ.Invoke(this, categoryName).ToList();
        }
```

<span data-ttu-id="350e1-454">Questo metodo di supporto viene richiamato come segue:This helper method would be invoked as follows:</span><span class="sxs-lookup"><span data-stu-id="350e1-454">This helper method would be invoked as follows:</span></span>

``` csharp
    this.productsGrid.DataSource = context.GetProductsForCategory(selectedCategory);
```

#### <a name="332-composing-over-a-compiledquery"></a><span data-ttu-id="350e1-455">3.3.2 Composizione su una query di compilazione</span><span class="sxs-lookup"><span data-stu-id="350e1-455">3.3.2       Composing over a CompiledQuery</span></span>

<span data-ttu-id="350e1-456">La possibilità di comporre su qualsiasi query LINQ è estremamente utile; A tale scopo, è sufficiente richiamare un metodo dopo iQueryable, ad esempio *Skip()* o *Count().*</span><span class="sxs-lookup"><span data-stu-id="350e1-456">The ability to compose over any LINQ query is extremely useful; to do this, you simply invoke a method after the IQueryable such as *Skip()* or *Count()*.</span></span> <span data-ttu-id="350e1-457">Tuttavia, questa operazione restituisce essenzialmente un nuovo oggetto IQueryable.However, doing so essentially returns a new IQueryable object.</span><span class="sxs-lookup"><span data-stu-id="350e1-457">However, doing so essentially returns a new IQueryable object.</span></span> <span data-ttu-id="350e1-458">Anche se non c'è nulla che ti impedisca tecnicamente di comporre su un oggetto CompiledQuery, in questo modo la generazione di un nuovo oggetto IQueryable che richiede nuovamente il passaggio attraverso il compilatore di piano.</span><span class="sxs-lookup"><span data-stu-id="350e1-458">While there’s nothing to stop you technically from composing over a CompiledQuery, doing so will cause the generation of a new IQueryable object that requires passing through the plan compiler again.</span></span>

<span data-ttu-id="350e1-459">Alcuni componenti utilizzeranno oggetti IQueryable composti per abilitare funzionalità avanzate.</span><span class="sxs-lookup"><span data-stu-id="350e1-459">Some components will make use of composed IQueryable objects to enable advanced functionality.</span></span> <span data-ttu-id="350e1-460">Ad esempio, ASP. GridView di NET può essere associato a dati a un IQueryable oggetto tramite il SelectMethod proprietà.</span><span class="sxs-lookup"><span data-stu-id="350e1-460">For example, ASP.NET’s GridView can be data-bound to an IQueryable object via the SelectMethod property.</span></span> <span data-ttu-id="350e1-461">Il controllo GridView comporrà quindi su questo oggetto IQueryable per consentire l'ordinamento e il paging sul modello di dati.</span><span class="sxs-lookup"><span data-stu-id="350e1-461">The GridView will then compose over this IQueryable object to allow sorting and paging over the data model.</span></span> <span data-ttu-id="350e1-462">Come si può vedere, utilizzando un CompiledQuery per il controllo GridView non sarebbe raggiunto la query compilata, ma genererebbe una nuova query automatica.</span><span class="sxs-lookup"><span data-stu-id="350e1-462">As you can see, using a CompiledQuery for the GridView would not hit the compiled query but would generate a new autocompiled query.</span></span>

<span data-ttu-id="350e1-463">Un punto in cui è possibile eseguire questo è quando si aggiungono filtri progressivi a una query.</span><span class="sxs-lookup"><span data-stu-id="350e1-463">One place where you may run into this is when adding progressive filters to a query.</span></span> <span data-ttu-id="350e1-464">Si supponga, ad esempio, di avere una pagina Clienti con diversi elenchi a discesa per i filtri facoltativi , ad esempio Country e OrdersCount.</span><span class="sxs-lookup"><span data-stu-id="350e1-464">For example, suppose you had a Customers page with several drop-down lists for optional filters (for example, Country and OrdersCount).</span></span> <span data-ttu-id="350e1-465">È possibile comporre questi filtri sui risultati IQueryable di un oggetto CompiledQuery, ma in questo modo la nuova query passa attraverso il compilatore di piani ogni volta che viene eseguita.</span><span class="sxs-lookup"><span data-stu-id="350e1-465">You can compose these filters over the IQueryable results of a CompiledQuery, but doing so will result in the new query going through the plan compiler every time you execute it.</span></span>

``` csharp
    using (NorthwindEntities context = new NorthwindEntities())
    {
        IQueryable<Customer> myCustomers = context.InvokeCustomersForEmployee();

        if (this.orderCountFilterList.SelectedItem.Value != defaultFilterText)
        {
            int orderCount = int.Parse(orderCountFilterList.SelectedValue);
            myCustomers = myCustomers.Where(c => c.Orders.Count > orderCount);
        }

        if (this.countryFilterList.SelectedItem.Value != defaultFilterText)
        {
            myCustomers = myCustomers.Where(c => c.Address.Country == countryFilterList.SelectedValue);
        }

        this.customersGrid.DataSource = myCustomers;
        this.customersGrid.DataBind();
    }
```

 <span data-ttu-id="350e1-466">Per evitare questa ricompilazione, è possibile riscrivere il CompiledQuery per prendere in considerazione i possibili filtri:</span><span class="sxs-lookup"><span data-stu-id="350e1-466">To avoid this re-compilation, you can rewrite the CompiledQuery to take the possible filters into account:</span></span>

``` csharp
    private static readonly Func<NorthwindEntities, int, int?, string, IQueryable<Customer>> customersForEmployeeWithFiltersCQ = CompiledQuery.Compile(
        (NorthwindEntities context, int empId, int? countFilter, string countryFilter) =>
            context.Customers.Where(c => c.Orders.Any(o => o.EmployeeID == empId))
            .Where(c => countFilter.HasValue == false || c.Orders.Count > countFilter)
            .Where(c => countryFilter == null || c.Address.Country == countryFilter)
        );
```

<span data-ttu-id="350e1-467">Che verrebbe richiamato nell'interfaccia utente come:</span><span class="sxs-lookup"><span data-stu-id="350e1-467">Which would be invoked in the UI like:</span></span>

``` csharp
    using (NorthwindEntities context = new NorthwindEntities())
    {
        int? countFilter = (this.orderCountFilterList.SelectedIndex == 0) ?
            (int?)null :
            int.Parse(this.orderCountFilterList.SelectedValue);

        string countryFilter = (this.countryFilterList.SelectedIndex == 0) ?
            null :
            this.countryFilterList.SelectedValue;

        IQueryable<Customer> myCustomers = context.InvokeCustomersForEmployeeWithFilters(
                countFilter, countryFilter);

        this.customersGrid.DataSource = myCustomers;
        this.customersGrid.DataBind();
    }
```

 <span data-ttu-id="350e1-468">Un compromesso è che il comando di archivio generato avrà sempre i filtri con i controlli null, ma questi dovrebbero essere abbastanza semplici per il server di database per ottimizzare:</span><span class="sxs-lookup"><span data-stu-id="350e1-468">A tradeoff here is the generated store command will always have the filters with the null checks, but these should be fairly simple for the database server to optimize:</span></span>

``` SQL
...
WHERE ((0 = (CASE WHEN (@p__linq__1 IS NOT NULL) THEN cast(1 as bit) WHEN (@p__linq__1 IS NULL) THEN cast(0 as bit) END)) OR ([Project3].[C2] > @p__linq__2)) AND (@p__linq__3 IS NULL OR [Project3].[Country] = @p__linq__4)
```

### <a name="34-metadata-caching"></a><span data-ttu-id="350e1-469">3.4 Memorizzazione dei metadati nella cache</span><span class="sxs-lookup"><span data-stu-id="350e1-469">3.4 Metadata caching</span></span>

<span data-ttu-id="350e1-470">Entity Framework supporta anche la memorizzazione dei metadati nella cache.</span><span class="sxs-lookup"><span data-stu-id="350e1-470">The Entity Framework also supports Metadata caching.</span></span> <span data-ttu-id="350e1-471">Si tratta essenzialmente di memorizzazione nella cache delle informazioni sul tipo e del mapping da tipo a database tra connessioni diverse allo stesso modello.</span><span class="sxs-lookup"><span data-stu-id="350e1-471">This is essentially caching of type information and type-to-database mapping information across different connections to the same model.</span></span> <span data-ttu-id="350e1-472">La cache dei metadati è univoca per AppDomain.The Metadata cache is unique per AppDomain.</span><span class="sxs-lookup"><span data-stu-id="350e1-472">The Metadata cache is unique per AppDomain.</span></span>

#### <a name="341-metadata-caching-algorithm"></a><span data-ttu-id="350e1-473">3.4.1 Algoritmo di memorizzazione dei metadati Caching</span><span class="sxs-lookup"><span data-stu-id="350e1-473">3.4.1 Metadata Caching algorithm</span></span>

1.  <span data-ttu-id="350e1-474">Le informazioni sui metadati per un modello vengono archiviate in un ItemCollection per ogni EntityConnection.Metadata information for a model is stored in an ItemCollection for each EntityConnection.</span><span class="sxs-lookup"><span data-stu-id="350e1-474">Metadata information for a model is stored in an ItemCollection for each EntityConnection.</span></span>
    -   <span data-ttu-id="350e1-475">Come nota a margine, esistono diversi ItemCollection oggetti per le diverse parti del modello.</span><span class="sxs-lookup"><span data-stu-id="350e1-475">As a side note, there are different ItemCollection objects for different parts of the model.</span></span> <span data-ttu-id="350e1-476">Ad esempio, StoreItemCollections contiene le informazioni sul modello di database; ObjectItemCollection contiene informazioni sul modello di dati; EdmItemCollection contiene informazioni sul modello concettuale.</span><span class="sxs-lookup"><span data-stu-id="350e1-476">For example, StoreItemCollections contains the information about the database model; ObjectItemCollection contains information about the data model; EdmItemCollection contains information about the conceptual model.</span></span>

2.  <span data-ttu-id="350e1-477">Se due connessioni utilizzano la stessa stringa di connessione, condivideranno la stessa istanza ItemCollection.If two connections use the same connection string, they will share the same ItemCollection instance.</span><span class="sxs-lookup"><span data-stu-id="350e1-477">If two connections use the same connection string, they will share the same ItemCollection instance.</span></span>
3.  <span data-ttu-id="350e1-478">Le stringhe di connessione funzionalmente equivalenti ma clauviamente diverse possono generare cache dei metadati diverse.</span><span class="sxs-lookup"><span data-stu-id="350e1-478">Functionally equivalent but textually different connection strings may result in different metadata caches.</span></span> <span data-ttu-id="350e1-479">Facciamo tokenize stringhe di connessione, quindi semplicemente la modifica dell'ordine dei token dovrebbe comportare metadati condivisi.</span><span class="sxs-lookup"><span data-stu-id="350e1-479">We do tokenize connection strings, so simply changing the order of the tokens should result in shared metadata.</span></span> <span data-ttu-id="350e1-480">Ma due stringhe di connessione che sembrano funzionalmente uguali potrebbero non essere valutate come identiche dopo la tokenizzazione.</span><span class="sxs-lookup"><span data-stu-id="350e1-480">But two connection strings that seem functionally the same may not be evaluated as identical after tokenization.</span></span>
4.  <span data-ttu-id="350e1-481">Il ItemCollection viene controllato periodicamente per l'utilizzo.</span><span class="sxs-lookup"><span data-stu-id="350e1-481">The ItemCollection is periodically checked for use.</span></span> <span data-ttu-id="350e1-482">Se viene determinato che un workspace non è stato eseguito di recente, verrà contrassegnato per la pulizia nella successiva sweep della cache.</span><span class="sxs-lookup"><span data-stu-id="350e1-482">If it is determined that a workspace has not been accessed recently, it will be marked for cleanup on the next cache sweep.</span></span>
5.  <span data-ttu-id="350e1-483">La semplice creazione di un oggetto EntityConnection causerà la creazione di una cache dei metadati (anche se le raccolte di elementi in essa in essa in essa non verranno inizializzate fino all'apertura della connessione).</span><span class="sxs-lookup"><span data-stu-id="350e1-483">Merely creating an EntityConnection will cause a metadata cache to be created (though the item collections in it will not be initialized until the connection is opened).</span></span> <span data-ttu-id="350e1-484">Questa area di lavoro rimarrà in memoria fino a quando l'algoritmo di memorizzazione nella cache non determina che non è "in uso".</span><span class="sxs-lookup"><span data-stu-id="350e1-484">This workspace will remain in-memory until the caching algorithm determines it is not “in use”.</span></span>

<span data-ttu-id="350e1-485">Il team di consulenza clienti ha scritto un post di blog che descrive il mantenimento di \< https://docs.microsoft.com/archive/blogs/appfabriccat/holding-a-reference-to-the-ef-metadataworkspace-for-wcf-services>un riferimento a un oggetto ItemCollection per evitare la "deprecazione" quando si utilizzano modelli di grandi dimensioni: .</span><span class="sxs-lookup"><span data-stu-id="350e1-485">The Customer Advisory Team has written a blog post that describes holding a reference to an ItemCollection in order to avoid "deprecation" when using large models: \<https://docs.microsoft.com/archive/blogs/appfabriccat/holding-a-reference-to-the-ef-metadataworkspace-for-wcf-services>.</span></span>

#### <a name="342-the-relationship-between-metadata-caching-and-query-plan-caching"></a><span data-ttu-id="350e1-486">3.4.2 Relazione tra la memorizzazione nella cache dei metadati e la memorizzazione nella cache del piano di query</span><span class="sxs-lookup"><span data-stu-id="350e1-486">3.4.2 The relationship between Metadata Caching and Query Plan Caching</span></span>

<span data-ttu-id="350e1-487">L'istanza della cache del piano di query si trova nella raccolta ItemCollection di MetadataWorkspace dei tipi di archivio.</span><span class="sxs-lookup"><span data-stu-id="350e1-487">The query plan cache instance lives in the MetadataWorkspace's ItemCollection of store types.</span></span> <span data-ttu-id="350e1-488">Ciò significa che i comandi dell'archivio memorizzati nella cache verranno utilizzati per le query su qualsiasi contesto di cui è stata creata un'istanza utilizzando un oggetto MetadataWorkspace specificato.</span><span class="sxs-lookup"><span data-stu-id="350e1-488">This means that cached store commands will be used for queries against any context instantiated using a given MetadataWorkspace.</span></span> <span data-ttu-id="350e1-489">Significa anche che se si dispone di due stringhe di connessioni che sono leggermente diverse e non corrispondono dopo il tokenizzazione, si disporrà di istanze della cache del piano di query diverse.</span><span class="sxs-lookup"><span data-stu-id="350e1-489">It also means that if you have two connections strings that are slightly different and don't match after tokenizing, you will have different query plan cache instances.</span></span>

### <a name="35-results-caching"></a><span data-ttu-id="350e1-490">3.5 Memorizzazione nella cache dei risultati</span><span class="sxs-lookup"><span data-stu-id="350e1-490">3.5 Results caching</span></span>

<span data-ttu-id="350e1-491">Con la memorizzazione nella cache dei risultati (nota anche come "memorizzazione nella cache di secondo livello"), si mantengono i risultati delle query in una cache locale.</span><span class="sxs-lookup"><span data-stu-id="350e1-491">With results caching (also known as "second-level caching"), you keep the results of queries in a local cache.</span></span> <span data-ttu-id="350e1-492">Quando si esegue una query, è necessario verificare se i risultati sono disponibili localmente prima di eseguire una query sull'archivio.</span><span class="sxs-lookup"><span data-stu-id="350e1-492">When issuing a query, you first see if the results are available locally before you query against the store.</span></span> <span data-ttu-id="350e1-493">Mentre la memorizzazione dei risultati nella cache non è supportata direttamente da Entity Framework, è possibile aggiungere una cache di secondo livello utilizzando un provider di wrapping.</span><span class="sxs-lookup"><span data-stu-id="350e1-493">While results caching isn't directly supported by Entity Framework, it's possible to add a second level cache by using a wrapping provider.</span></span> <span data-ttu-id="350e1-494">Un provider di cui avviene di esempio con una cache di secondo livello è la cache di secondo livello di Entity Framework di Alachisoft [basata su NCache](https://www.alachisoft.com/ncache/entity-framework.html).</span><span class="sxs-lookup"><span data-stu-id="350e1-494">An example wrapping provider with a second-level cache is Alachisoft's [Entity Framework Second Level Cache based on NCache](https://www.alachisoft.com/ncache/entity-framework.html).</span></span>

<span data-ttu-id="350e1-495">Questa implementazione della memorizzazione nella cache di secondo livello è una funzionalità inserita che viene eseguita dopo che l'espressione LINQ è stata valutata (e migliorata) e il piano di esecuzione della query viene calcolato o recuperato dalla cache di primo livello.</span><span class="sxs-lookup"><span data-stu-id="350e1-495">This implementation of second-level caching is an injected functionality that takes place after the LINQ expression has been evaluated (and funcletized) and the query execution plan is computed or retrieved from the first-level cache.</span></span> <span data-ttu-id="350e1-496">La cache di secondo livello archivierà quindi solo i risultati del database non elaborati, in modo che la pipeline di materializzazione venga comunque eseguita successivamente.</span><span class="sxs-lookup"><span data-stu-id="350e1-496">The second-level cache will then store only the raw database results, so the materialization pipeline still executes afterwards.</span></span>

#### <a name="351-additional-references-for-results-caching-with-the-wrapping-provider"></a><span data-ttu-id="350e1-497">3.5.1 Riferimenti aggiuntivi per la memorizzazione nella cache dei risultati con il provider di wrapping</span><span class="sxs-lookup"><span data-stu-id="350e1-497">3.5.1 Additional references for results caching with the wrapping provider</span></span>

-   <span data-ttu-id="350e1-498">Julie Lerman ha scritto un articolo MSDN "Second-Level Caching in Entity Framework and Windows Azure" che include come aggiornare il provider di wrapping di esempio per utilizzare la memorizzazione nella cache di Windows Server AppFabric:[https://msdn.microsoft.com/magazine/hh394143.aspx](https://msdn.microsoft.com/magazine/hh394143.aspx)</span><span class="sxs-lookup"><span data-stu-id="350e1-498">Julie Lerman has written a "Second-Level Caching in Entity Framework and Windows Azure" MSDN article that includes how to update the sample wrapping provider to use Windows Server AppFabric caching: [https://msdn.microsoft.com/magazine/hh394143.aspx](https://msdn.microsoft.com/magazine/hh394143.aspx)</span></span>
-   <span data-ttu-id="350e1-499">Se si utilizza Entity Framework 5, il blog del team contiene un post che descrive come \< https://docs.microsoft.com/archive/blogs/adonet/ef-caching-with-jarek-kowalskis-provider>eseguire elementi con il provider di memorizzazione nella cache per Entity Framework 5: .</span><span class="sxs-lookup"><span data-stu-id="350e1-499">If you are working with Entity Framework 5, the team blog has a post that describes how to get things running with the caching provider for Entity Framework 5: \<https://docs.microsoft.com/archive/blogs/adonet/ef-caching-with-jarek-kowalskis-provider>.</span></span> <span data-ttu-id="350e1-500">Include anche un modello T4 per automatizzare l'aggiunta della memorizzazione nella cache di secondo livello al progetto.</span><span class="sxs-lookup"><span data-stu-id="350e1-500">It also includes a T4 template to help automate adding the 2nd-level caching to your project.</span></span>

## <a name="4-autocompiled-queries"></a><span data-ttu-id="350e1-501">4 Query autocompilate</span><span class="sxs-lookup"><span data-stu-id="350e1-501">4 Autocompiled Queries</span></span>

<span data-ttu-id="350e1-502">Quando una query viene eseguita su un database che utilizza Entity Framework, deve eseguire una serie di passaggi prima di materializzare effettivamente i risultati; uno di questi passaggi è la compilazione di query.</span><span class="sxs-lookup"><span data-stu-id="350e1-502">When a query is issued against a database using Entity Framework, it must go through a series of steps before actually materializing the results; one such step is Query Compilation.</span></span> <span data-ttu-id="350e1-503">Le query Entity SQLEntity SQL erano note per avere buone prestazioni in quanto vengono automaticamente memorizzate nella cache, pertanto la seconda o la terza volta che si esegue la stessa query è possibile ignorare il compilatore di piano e utilizzare il piano memorizzato nella cache invece.</span><span class="sxs-lookup"><span data-stu-id="350e1-503">Entity SQL queries were known to have good performance as they are automatically cached, so the second or third time you execute the same query it can skip the plan compiler and use the cached plan instead.</span></span>

<span data-ttu-id="350e1-504">Entity Framework 5 ha introdotto la memorizzazione automatica nella cache anche per le query LINQ to Entities.</span><span class="sxs-lookup"><span data-stu-id="350e1-504">Entity Framework 5 introduced automatic caching for LINQ to Entities queries as well.</span></span> <span data-ttu-id="350e1-505">Nelle edizioni precedenti di Entity Framework la creazione di un oggetto CompiledQuery per velocizzare le prestazioni era una pratica comune, in quanto ciò renderebbe la query LINQ to Entities memorizzabile nella cache.</span><span class="sxs-lookup"><span data-stu-id="350e1-505">In past editions of Entity Framework creating a CompiledQuery to speed your performance was a common practice, as this would make your LINQ to Entities query cacheable.</span></span> <span data-ttu-id="350e1-506">Poiché la memorizzazione nella cache viene ora eseguita automaticamente senza l'utilizzo di un oggetto CompiledQuery, questa funzionalità viene chiamata "query compilate automaticamente".</span><span class="sxs-lookup"><span data-stu-id="350e1-506">Since caching is now done automatically without the use of a CompiledQuery, we call this feature “autocompiled queries”.</span></span> <span data-ttu-id="350e1-507">Per altre informazioni sulla cache del piano di query e sui relativi meccanismi, vedere Memorizzazione nella cache del piano di query.</span><span class="sxs-lookup"><span data-stu-id="350e1-507">For more information about the query plan cache and its mechanics, see Query Plan Caching.</span></span>

<span data-ttu-id="350e1-508">Entity Framework rileva quando una query richiede la ricompilazione e lo fa quando la query viene richiamata anche se era stata compilata in precedenza.</span><span class="sxs-lookup"><span data-stu-id="350e1-508">Entity Framework detects when a query requires to be recompiled, and does so when the query is invoked even if it had been compiled before.</span></span> <span data-ttu-id="350e1-509">Le condizioni comuni che causano la ricompilazione della query sono:</span><span class="sxs-lookup"><span data-stu-id="350e1-509">Common conditions that cause the query to be recompiled are:</span></span>

-   <span data-ttu-id="350e1-510">Modifica dell'opzione MergeOption associata alla query.</span><span class="sxs-lookup"><span data-stu-id="350e1-510">Changing the MergeOption associated to your query.</span></span> <span data-ttu-id="350e1-511">La query memorizzata nella cache non verrà utilizzata, ma il compilatore di piani verrà eseguito di nuovo e il piano appena creato viene memorizzato nella cache.</span><span class="sxs-lookup"><span data-stu-id="350e1-511">The cached query will not be used, instead the plan compiler will run again and the newly created plan gets cached.</span></span>
-   <span data-ttu-id="350e1-512">Modifica del valore di ContextOptions.UseCSharpNullComparisonBehavior.</span><span class="sxs-lookup"><span data-stu-id="350e1-512">Changing the value of ContextOptions.UseCSharpNullComparisonBehavior.</span></span> <span data-ttu-id="350e1-513">Si ottiene lo stesso effetto della modifica di MergeOption.You get the same effect as changing the MergeOption.</span><span class="sxs-lookup"><span data-stu-id="350e1-513">You get the same effect as changing the MergeOption.</span></span>

<span data-ttu-id="350e1-514">Altre condizioni possono impedire alla query di utilizzare la cache.</span><span class="sxs-lookup"><span data-stu-id="350e1-514">Other conditions can prevent your query from using the cache.</span></span> <span data-ttu-id="350e1-515">Esempi comuni:</span><span class="sxs-lookup"><span data-stu-id="350e1-515">Common examples are:</span></span>

-   <span data-ttu-id="350e1-516">Utilizzo di&lt;&gt;IEnumerable T . Contiene&lt;&gt;(valore T).</span><span class="sxs-lookup"><span data-stu-id="350e1-516">Using IEnumerable&lt;T&gt;.Contains&lt;&gt;(T value).</span></span>
-   <span data-ttu-id="350e1-517">Utilizzo di funzioni che producono query con costanti.</span><span class="sxs-lookup"><span data-stu-id="350e1-517">Using functions that produce queries with constants.</span></span>
-   <span data-ttu-id="350e1-518">Utilizzo delle proprietà di un oggetto non mappato.</span><span class="sxs-lookup"><span data-stu-id="350e1-518">Using the properties of a non-mapped object.</span></span>
-   <span data-ttu-id="350e1-519">Collegamento della query a un'altra query che deve essere ricompilata.</span><span class="sxs-lookup"><span data-stu-id="350e1-519">Linking your query to another query that requires to be recompiled.</span></span>

### <a name="41-using-ienumerablelttgtcontainslttgtt-value"></a><span data-ttu-id="350e1-520">4.1 Utilizzo&lt;di&gt;IEnumerable T . Contiene&lt;&gt;T (valore T)</span><span class="sxs-lookup"><span data-stu-id="350e1-520">4.1 Using IEnumerable&lt;T&gt;.Contains&lt;T&gt;(T value)</span></span>

<span data-ttu-id="350e1-521">Entity Framework non memorizza nella&lt;&gt;cache le query che richiamano IEnumerable T . Contiene&lt;&gt;T (valore T) rispetto a una raccolta in memoria, poiché i valori della raccolta sono considerati volatili.</span><span class="sxs-lookup"><span data-stu-id="350e1-521">Entity Framework does not cache queries that invoke IEnumerable&lt;T&gt;.Contains&lt;T&gt;(T value) against an in-memory collection, since the values of the collection are considered volatile.</span></span> <span data-ttu-id="350e1-522">La query di esempio seguente non verrà memorizzata nella cache, pertanto verrà sempre elaborata dal compilatore del piano:The following example query will not be cached, so it will always be processed by the plan compiler:</span><span class="sxs-lookup"><span data-stu-id="350e1-522">The following example query will not be cached, so it will always be processed by the plan compiler:</span></span>

``` csharp
int[] ids = new int[10000];
...
using (var context = new MyContext())
{
    var query = context.MyEntities
                    .Where(entity => ids.Contains(entity.Id));

    var results = query.ToList();
    ...
}
```

<span data-ttu-id="350e1-523">Si noti che la dimensione di IEnumerable su cui Contains viene eseguito determina la velocità o la velocità di compilazione della query.</span><span class="sxs-lookup"><span data-stu-id="350e1-523">Note that the size of the IEnumerable against which Contains is executed determines how fast or how slow your query is compiled.</span></span> <span data-ttu-id="350e1-524">Le prestazioni possono risentirne in modo significativo quando si usano raccolte di grandi dimensioni, come quella illustrata nell'esempio precedente.</span><span class="sxs-lookup"><span data-stu-id="350e1-524">Performance can suffer significantly when using large collections such as the one shown in the example above.</span></span>

<span data-ttu-id="350e1-525">Entity Framework 6 contiene ottimizzazioni&lt;per&gt;il modo in cui IEnumerable T . Contiene&lt;&gt;il valore T (valore T) funziona quando vengono eseguite le query.</span><span class="sxs-lookup"><span data-stu-id="350e1-525">Entity Framework 6 contains optimizations to the way IEnumerable&lt;T&gt;.Contains&lt;T&gt;(T value) works when queries are executed.</span></span> <span data-ttu-id="350e1-526">Il codice SQL generato è molto più veloce da produrre e più leggibile e nella maggior parte dei casi viene eseguito anche più velocemente nel server.</span><span class="sxs-lookup"><span data-stu-id="350e1-526">The SQL code that is generated is much faster to produce and more readable, and in most cases it also executes faster in the server.</span></span>

### <a name="42-using-functions-that-produce-queries-with-constants"></a><span data-ttu-id="350e1-527">4.2 Utilizzo di funzioni che producono query con costanti</span><span class="sxs-lookup"><span data-stu-id="350e1-527">4.2 Using functions that produce queries with constants</span></span>

<span data-ttu-id="350e1-528">Gli operatori LINQ Skip(), Take(), Contains() e DefautIfEmpty() non producono query SQL con parametri, ma inseriscono i valori passati come costanti.</span><span class="sxs-lookup"><span data-stu-id="350e1-528">The Skip(), Take(), Contains() and DefautIfEmpty() LINQ operators do not produce SQL queries with parameters but instead put the values passed to them as constants.</span></span> <span data-ttu-id="350e1-529">Per questo motivo, le query che potrebbero altrimenti essere identiche finiscono per inquinare la cache del piano di query, sia nello stack di Entity Framework e sul server di database e non vengono reutilizzate a meno che le stesse costanti vengono utilizzate in un'esecuzione di query successiva.</span><span class="sxs-lookup"><span data-stu-id="350e1-529">Because of this, queries that might otherwise be identical end up polluting the query plan cache, both on the EF stack and on the database server, and do not get reutilized unless the same constants are used in a subsequent query execution.</span></span> <span data-ttu-id="350e1-530">Ad esempio:</span><span class="sxs-lookup"><span data-stu-id="350e1-530">For example:</span></span>

``` csharp
var id = 10;
...
using (var context = new MyContext())
{
    var query = context.MyEntities.Select(entity => entity.Id).Contains(id);

    var results = query.ToList();
    ...
}
```

<span data-ttu-id="350e1-531">In questo esempio, ogni volta che la query viene eseguita con un valore diverso per id la query verrà compilata in un nuovo piano.</span><span class="sxs-lookup"><span data-stu-id="350e1-531">In this example, each time this query is executed with a different value for id the query will be compiled into a new plan.</span></span>

<span data-ttu-id="350e1-532">In particolare prestare attenzione all'uso di Skip and Take quando si esegue il paging.</span><span class="sxs-lookup"><span data-stu-id="350e1-532">In particular pay attention to the use of Skip and Take when doing paging.</span></span> <span data-ttu-id="350e1-533">In EF6 questi metodi hanno un overload lambda che rende in modo efficace il piano di query memorizzato nella cache riutilizzabile perché EF può acquisire le variabili passate a questi metodi e tradurle in SQLparameters.</span><span class="sxs-lookup"><span data-stu-id="350e1-533">In EF6 these methods have a lambda overload that effectively makes the cached query plan reusable because EF can capture variables passed to these methods and translate them to SQLparameters.</span></span> <span data-ttu-id="350e1-534">Ciò consente inoltre di mantenere la cache più pulita poiché in caso contrario ogni query con una costante diversa per Skip e Take otterrebbe la propria voce della cache del piano di query.</span><span class="sxs-lookup"><span data-stu-id="350e1-534">This also helps keep the cache cleaner since otherwise each query with a different constant for Skip and Take would get its own query plan cache entry.</span></span>

<span data-ttu-id="350e1-535">Si consideri il codice seguente, che non è ottimale, ma ha solo lo scopo di esemplificare questa classe di query:Consider the following code, which is suboptimal but is only meant to emplify this class of queries:</span><span class="sxs-lookup"><span data-stu-id="350e1-535">Consider the following code, which is suboptimal but is only meant to exemplify this class of queries:</span></span>

``` csharp
var customers = context.Customers.OrderBy(c => c.LastName);
for (var i = 0; i < count; ++i)
{
    var currentCustomer = customers.Skip(i).FirstOrDefault();
    ProcessCustomer(currentCustomer);
}
```

<span data-ttu-id="350e1-536">Una versione più veloce di questo stesso codice comporterebbe la chiamata Skip con un'espressione lambda:A faster version of this same code would involve calling Skip with a lambda:</span><span class="sxs-lookup"><span data-stu-id="350e1-536">A faster version of this same code would involve calling Skip with a lambda:</span></span>

``` csharp
var customers = context.Customers.OrderBy(c => c.LastName);
for (var i = 0; i < count; ++i)
{
    var currentCustomer = customers.Skip(() => i).FirstOrDefault();
    ProcessCustomer(currentCustomer);
}
```

<span data-ttu-id="350e1-537">Il secondo frammento di codice può essere eseguito fino all'11% più velocemente perché viene utilizzato lo stesso piano di query ogni volta che viene eseguita la query, risparmiando tempo della CPU ed evitando di inquinare la cache delle query.</span><span class="sxs-lookup"><span data-stu-id="350e1-537">The second snippet may run up to 11% faster because the same query plan is used every time the query is run, which saves CPU time and avoids polluting the query cache.</span></span> <span data-ttu-id="350e1-538">Inoltre, poiché il parametro Skip è in una chiusura, il codice potrebbe anche essere simile al seguente ora:For the parameter to Skip is in a closure, the code might well look like this now:</span><span class="sxs-lookup"><span data-stu-id="350e1-538">Furthermore, because the parameter to Skip is in a closure the code might as well look like this now:</span></span>

``` csharp
var i = 0;
var skippyCustomers = context.Customers.OrderBy(c => c.LastName).Skip(() => i);
for (; i < count; ++i)
{
    var currentCustomer = skippyCustomers.FirstOrDefault();
    ProcessCustomer(currentCustomer);
}
```

### <a name="43-using-the-properties-of-a-non-mapped-object"></a><span data-ttu-id="350e1-539">4.3 Utilizzo delle proprietà di un oggetto non mappato</span><span class="sxs-lookup"><span data-stu-id="350e1-539">4.3 Using the properties of a non-mapped object</span></span>

<span data-ttu-id="350e1-540">Quando una query utilizza le proprietà di un tipo di oggetto non mappato come parametro, la query non verrà memorizzata nella cache.</span><span class="sxs-lookup"><span data-stu-id="350e1-540">When a query uses the properties of a non-mapped object type as a parameter then the query will not get cached.</span></span> <span data-ttu-id="350e1-541">Ad esempio:</span><span class="sxs-lookup"><span data-stu-id="350e1-541">For example:</span></span>

``` csharp
using (var context = new MyContext())
{
    var myObject = new NonMappedType();

    var query = from entity in context.MyEntities
                where entity.Name.StartsWith(myObject.MyProperty)
                select entity;

   var results = query.ToList();
    ...
}
```

<span data-ttu-id="350e1-542">In questo esempio, si supponga che la classe NonMappedType non faccia parte del modello di entità.</span><span class="sxs-lookup"><span data-stu-id="350e1-542">In this example, assume that class NonMappedType is not part of the Entity model.</span></span> <span data-ttu-id="350e1-543">Questa query può essere facilmente modificata per non utilizzare un tipo non mappato e invece utilizzare una variabile locale come parametro per la query:This query can easily be changed to not use a non-mapped type and instead use a local variable as the parameter to the query:</span><span class="sxs-lookup"><span data-stu-id="350e1-543">This query can easily be changed to not use a non-mapped type and instead use a local variable as the parameter to the query:</span></span>

``` csharp
using (var context = new MyContext())
{
    var myObject = new NonMappedType();
    var myValue = myObject.MyProperty;
    var query = from entity in context.MyEntities
                where entity.Name.StartsWith(myValue)
                select entity;

    var results = query.ToList();
    ...
}
```

<span data-ttu-id="350e1-544">In questo caso, la query sarà in grado di ottenere la memorizzazione nella cache e trarrà vantaggio dalla cache del piano di query.</span><span class="sxs-lookup"><span data-stu-id="350e1-544">In this case, the query will be able to get cached and will benefit from the query plan cache.</span></span>

### <a name="44-linking-to-queries-that-require-recompiling"></a><span data-ttu-id="350e1-545">4.4 Collegamento a query che richiedono la ricompilazione</span><span class="sxs-lookup"><span data-stu-id="350e1-545">4.4 Linking to queries that require recompiling</span></span>

<span data-ttu-id="350e1-546">Seguendo lo stesso esempio precedente, se si dispone di una seconda query che si basa su una query che deve essere ricompilata, verrà ricompilata anche l'intera seconda query.</span><span class="sxs-lookup"><span data-stu-id="350e1-546">Following the same example as above, if you have a second query that relies on a query that needs to be recompiled, your entire second query will also be recompiled.</span></span> <span data-ttu-id="350e1-547">Di seguito è riportato un esempio per illustrare questo scenario:Here's an example to illustrate this scenario:</span><span class="sxs-lookup"><span data-stu-id="350e1-547">Here’s an example to illustrate this scenario:</span></span>

``` csharp
int[] ids = new int[10000];
...
using (var context = new MyContext())
{
    var firstQuery = from entity in context.MyEntities
                        where ids.Contains(entity.Id)
                        select entity;

    var secondQuery = from entity in context.MyEntities
                        where firstQuery.Any(otherEntity => otherEntity.Id == entity.Id)
                        select entity;

    var results = secondQuery.ToList();
    ...
}
```

<span data-ttu-id="350e1-548">L'esempio è generico, ma illustra come il collegamento a firstQuery stia causando la impossibilità di non essere memorizzata nella cache di secondQuery.The example is generic, but it illustrates how linking to firstQuery is causing secondQuery to be unable to get cached.</span><span class="sxs-lookup"><span data-stu-id="350e1-548">The example is generic, but it illustrates how linking to firstQuery is causing secondQuery to be unable to get cached.</span></span> <span data-ttu-id="350e1-549">Se firstQuery non fosse stata una query che richiede la ricompilazione, secondQuery sarebbe stata memorizzata nella cache.</span><span class="sxs-lookup"><span data-stu-id="350e1-549">If firstQuery had not been a query that requires recompiling, then secondQuery would have been cached.</span></span>

## <a name="5-notracking-queries"></a><span data-ttu-id="350e1-550">5 Query NoTracking</span><span class="sxs-lookup"><span data-stu-id="350e1-550">5 NoTracking Queries</span></span>

### <a name="51-disabling-change-tracking-to-reduce-state-management-overhead"></a><span data-ttu-id="350e1-551">5.1 Disabilitazione del rilevamento delle modifiche per ridurre l'overhead di gestione dello stato</span><span class="sxs-lookup"><span data-stu-id="350e1-551">5.1 Disabling change tracking to reduce state management overhead</span></span>

<span data-ttu-id="350e1-552">Se si è in uno scenario di sola lettura e si desidera evitare l'overhead del caricamento degli oggetti in ObjectStateManager, è possibile eseguire query "No Tracking".</span><span class="sxs-lookup"><span data-stu-id="350e1-552">If you are in a read-only scenario and want to avoid the overhead of loading the objects into the ObjectStateManager, you can issue "No Tracking" queries.</span></span><span data-ttu-id="350e1-553">Il rilevamento delle modifiche può essere disabilitato a livello di query.</span><span class="sxs-lookup"><span data-stu-id="350e1-553">  Change tracking can be disabled at the query level.</span></span>

<span data-ttu-id="350e1-554">Si noti tuttavia che disabilitando il rilevamento delle modifiche si disattiva effettivamente la cache degli oggetti.</span><span class="sxs-lookup"><span data-stu-id="350e1-554">Note though that by disabling change tracking you are effectively turning off the object cache.</span></span> <span data-ttu-id="350e1-555">Quando si esegue una query per un'entità, non è possibile ignorare la materializzazione estraendo i risultati della query materializzata in precedenza da ObjectStateManager.</span><span class="sxs-lookup"><span data-stu-id="350e1-555">When you query for an entity, we can't skip materialization by pulling the previously-materialized query results from the ObjectStateManager.</span></span> <span data-ttu-id="350e1-556">Se si esegue ripetutamente una query per le stesse entità nello stesso contesto, è possibile ottenere un vantaggio in termini di prestazioni derivante dall'abilitazione del rilevamento delle modifiche.</span><span class="sxs-lookup"><span data-stu-id="350e1-556">If you are repeatedly querying for the same entities on the same context, you might actually see a performance benefit from enabling change tracking.</span></span>

<span data-ttu-id="350e1-557">Quando si esegue una query utilizzando ObjectContext, ObjectQuery e ObjectSet istanze ricorderanno un MergeOption una volta che è impostato e le query che sono composte su di esse erediteranno l'effettivo MergeOption della query padre.</span><span class="sxs-lookup"><span data-stu-id="350e1-557">When querying using ObjectContext, ObjectQuery and ObjectSet instances will remember a MergeOption once it is set, and queries that are composed on them will inherit the effective MergeOption of the parent query.</span></span> <span data-ttu-id="350e1-558">Quando si utilizza DbContext, il rilevamento può essere disabilitato chiamando il modificatore AsNoTracking() nel DbSet.</span><span class="sxs-lookup"><span data-stu-id="350e1-558">When using DbContext, tracking can be disabled by calling the AsNoTracking() modifier on the DbSet.</span></span>

#### <a name="511-disabling-change-tracking-for-a-query-when-using-dbcontext"></a><span data-ttu-id="350e1-559">5.1.1 Disabilitazione del rilevamento delle modifiche per una query quando si usa DbContext</span><span class="sxs-lookup"><span data-stu-id="350e1-559">5.1.1 Disabling change tracking for a query when using DbContext</span></span>

<span data-ttu-id="350e1-560">È possibile passare alla modalità di una query su NoTracking concatenando una chiamata al metodo AsNoTracking() nella query.</span><span class="sxs-lookup"><span data-stu-id="350e1-560">You can switch the mode of a query to NoTracking by chaining a call to the AsNoTracking() method in the query.</span></span> <span data-ttu-id="350e1-561">A differenza di ObjectQuery, le classi DbSet e DbQuery nell'API DbContext non dispongono di una proprietà modificabile per MergeOption.</span><span class="sxs-lookup"><span data-stu-id="350e1-561">Unlike ObjectQuery, the DbSet and DbQuery classes in the DbContext API don’t have a mutable property for the MergeOption.</span></span>

``` csharp
    var productsForCategory = from p in context.Products.AsNoTracking()
                                where p.Category.CategoryName == selectedCategory
                                select p;


```

#### <a name="512-disabling-change-tracking-at-the-query-level-using-objectcontext"></a><span data-ttu-id="350e1-562">5.1.2 Disabilitazione del rilevamento delle modifiche a livello di query tramite ObjectContext</span><span class="sxs-lookup"><span data-stu-id="350e1-562">5.1.2 Disabling change tracking at the query level using ObjectContext</span></span>

``` csharp
    var productsForCategory = from p in context.Products
                                where p.Category.CategoryName == selectedCategory
                                select p;

    ((ObjectQuery)productsForCategory).MergeOption = MergeOption.NoTracking;
```

#### <a name="513-disabling-change-tracking-for-an-entire-entity-set-using-objectcontext"></a><span data-ttu-id="350e1-563">5.1.3 Disabilitazione del rilevamento delle modifiche per un intero set di entità tramite ObjectContext</span><span class="sxs-lookup"><span data-stu-id="350e1-563">5.1.3 Disabling change tracking for an entire entity set using ObjectContext</span></span>

``` csharp
    context.Products.MergeOption = MergeOption.NoTracking;

    var productsForCategory = from p in context.Products
                                where p.Category.CategoryName == selectedCategory
                                select p;
```

### <a name="52test-metrics-demonstrating-the-performance-benefit-of-notracking-queries"></a><span data-ttu-id="350e1-564">5.2 Metriche di test che illustrano i vantaggi in termini di prestazioni delle query NoTracking</span><span class="sxs-lookup"><span data-stu-id="350e1-564">5.2 Test Metrics demonstrating the performance benefit of NoTracking queries</span></span>

<span data-ttu-id="350e1-565">In questo test esamineremo il costo di riempimento di ObjectStateManager confrontando Tracking a NoTracking query per il modello Navision.In this test we look the cost of filling the ObjectStateManager by comparing Tracking to NoTracking queries for the Navision model.</span><span class="sxs-lookup"><span data-stu-id="350e1-565">In this test we look at the cost of filling the ObjectStateManager by comparing Tracking to NoTracking queries for the Navision model.</span></span> <span data-ttu-id="350e1-566">Vedere l'appendice per una descrizione del modello Navision e i tipi di query che sono state eseguite.</span><span class="sxs-lookup"><span data-stu-id="350e1-566">See the appendix for a description of the Navision model and the types of queries which were executed.</span></span> <span data-ttu-id="350e1-567">In questo test, iterare l'elenco di query ed eseguirle una volta.</span><span class="sxs-lookup"><span data-stu-id="350e1-567">In this test, we iterate through the list of queries and execute each one once.</span></span> <span data-ttu-id="350e1-568">Abbiamo eseguito due varianti del test, una volta con le query NoTracking e una volta con l'opzione di unione predefinita di "AppendOnly".</span><span class="sxs-lookup"><span data-stu-id="350e1-568">We ran two variations of the test, once with NoTracking queries and once with the default merge option of "AppendOnly".</span></span> <span data-ttu-id="350e1-569">Abbiamo eseguito ogni variazione 3 volte e prendere il valore medio delle corse.</span><span class="sxs-lookup"><span data-stu-id="350e1-569">We ran each variation 3 times and take the mean value of the runs.</span></span> <span data-ttu-id="350e1-570">Tra i test si cancella la cache delle query in SQL Server e compattare il database tempdb eseguendo i comandi seguenti:</span><span class="sxs-lookup"><span data-stu-id="350e1-570">Between the tests we clear the query cache on the SQL Server and shrink the tempdb by running the following commands:</span></span>

1.  <span data-ttu-id="350e1-571">DBCC DROPCLEANBUFFERS</span><span class="sxs-lookup"><span data-stu-id="350e1-571">DBCC DROPCLEANBUFFERS</span></span>
2.  <span data-ttu-id="350e1-572">DBCC FREEPROCCACHE</span><span class="sxs-lookup"><span data-stu-id="350e1-572">DBCC FREEPROCCACHE</span></span>
3.  <span data-ttu-id="350e1-573">DBCC SHRINKDATABASE (tempdb, 0)</span><span class="sxs-lookup"><span data-stu-id="350e1-573">DBCC SHRINKDATABASE (tempdb, 0)</span></span>

<span data-ttu-id="350e1-574">Risultati del test, mediana su 3 corse:</span><span class="sxs-lookup"><span data-stu-id="350e1-574">Test Results, median over 3 runs:</span></span>

|                        | <span data-ttu-id="350e1-575">NESSUN TRACCIAMENTO – WORKING SET</span><span class="sxs-lookup"><span data-stu-id="350e1-575">NO TRACKING – WORKING SET</span></span> | <span data-ttu-id="350e1-576">NESSUN TRACCIAMENTO – TEMPO</span><span class="sxs-lookup"><span data-stu-id="350e1-576">NO TRACKING – TIME</span></span> | <span data-ttu-id="350e1-577">SOLO AGGIUNTA – WORKING SET</span><span class="sxs-lookup"><span data-stu-id="350e1-577">APPEND ONLY – WORKING SET</span></span> | <span data-ttu-id="350e1-578">SOLO APPEND – TEMPO</span><span class="sxs-lookup"><span data-stu-id="350e1-578">APPEND ONLY – TIME</span></span> |
|:-----------------------|:--------------------------|:-------------------|:--------------------------|:-------------------|
| <span data-ttu-id="350e1-579">**Entity Framework 5**</span><span class="sxs-lookup"><span data-stu-id="350e1-579">**Entity Framework 5**</span></span> | <span data-ttu-id="350e1-580">460361728</span><span class="sxs-lookup"><span data-stu-id="350e1-580">460361728</span></span>                 | <span data-ttu-id="350e1-581">1163536 ms</span><span class="sxs-lookup"><span data-stu-id="350e1-581">1163536 ms</span></span>         | <span data-ttu-id="350e1-582">596545536</span><span class="sxs-lookup"><span data-stu-id="350e1-582">596545536</span></span>                 | <span data-ttu-id="350e1-583">1273042 ms</span><span class="sxs-lookup"><span data-stu-id="350e1-583">1273042 ms</span></span>         |
| <span data-ttu-id="350e1-584">**Entity Framework 6**</span><span class="sxs-lookup"><span data-stu-id="350e1-584">**Entity Framework 6**</span></span> | <span data-ttu-id="350e1-585">647127040</span><span class="sxs-lookup"><span data-stu-id="350e1-585">647127040</span></span>                 | <span data-ttu-id="350e1-586">190228 ms</span><span class="sxs-lookup"><span data-stu-id="350e1-586">190228 ms</span></span>          | <span data-ttu-id="350e1-587">832798720</span><span class="sxs-lookup"><span data-stu-id="350e1-587">832798720</span></span>                 | <span data-ttu-id="350e1-588">195521 ms</span><span class="sxs-lookup"><span data-stu-id="350e1-588">195521 ms</span></span>          |

<span data-ttu-id="350e1-589">Entity Framework 5 avrà un footprint di memoria inferiore alla fine dell'esecuzione rispetto a Entity Framework 6.</span><span class="sxs-lookup"><span data-stu-id="350e1-589">Entity Framework 5 will have a smaller memory footprint at the end of the run than Entity Framework 6 does.</span></span> <span data-ttu-id="350e1-590">La memoria aggiuntiva utilizzata da Entity Framework 6 è il risultato di strutture di memoria aggiuntive e codice che consentono nuove funzionalità e prestazioni migliori.</span><span class="sxs-lookup"><span data-stu-id="350e1-590">The additional memory consumed by Entity Framework 6 is the result of additional memory structures and code that enable new features and better performance.</span></span>

<span data-ttu-id="350e1-591">C'è anche una chiara differenza nel footprint di memoria quando si utilizza ObjectStateManager.</span><span class="sxs-lookup"><span data-stu-id="350e1-591">There’s also a clear difference in memory footprint when using the ObjectStateManager.</span></span> <span data-ttu-id="350e1-592">Entity Framework 5 ha aumentato il footprint del 30% tenendo traccia di tutte le entità che abbiamo materializzato dal database.</span><span class="sxs-lookup"><span data-stu-id="350e1-592">Entity Framework 5 increased its footprint by 30% when keeping track of all the entities we materialized from the database.</span></span> <span data-ttu-id="350e1-593">Entity Framework 6 ha aumentato la propria impronta del 28% quando lo si fa.</span><span class="sxs-lookup"><span data-stu-id="350e1-593">Entity Framework 6 increased its footprint by 28% when doing so.</span></span>

<span data-ttu-id="350e1-594">In termini di tempo, Entity Framework 6 supera Entity Framework 5 in questo test di un margine elevato.</span><span class="sxs-lookup"><span data-stu-id="350e1-594">In terms of time, Entity Framework 6 outperforms Entity Framework 5 in this test by a large margin.</span></span> <span data-ttu-id="350e1-595">Entity Framework 6 ha completato il test in circa il 16% del tempo impiegato da Entity Framework 5.</span><span class="sxs-lookup"><span data-stu-id="350e1-595">Entity Framework 6 completed the test in roughly 16% of the time consumed by Entity Framework 5.</span></span> <span data-ttu-id="350e1-596">Inoltre, Entity Framework 5 richiede il 9% di tempo in più per completare quando il ObjectStateManager viene utilizzato.</span><span class="sxs-lookup"><span data-stu-id="350e1-596">Additionally, Entity Framework 5 takes 9% more time to complete when the ObjectStateManager is being used.</span></span> <span data-ttu-id="350e1-597">In confronto, Entity Framework 6 utilizza il 3% di tempo in più quando si utilizza ObjectStateManager.</span><span class="sxs-lookup"><span data-stu-id="350e1-597">In comparison, Entity Framework 6 is using 3% more time when using the ObjectStateManager.</span></span>

## <a name="6-query-execution-options"></a><span data-ttu-id="350e1-598">6 Opzioni di esecuzione delle query</span><span class="sxs-lookup"><span data-stu-id="350e1-598">6 Query Execution Options</span></span>

<span data-ttu-id="350e1-599">Entity Framework offre diversi modi per eseguire query.</span><span class="sxs-lookup"><span data-stu-id="350e1-599">Entity Framework offers several different ways to query.</span></span> <span data-ttu-id="350e1-600">Esamineremo le seguenti opzioni, confronteremo i pro e i contro di ciascuna ed esamineremo le loro caratteristiche di prestazione:</span><span class="sxs-lookup"><span data-stu-id="350e1-600">We'll take a look at the following options, compare the pros and cons of each, and examine their performance characteristics:</span></span>

-   <span data-ttu-id="350e1-601">LINQ to Entities.</span><span class="sxs-lookup"><span data-stu-id="350e1-601">LINQ to Entities.</span></span>
-   <span data-ttu-id="350e1-602">Nessun tracking LINQ to Entities.</span><span class="sxs-lookup"><span data-stu-id="350e1-602">No Tracking LINQ to Entities.</span></span>
-   <span data-ttu-id="350e1-603">Entity SQL su un oggetto ObjectQuery.</span><span class="sxs-lookup"><span data-stu-id="350e1-603">Entity SQL over an ObjectQuery.</span></span>
-   <span data-ttu-id="350e1-604">Entity SQL su un EntityCommand.</span><span class="sxs-lookup"><span data-stu-id="350e1-604">Entity SQL over an EntityCommand.</span></span>
-   <span data-ttu-id="350e1-605">ExecuteStoreQuery.</span><span class="sxs-lookup"><span data-stu-id="350e1-605">ExecuteStoreQuery.</span></span>
-   <span data-ttu-id="350e1-606">Oggetto SqlQuery.</span><span class="sxs-lookup"><span data-stu-id="350e1-606">SqlQuery.</span></span>
-   <span data-ttu-id="350e1-607">CompiledQuery.</span><span class="sxs-lookup"><span data-stu-id="350e1-607">CompiledQuery.</span></span>

### <a name="61-linq-to-entities-queries"></a><span data-ttu-id="350e1-608">6.1 Query LINQ to Entities</span><span class="sxs-lookup"><span data-stu-id="350e1-608">6.1       LINQ to Entities queries</span></span>

``` csharp
var q = context.Products.Where(p => p.Category.CategoryName == "Beverages");
```

<span data-ttu-id="350e1-609">**Pro**</span><span class="sxs-lookup"><span data-stu-id="350e1-609">**Pros**</span></span>

-   <span data-ttu-id="350e1-610">Adatto per le operazioni CUD.</span><span class="sxs-lookup"><span data-stu-id="350e1-610">Suitable for CUD operations.</span></span>
-   <span data-ttu-id="350e1-611">Oggetti completamente materializzati.</span><span class="sxs-lookup"><span data-stu-id="350e1-611">Fully materialized objects.</span></span>
-   <span data-ttu-id="350e1-612">Più semplice scrivere con la sintassi incorporata nel linguaggio di programmazione.</span><span class="sxs-lookup"><span data-stu-id="350e1-612">Simplest to write with syntax built into the programming language.</span></span>
-   <span data-ttu-id="350e1-613">Buone prestazioni.</span><span class="sxs-lookup"><span data-stu-id="350e1-613">Good performance.</span></span>

<span data-ttu-id="350e1-614">**Contro**</span><span class="sxs-lookup"><span data-stu-id="350e1-614">**Cons**</span></span>

-   <span data-ttu-id="350e1-615">Alcune restrizioni tecniche, quali:</span><span class="sxs-lookup"><span data-stu-id="350e1-615">Certain technical restrictions, such as:</span></span>
    -   <span data-ttu-id="350e1-616">I modelli che usano DefaultIfEmpty per le query OUTER JOIN generano query più complesse rispetto alle istruzioni OUTER JOIN semplici in Entity SQLEntity SQL.</span><span class="sxs-lookup"><span data-stu-id="350e1-616">Patterns using DefaultIfEmpty for OUTER JOIN queries result in more complex queries than simple OUTER JOIN statements in Entity SQL.</span></span>
    -   <span data-ttu-id="350e1-617">Non è ancora possibile usare LIKE con criteri di ricerca generali.</span><span class="sxs-lookup"><span data-stu-id="350e1-617">You still can’t use LIKE with general pattern matching.</span></span>

### <a name="62-no-tracking-linq-to-entities-queries"></a><span data-ttu-id="350e1-618">6.2 Nessun rilevamento di query LINQ to Entities</span><span class="sxs-lookup"><span data-stu-id="350e1-618">6.2       No Tracking LINQ to Entities queries</span></span>

<span data-ttu-id="350e1-619">Quando il contesto deriva ObjectContext:When the context derives ObjectContext:</span><span class="sxs-lookup"><span data-stu-id="350e1-619">When the context derives ObjectContext:</span></span>

``` csharp
context.Products.MergeOption = MergeOption.NoTracking;
var q = context.Products.Where(p => p.Category.CategoryName == "Beverages");
```

<span data-ttu-id="350e1-620">Quando il contesto deriva DbContext:When the context derives DbContext:</span><span class="sxs-lookup"><span data-stu-id="350e1-620">When the context derives DbContext:</span></span>

``` csharp
var q = context.Products.AsNoTracking()
                        .Where(p => p.Category.CategoryName == "Beverages");
```

<span data-ttu-id="350e1-621">**Pro**</span><span class="sxs-lookup"><span data-stu-id="350e1-621">**Pros**</span></span>

-   <span data-ttu-id="350e1-622">Miglioramento delle prestazioni rispetto alle normali query LINQ.</span><span class="sxs-lookup"><span data-stu-id="350e1-622">Improved performance over regular LINQ queries.</span></span>
-   <span data-ttu-id="350e1-623">Oggetti completamente materializzati.</span><span class="sxs-lookup"><span data-stu-id="350e1-623">Fully materialized objects.</span></span>
-   <span data-ttu-id="350e1-624">Più semplice scrivere con la sintassi incorporata nel linguaggio di programmazione.</span><span class="sxs-lookup"><span data-stu-id="350e1-624">Simplest to write with syntax built into the programming language.</span></span>

<span data-ttu-id="350e1-625">**Contro**</span><span class="sxs-lookup"><span data-stu-id="350e1-625">**Cons**</span></span>

-   <span data-ttu-id="350e1-626">Non adatto per le operazioni CUD.</span><span class="sxs-lookup"><span data-stu-id="350e1-626">Not suitable for CUD operations.</span></span>
-   <span data-ttu-id="350e1-627">Alcune restrizioni tecniche, quali:</span><span class="sxs-lookup"><span data-stu-id="350e1-627">Certain technical restrictions, such as:</span></span>
    -   <span data-ttu-id="350e1-628">I modelli che usano DefaultIfEmpty per le query OUTER JOIN generano query più complesse rispetto alle istruzioni OUTER JOIN semplici in Entity SQLEntity SQL.</span><span class="sxs-lookup"><span data-stu-id="350e1-628">Patterns using DefaultIfEmpty for OUTER JOIN queries result in more complex queries than simple OUTER JOIN statements in Entity SQL.</span></span>
    -   <span data-ttu-id="350e1-629">Non è ancora possibile usare LIKE con criteri di ricerca generali.</span><span class="sxs-lookup"><span data-stu-id="350e1-629">You still can’t use LIKE with general pattern matching.</span></span>

<span data-ttu-id="350e1-630">Si noti che le query che proiettano le proprietà scalari non vengono rilevate anche se NoTracking non è specificato.</span><span class="sxs-lookup"><span data-stu-id="350e1-630">Note that queries that project scalar properties are not tracked even if the NoTracking is not specified.</span></span> <span data-ttu-id="350e1-631">Ad esempio:</span><span class="sxs-lookup"><span data-stu-id="350e1-631">For example:</span></span>

``` csharp
var q = context.Products.Where(p => p.Category.CategoryName == "Beverages").Select(p => new { p.ProductName });
```

<span data-ttu-id="350e1-632">Questa particolare query non specifica in modo esplicito di NoTracking, ma poiché non sta materializzando un tipo noto al gestore dello stato dell'oggetto, il risultato materializzato non viene registrato.</span><span class="sxs-lookup"><span data-stu-id="350e1-632">This particular query doesn’t explicitly specify being NoTracking, but since it’s not materializing a type that’s known to the object state manager then the materialized result is not tracked.</span></span>

### <a name="63-entity-sql-over-an-objectquery"></a><span data-ttu-id="350e1-633">6.3 Entity SQL su un oggetto ObjectQuery</span><span class="sxs-lookup"><span data-stu-id="350e1-633">6.3       Entity SQL over an ObjectQuery</span></span>

``` csharp
ObjectQuery<Product> products = context.Products.Where("it.Category.CategoryName = 'Beverages'");
```

<span data-ttu-id="350e1-634">**Pro**</span><span class="sxs-lookup"><span data-stu-id="350e1-634">**Pros**</span></span>

-   <span data-ttu-id="350e1-635">Adatto per le operazioni CUD.</span><span class="sxs-lookup"><span data-stu-id="350e1-635">Suitable for CUD operations.</span></span>
-   <span data-ttu-id="350e1-636">Oggetti completamente materializzati.</span><span class="sxs-lookup"><span data-stu-id="350e1-636">Fully materialized objects.</span></span>
-   <span data-ttu-id="350e1-637">Supporta la memorizzazione nella cache del piano di query.</span><span class="sxs-lookup"><span data-stu-id="350e1-637">Supports query plan caching.</span></span>

<span data-ttu-id="350e1-638">**Contro**</span><span class="sxs-lookup"><span data-stu-id="350e1-638">**Cons**</span></span>

-   <span data-ttu-id="350e1-639">Coinvolge stringhe di query testuali che sono più soggette a errori dell'utente rispetto ai costrutti di query incorporati nel linguaggio.</span><span class="sxs-lookup"><span data-stu-id="350e1-639">Involves textual query strings which are more prone to user error than query constructs built into the language.</span></span>

### <a name="64-entity-sql-over-an-entity-command"></a><span data-ttu-id="350e1-640">6.4 Entity SQL su un comando di entità</span><span class="sxs-lookup"><span data-stu-id="350e1-640">6.4       Entity SQL over an Entity Command</span></span>

``` csharp
EntityCommand cmd = eConn.CreateCommand();
cmd.CommandText = "Select p From NorthwindEntities.Products As p Where p.Category.CategoryName = 'Beverages'";

using (EntityDataReader reader = cmd.ExecuteReader(CommandBehavior.SequentialAccess))
{
    while (reader.Read())
    {
        // manually 'materialize' the product
    }
}
```

<span data-ttu-id="350e1-641">**Pro**</span><span class="sxs-lookup"><span data-stu-id="350e1-641">**Pros**</span></span>

-   <span data-ttu-id="350e1-642">Supporta la memorizzazione nella cache del piano di query in .NET 4.0 (la memorizzazione nella cache del piano è supportata da tutti gli altri tipi di query in .NET 4.5).</span><span class="sxs-lookup"><span data-stu-id="350e1-642">Supports query plan caching in .NET 4.0 (plan caching is supported by all other query types in .NET 4.5).</span></span>

<span data-ttu-id="350e1-643">**Contro**</span><span class="sxs-lookup"><span data-stu-id="350e1-643">**Cons**</span></span>

-   <span data-ttu-id="350e1-644">Coinvolge stringhe di query testuali che sono più soggette a errori dell'utente rispetto ai costrutti di query incorporati nel linguaggio.</span><span class="sxs-lookup"><span data-stu-id="350e1-644">Involves textual query strings which are more prone to user error than query constructs built into the language.</span></span>
-   <span data-ttu-id="350e1-645">Non adatto per le operazioni CUD.</span><span class="sxs-lookup"><span data-stu-id="350e1-645">Not suitable for CUD operations.</span></span>
-   <span data-ttu-id="350e1-646">I risultati non vengono materializzati automaticamente e devono essere letti dal lettore dati.</span><span class="sxs-lookup"><span data-stu-id="350e1-646">Results are not automatically materialized, and must be read from the data reader.</span></span>

### <a name="65-sqlquery-and-executestorequery"></a><span data-ttu-id="350e1-647">6.5 SqlQuery ed ExecuteStoreQuery</span><span class="sxs-lookup"><span data-stu-id="350e1-647">6.5       SqlQuery and ExecuteStoreQuery</span></span>

<span data-ttu-id="350e1-648">SqlQuery nel database:</span><span class="sxs-lookup"><span data-stu-id="350e1-648">SqlQuery on Database:</span></span>

``` csharp
// use this to obtain entities and not track them
var q1 = context.Database.SqlQuery<Product>("select * from products");
```

<span data-ttu-id="350e1-649">SqlQuery su DbSet:</span><span class="sxs-lookup"><span data-stu-id="350e1-649">SqlQuery on DbSet:</span></span>

``` csharp
// use this to obtain entities and have them tracked
var q2 = context.Products.SqlQuery("select * from products");
```

<span data-ttu-id="350e1-650">ExecyteStoreQuery:</span><span class="sxs-lookup"><span data-stu-id="350e1-650">ExecyteStoreQuery:</span></span>

``` csharp
var beverages = context.ExecuteStoreQuery<Product>(
@"     SELECT        P.ProductID, P.ProductName, P.SupplierID, P.CategoryID, P.QuantityPerUnit, P.UnitPrice, P.UnitsInStock, P.UnitsOnOrder, P.ReorderLevel, P.Discontinued, P.DiscontinuedDate
       FROM            Products AS P INNER JOIN Categories AS C ON P.CategoryID = C.CategoryID
       WHERE        (C.CategoryName = 'Beverages')"
);
```

<span data-ttu-id="350e1-651">**Pro**</span><span class="sxs-lookup"><span data-stu-id="350e1-651">**Pros**</span></span>

-   <span data-ttu-id="350e1-652">Prestazioni generalmente più veloci poiché il compilatore del piano viene ignorato.</span><span class="sxs-lookup"><span data-stu-id="350e1-652">Generally fastest performance since plan compiler is bypassed.</span></span>
-   <span data-ttu-id="350e1-653">Oggetti completamente materializzati.</span><span class="sxs-lookup"><span data-stu-id="350e1-653">Fully materialized objects.</span></span>
-   <span data-ttu-id="350e1-654">Adatto per le operazioni CUD quando utilizzato dal DbSet.</span><span class="sxs-lookup"><span data-stu-id="350e1-654">Suitable for CUD operations when used from the DbSet.</span></span>

<span data-ttu-id="350e1-655">**Contro**</span><span class="sxs-lookup"><span data-stu-id="350e1-655">**Cons**</span></span>

-   <span data-ttu-id="350e1-656">La query è testuale e soggetta a errori.</span><span class="sxs-lookup"><span data-stu-id="350e1-656">Query is textual and error prone.</span></span>
-   <span data-ttu-id="350e1-657">La query è legata a un back-end specifico utilizzando la semantica dell'archivio anziché la semantica concettuale.</span><span class="sxs-lookup"><span data-stu-id="350e1-657">Query is tied to a specific backend by using store semantics instead of conceptual semantics.</span></span>
-   <span data-ttu-id="350e1-658">Quando è presente l'ereditarietà, la query creata a mano deve tenere conto delle condizioni di mapping per il tipo richiesto.</span><span class="sxs-lookup"><span data-stu-id="350e1-658">When inheritance is present, handcrafted query needs to account for mapping conditions for the type requested.</span></span>

### <a name="66-compiledquery"></a><span data-ttu-id="350e1-659">6.6 Database CompilatoQuery</span><span class="sxs-lookup"><span data-stu-id="350e1-659">6.6       CompiledQuery</span></span>

``` csharp
private static readonly Func<NorthwindEntities, string, IQueryable<Product>> productsForCategoryCQ = CompiledQuery.Compile(
    (NorthwindEntities context, string categoryName) =>
        context.Products.Where(p => p.Category.CategoryName == categoryName)
        );
…
var q = context.InvokeProductsForCategoryCQ("Beverages");
```

<span data-ttu-id="350e1-660">**Pro**</span><span class="sxs-lookup"><span data-stu-id="350e1-660">**Pros**</span></span>

-   <span data-ttu-id="350e1-661">Fornisce fino a un miglioramento delle prestazioni del 7% rispetto alle normali query LINQ.</span><span class="sxs-lookup"><span data-stu-id="350e1-661">Provides up to a 7% performance improvement over regular LINQ queries.</span></span>
-   <span data-ttu-id="350e1-662">Oggetti completamente materializzati.</span><span class="sxs-lookup"><span data-stu-id="350e1-662">Fully materialized objects.</span></span>
-   <span data-ttu-id="350e1-663">Adatto per le operazioni CUD.</span><span class="sxs-lookup"><span data-stu-id="350e1-663">Suitable for CUD operations.</span></span>

<span data-ttu-id="350e1-664">**Contro**</span><span class="sxs-lookup"><span data-stu-id="350e1-664">**Cons**</span></span>

-   <span data-ttu-id="350e1-665">Aumento della complessità e dell'overhead di programmazione.</span><span class="sxs-lookup"><span data-stu-id="350e1-665">Increased complexity and programming overhead.</span></span>
-   <span data-ttu-id="350e1-666">Il miglioramento delle prestazioni viene perso durante la composizione su una query compilata.</span><span class="sxs-lookup"><span data-stu-id="350e1-666">The performance improvement is lost when composing on top of a compiled query.</span></span>
-   <span data-ttu-id="350e1-667">Alcune query LINQ non possono essere scritte come CompiledQuery, ad esempio proiezioni di tipi anonimi.</span><span class="sxs-lookup"><span data-stu-id="350e1-667">Some LINQ queries can't be written as a CompiledQuery - for example, projections of anonymous types.</span></span>

### <a name="67-performance-comparison-of-different-query-options"></a><span data-ttu-id="350e1-668">6.7 Confronto delle prestazioni tra diverse opzioni di query</span><span class="sxs-lookup"><span data-stu-id="350e1-668">6.7       Performance Comparison of different query options</span></span>

<span data-ttu-id="350e1-669">Sono stati sottoposti alla prova semplici microbenchmark in cui la creazione del contesto non è stata eseguita.</span><span class="sxs-lookup"><span data-stu-id="350e1-669">Simple microbenchmarks where the context creation was not timed were put to the test.</span></span> <span data-ttu-id="350e1-670">Abbiamo misurato l'esecuzione di query 5000 volte per un set di entità non memorizzate nella cache in un ambiente controllato.</span><span class="sxs-lookup"><span data-stu-id="350e1-670">We measured querying 5000 times for a set of non-cached entities in a controlled environment.</span></span> <span data-ttu-id="350e1-671">Questi numeri devono essere presi con un avvertimento: non riflettono i numeri effettivi prodotti da un'applicazione, ma sono invece una misura molto accurata di quanta differenza di prestazioni c'è quando diverse opzioni di query vengono confrontate mele a mele, escludendo il costo della creazione di un nuovo contesto.</span><span class="sxs-lookup"><span data-stu-id="350e1-671">These numbers are to be taken with a warning: they do not reflect actual numbers produced by an application, but instead they are a very accurate measurement of how much of a performance difference there is when different querying options are compared apples-to-apples, excluding the cost of creating a new context.</span></span>

| <span data-ttu-id="350e1-672">EF</span><span class="sxs-lookup"><span data-stu-id="350e1-672">EF</span></span>  | <span data-ttu-id="350e1-673">Test</span><span class="sxs-lookup"><span data-stu-id="350e1-673">Test</span></span>                                 | <span data-ttu-id="350e1-674">Ora (ms)</span><span class="sxs-lookup"><span data-stu-id="350e1-674">Time (ms)</span></span> | <span data-ttu-id="350e1-675">Memoria</span><span class="sxs-lookup"><span data-stu-id="350e1-675">Memory</span></span>   |
|:----|:-------------------------------------|:----------|:---------|
| <span data-ttu-id="350e1-676">EF5</span><span class="sxs-lookup"><span data-stu-id="350e1-676">EF5</span></span> | <span data-ttu-id="350e1-677">ObjectContext ESQL</span><span class="sxs-lookup"><span data-stu-id="350e1-677">ObjectContext ESQL</span></span>                   | <span data-ttu-id="350e1-678">2414</span><span class="sxs-lookup"><span data-stu-id="350e1-678">2414</span></span>      | <span data-ttu-id="350e1-679">38801408</span><span class="sxs-lookup"><span data-stu-id="350e1-679">38801408</span></span> |
| <span data-ttu-id="350e1-680">EF5</span><span class="sxs-lookup"><span data-stu-id="350e1-680">EF5</span></span> | <span data-ttu-id="350e1-681">ObjectContext Linq Query</span><span class="sxs-lookup"><span data-stu-id="350e1-681">ObjectContext Linq Query</span></span>             | <span data-ttu-id="350e1-682">2692</span><span class="sxs-lookup"><span data-stu-id="350e1-682">2692</span></span>      | <span data-ttu-id="350e1-683">38277120</span><span class="sxs-lookup"><span data-stu-id="350e1-683">38277120</span></span> |
| <span data-ttu-id="350e1-684">EF5</span><span class="sxs-lookup"><span data-stu-id="350e1-684">EF5</span></span> | <span data-ttu-id="350e1-685">DbContext Linq Query Nessun rilevamento</span><span class="sxs-lookup"><span data-stu-id="350e1-685">DbContext Linq Query No Tracking</span></span>     | <span data-ttu-id="350e1-686">2818</span><span class="sxs-lookup"><span data-stu-id="350e1-686">2818</span></span>      | <span data-ttu-id="350e1-687">41840640</span><span class="sxs-lookup"><span data-stu-id="350e1-687">41840640</span></span> |
| <span data-ttu-id="350e1-688">EF5</span><span class="sxs-lookup"><span data-stu-id="350e1-688">EF5</span></span> | <span data-ttu-id="350e1-689">DbContext Linq Query</span><span class="sxs-lookup"><span data-stu-id="350e1-689">DbContext Linq Query</span></span>                 | <span data-ttu-id="350e1-690">2930</span><span class="sxs-lookup"><span data-stu-id="350e1-690">2930</span></span>      | <span data-ttu-id="350e1-691">41771008</span><span class="sxs-lookup"><span data-stu-id="350e1-691">41771008</span></span> |
| <span data-ttu-id="350e1-692">EF5</span><span class="sxs-lookup"><span data-stu-id="350e1-692">EF5</span></span> | <span data-ttu-id="350e1-693">ObjectContext Linq Query Nessun rilevamento</span><span class="sxs-lookup"><span data-stu-id="350e1-693">ObjectContext Linq Query No Tracking</span></span> | <span data-ttu-id="350e1-694">3013</span><span class="sxs-lookup"><span data-stu-id="350e1-694">3013</span></span>      | <span data-ttu-id="350e1-695">38412288</span><span class="sxs-lookup"><span data-stu-id="350e1-695">38412288</span></span> |
|     |                                      |           |          |
| <span data-ttu-id="350e1-696">EF6</span><span class="sxs-lookup"><span data-stu-id="350e1-696">EF6</span></span> | <span data-ttu-id="350e1-697">ObjectContext ESQL</span><span class="sxs-lookup"><span data-stu-id="350e1-697">ObjectContext ESQL</span></span>                   | <span data-ttu-id="350e1-698">2059</span><span class="sxs-lookup"><span data-stu-id="350e1-698">2059</span></span>      | <span data-ttu-id="350e1-699">46039040</span><span class="sxs-lookup"><span data-stu-id="350e1-699">46039040</span></span> |
| <span data-ttu-id="350e1-700">EF6</span><span class="sxs-lookup"><span data-stu-id="350e1-700">EF6</span></span> | <span data-ttu-id="350e1-701">ObjectContext Linq Query</span><span class="sxs-lookup"><span data-stu-id="350e1-701">ObjectContext Linq Query</span></span>             | <span data-ttu-id="350e1-702">3074</span><span class="sxs-lookup"><span data-stu-id="350e1-702">3074</span></span>      | <span data-ttu-id="350e1-703">45248512</span><span class="sxs-lookup"><span data-stu-id="350e1-703">45248512</span></span> |
| <span data-ttu-id="350e1-704">EF6</span><span class="sxs-lookup"><span data-stu-id="350e1-704">EF6</span></span> | <span data-ttu-id="350e1-705">DbContext Linq Query Nessun rilevamento</span><span class="sxs-lookup"><span data-stu-id="350e1-705">DbContext Linq Query No Tracking</span></span>     | <span data-ttu-id="350e1-706">3125</span><span class="sxs-lookup"><span data-stu-id="350e1-706">3125</span></span>      | <span data-ttu-id="350e1-707">47575040</span><span class="sxs-lookup"><span data-stu-id="350e1-707">47575040</span></span> |
| <span data-ttu-id="350e1-708">EF6</span><span class="sxs-lookup"><span data-stu-id="350e1-708">EF6</span></span> | <span data-ttu-id="350e1-709">DbContext Linq Query</span><span class="sxs-lookup"><span data-stu-id="350e1-709">DbContext Linq Query</span></span>                 | <span data-ttu-id="350e1-710">3420</span><span class="sxs-lookup"><span data-stu-id="350e1-710">3420</span></span>      | <span data-ttu-id="350e1-711">47652864</span><span class="sxs-lookup"><span data-stu-id="350e1-711">47652864</span></span> |
| <span data-ttu-id="350e1-712">EF6</span><span class="sxs-lookup"><span data-stu-id="350e1-712">EF6</span></span> | <span data-ttu-id="350e1-713">ObjectContext Linq Query Nessun rilevamento</span><span class="sxs-lookup"><span data-stu-id="350e1-713">ObjectContext Linq Query No Tracking</span></span> | <span data-ttu-id="350e1-714">3593</span><span class="sxs-lookup"><span data-stu-id="350e1-714">3593</span></span>      | <span data-ttu-id="350e1-715">45260800</span><span class="sxs-lookup"><span data-stu-id="350e1-715">45260800</span></span> |

![Micro benchmark EF5, 5000 iterazioni calde](~/ef6/media/ef5micro5000warm.png)

![Micro benchmark EF6, 5000 iterazioni calde](~/ef6/media/ef6micro5000warm.png)

<span data-ttu-id="350e1-718">I microbenchmark sono molto sensibili alle piccole modifiche nel codice.</span><span class="sxs-lookup"><span data-stu-id="350e1-718">Microbenchmarks are very sensitive to small changes in the code.</span></span> <span data-ttu-id="350e1-719">In questo caso, la differenza tra i costi di Entity Framework 5 ed Entity Framework 6 è dovuta all'aggiunta di intercettazioni e [miglioramenti transazionali.](~/ef6/saving/transactions.md) [interception](~/ef6/fundamentals/logging-and-interception.md)</span><span class="sxs-lookup"><span data-stu-id="350e1-719">In this case, the difference between the costs of Entity Framework 5 and Entity Framework 6 are due to the addition of [interception](~/ef6/fundamentals/logging-and-interception.md) and [transactional improvements](~/ef6/saving/transactions.md).</span></span> <span data-ttu-id="350e1-720">Questi numeri di microbenchmark, tuttavia, sono una visione amplificata in un frammento molto piccolo di ciò che Entity Framework fa.</span><span class="sxs-lookup"><span data-stu-id="350e1-720">These microbenchmarks numbers, however, are an amplified vision into a very small fragment of what Entity Framework does.</span></span> <span data-ttu-id="350e1-721">Scenari reali di query a caldo non devono visualizzare una regressione delle prestazioni durante l'aggiornamento da Entity Framework 5 a Entity Framework 6.</span><span class="sxs-lookup"><span data-stu-id="350e1-721">Real-world scenarios of warm queries should not see a performance regression when upgrading from Entity Framework 5 to Entity Framework 6.</span></span>

<span data-ttu-id="350e1-722">Per confrontare le prestazioni reali delle diverse opzioni di query, abbiamo creato 5 varianti di test separate in cui utilizziamo un'opzione di query diversa per selezionare tutti i prodotti il cui nome di categoria è "Beverages".</span><span class="sxs-lookup"><span data-stu-id="350e1-722">To compare the real-world performance of the different query options, we created 5 separate test variations where we use a different query option to select all products whose category name is "Beverages".</span></span> <span data-ttu-id="350e1-723">Ogni iterazione include il costo di creazione del contesto e il costo di materializzazione di tutte le entità restituite.</span><span class="sxs-lookup"><span data-stu-id="350e1-723">Each iteration includes the cost of creating the context, and the cost of materializing all returned entities.</span></span> <span data-ttu-id="350e1-724">10 iterazioni vengono eseguite senza tempo prima di prendere la somma di 1000 iterazioni temportime.</span><span class="sxs-lookup"><span data-stu-id="350e1-724">10 iterations are run untimed before taking the sum of 1000 timed iterations.</span></span> <span data-ttu-id="350e1-725">I risultati mostrati sono l'esecuzione mediana tratta da 5 esecuzioni di ogni test.</span><span class="sxs-lookup"><span data-stu-id="350e1-725">The results shown are the median run taken from 5 runs of each test.</span></span> <span data-ttu-id="350e1-726">Per ulteriori informazioni, vedere l'Appendice B che include il codice per il test.</span><span class="sxs-lookup"><span data-stu-id="350e1-726">For more information, see Appendix B which includes the code for the test.</span></span>

| <span data-ttu-id="350e1-727">EF</span><span class="sxs-lookup"><span data-stu-id="350e1-727">EF</span></span>  | <span data-ttu-id="350e1-728">Test</span><span class="sxs-lookup"><span data-stu-id="350e1-728">Test</span></span>                                        | <span data-ttu-id="350e1-729">Ora (ms)</span><span class="sxs-lookup"><span data-stu-id="350e1-729">Time (ms)</span></span> | <span data-ttu-id="350e1-730">Memoria</span><span class="sxs-lookup"><span data-stu-id="350e1-730">Memory</span></span>   |
|:----|:--------------------------------------------|:----------|:---------|
| <span data-ttu-id="350e1-731">EF5</span><span class="sxs-lookup"><span data-stu-id="350e1-731">EF5</span></span> | <span data-ttu-id="350e1-732">Comando entità ObjectContext</span><span class="sxs-lookup"><span data-stu-id="350e1-732">ObjectContext Entity Command</span></span>                | <span data-ttu-id="350e1-733">621</span><span class="sxs-lookup"><span data-stu-id="350e1-733">621</span></span>       | <span data-ttu-id="350e1-734">39350272</span><span class="sxs-lookup"><span data-stu-id="350e1-734">39350272</span></span> |
| <span data-ttu-id="350e1-735">EF5</span><span class="sxs-lookup"><span data-stu-id="350e1-735">EF5</span></span> | <span data-ttu-id="350e1-736">DbContext Sql Query on Database</span><span class="sxs-lookup"><span data-stu-id="350e1-736">DbContext Sql Query on Database</span></span>             | <span data-ttu-id="350e1-737">825</span><span class="sxs-lookup"><span data-stu-id="350e1-737">825</span></span>       | <span data-ttu-id="350e1-738">37519360</span><span class="sxs-lookup"><span data-stu-id="350e1-738">37519360</span></span> |
| <span data-ttu-id="350e1-739">EF5</span><span class="sxs-lookup"><span data-stu-id="350e1-739">EF5</span></span> | <span data-ttu-id="350e1-740">Query dell'archivio ObjectContext</span><span class="sxs-lookup"><span data-stu-id="350e1-740">ObjectContext Store Query</span></span>                   | <span data-ttu-id="350e1-741">878</span><span class="sxs-lookup"><span data-stu-id="350e1-741">878</span></span>       | <span data-ttu-id="350e1-742">39460864</span><span class="sxs-lookup"><span data-stu-id="350e1-742">39460864</span></span> |
| <span data-ttu-id="350e1-743">EF5</span><span class="sxs-lookup"><span data-stu-id="350e1-743">EF5</span></span> | <span data-ttu-id="350e1-744">ObjectContext Linq Query Nessun rilevamento</span><span class="sxs-lookup"><span data-stu-id="350e1-744">ObjectContext Linq Query No Tracking</span></span>        | <span data-ttu-id="350e1-745">969</span><span class="sxs-lookup"><span data-stu-id="350e1-745">969</span></span>       | <span data-ttu-id="350e1-746">38293504</span><span class="sxs-lookup"><span data-stu-id="350e1-746">38293504</span></span> |
| <span data-ttu-id="350e1-747">EF5</span><span class="sxs-lookup"><span data-stu-id="350e1-747">EF5</span></span> | <span data-ttu-id="350e1-748">ObjectContext Entity Sql using Object Query</span><span class="sxs-lookup"><span data-stu-id="350e1-748">ObjectContext Entity Sql using Object Query</span></span> | <span data-ttu-id="350e1-749">1089</span><span class="sxs-lookup"><span data-stu-id="350e1-749">1089</span></span>      | <span data-ttu-id="350e1-750">38981632</span><span class="sxs-lookup"><span data-stu-id="350e1-750">38981632</span></span> |
| <span data-ttu-id="350e1-751">EF5</span><span class="sxs-lookup"><span data-stu-id="350e1-751">EF5</span></span> | <span data-ttu-id="350e1-752">Query compilata ObjectContext</span><span class="sxs-lookup"><span data-stu-id="350e1-752">ObjectContext Compiled Query</span></span>                | <span data-ttu-id="350e1-753">1099</span><span class="sxs-lookup"><span data-stu-id="350e1-753">1099</span></span>      | <span data-ttu-id="350e1-754">38682624</span><span class="sxs-lookup"><span data-stu-id="350e1-754">38682624</span></span> |
| <span data-ttu-id="350e1-755">EF5</span><span class="sxs-lookup"><span data-stu-id="350e1-755">EF5</span></span> | <span data-ttu-id="350e1-756">ObjectContext Linq Query</span><span class="sxs-lookup"><span data-stu-id="350e1-756">ObjectContext Linq Query</span></span>                    | <span data-ttu-id="350e1-757">1152</span><span class="sxs-lookup"><span data-stu-id="350e1-757">1152</span></span>      | <span data-ttu-id="350e1-758">38178816</span><span class="sxs-lookup"><span data-stu-id="350e1-758">38178816</span></span> |
| <span data-ttu-id="350e1-759">EF5</span><span class="sxs-lookup"><span data-stu-id="350e1-759">EF5</span></span> | <span data-ttu-id="350e1-760">DbContext Linq Query Nessun rilevamento</span><span class="sxs-lookup"><span data-stu-id="350e1-760">DbContext Linq Query No Tracking</span></span>            | <span data-ttu-id="350e1-761">1208</span><span class="sxs-lookup"><span data-stu-id="350e1-761">1208</span></span>      | <span data-ttu-id="350e1-762">41803776</span><span class="sxs-lookup"><span data-stu-id="350e1-762">41803776</span></span> |
| <span data-ttu-id="350e1-763">EF5</span><span class="sxs-lookup"><span data-stu-id="350e1-763">EF5</span></span> | <span data-ttu-id="350e1-764">Query sql DbContext su DbSet</span><span class="sxs-lookup"><span data-stu-id="350e1-764">DbContext Sql Query on DbSet</span></span>                | <span data-ttu-id="350e1-765">1414</span><span class="sxs-lookup"><span data-stu-id="350e1-765">1414</span></span>      | <span data-ttu-id="350e1-766">37982208</span><span class="sxs-lookup"><span data-stu-id="350e1-766">37982208</span></span> |
| <span data-ttu-id="350e1-767">EF5</span><span class="sxs-lookup"><span data-stu-id="350e1-767">EF5</span></span> | <span data-ttu-id="350e1-768">DbContext Linq Query</span><span class="sxs-lookup"><span data-stu-id="350e1-768">DbContext Linq Query</span></span>                        | <span data-ttu-id="350e1-769">1574</span><span class="sxs-lookup"><span data-stu-id="350e1-769">1574</span></span>      | <span data-ttu-id="350e1-770">41738240</span><span class="sxs-lookup"><span data-stu-id="350e1-770">41738240</span></span> |
|     |                                             |           |          |
| <span data-ttu-id="350e1-771">EF6</span><span class="sxs-lookup"><span data-stu-id="350e1-771">EF6</span></span> | <span data-ttu-id="350e1-772">Comando entità ObjectContext</span><span class="sxs-lookup"><span data-stu-id="350e1-772">ObjectContext Entity Command</span></span>                | <span data-ttu-id="350e1-773">480</span><span class="sxs-lookup"><span data-stu-id="350e1-773">480</span></span>       | <span data-ttu-id="350e1-774">47247360</span><span class="sxs-lookup"><span data-stu-id="350e1-774">47247360</span></span> |
| <span data-ttu-id="350e1-775">EF6</span><span class="sxs-lookup"><span data-stu-id="350e1-775">EF6</span></span> | <span data-ttu-id="350e1-776">Query dell'archivio ObjectContext</span><span class="sxs-lookup"><span data-stu-id="350e1-776">ObjectContext Store Query</span></span>                   | <span data-ttu-id="350e1-777">493</span><span class="sxs-lookup"><span data-stu-id="350e1-777">493</span></span>       | <span data-ttu-id="350e1-778">46739456</span><span class="sxs-lookup"><span data-stu-id="350e1-778">46739456</span></span> |
| <span data-ttu-id="350e1-779">EF6</span><span class="sxs-lookup"><span data-stu-id="350e1-779">EF6</span></span> | <span data-ttu-id="350e1-780">DbContext Sql Query on Database</span><span class="sxs-lookup"><span data-stu-id="350e1-780">DbContext Sql Query on Database</span></span>             | <span data-ttu-id="350e1-781">614</span><span class="sxs-lookup"><span data-stu-id="350e1-781">614</span></span>       | <span data-ttu-id="350e1-782">41607168</span><span class="sxs-lookup"><span data-stu-id="350e1-782">41607168</span></span> |
| <span data-ttu-id="350e1-783">EF6</span><span class="sxs-lookup"><span data-stu-id="350e1-783">EF6</span></span> | <span data-ttu-id="350e1-784">ObjectContext Linq Query Nessun rilevamento</span><span class="sxs-lookup"><span data-stu-id="350e1-784">ObjectContext Linq Query No Tracking</span></span>        | <span data-ttu-id="350e1-785">684</span><span class="sxs-lookup"><span data-stu-id="350e1-785">684</span></span>       | <span data-ttu-id="350e1-786">46333952</span><span class="sxs-lookup"><span data-stu-id="350e1-786">46333952</span></span> |
| <span data-ttu-id="350e1-787">EF6</span><span class="sxs-lookup"><span data-stu-id="350e1-787">EF6</span></span> | <span data-ttu-id="350e1-788">ObjectContext Entity Sql using Object Query</span><span class="sxs-lookup"><span data-stu-id="350e1-788">ObjectContext Entity Sql using Object Query</span></span> | <span data-ttu-id="350e1-789">767</span><span class="sxs-lookup"><span data-stu-id="350e1-789">767</span></span>       | <span data-ttu-id="350e1-790">48865280</span><span class="sxs-lookup"><span data-stu-id="350e1-790">48865280</span></span> |
| <span data-ttu-id="350e1-791">EF6</span><span class="sxs-lookup"><span data-stu-id="350e1-791">EF6</span></span> | <span data-ttu-id="350e1-792">Query compilata ObjectContext</span><span class="sxs-lookup"><span data-stu-id="350e1-792">ObjectContext Compiled Query</span></span>                | <span data-ttu-id="350e1-793">788</span><span class="sxs-lookup"><span data-stu-id="350e1-793">788</span></span>       | <span data-ttu-id="350e1-794">48467968</span><span class="sxs-lookup"><span data-stu-id="350e1-794">48467968</span></span> |
| <span data-ttu-id="350e1-795">EF6</span><span class="sxs-lookup"><span data-stu-id="350e1-795">EF6</span></span> | <span data-ttu-id="350e1-796">DbContext Linq Query Nessun rilevamento</span><span class="sxs-lookup"><span data-stu-id="350e1-796">DbContext Linq Query No Tracking</span></span>            | <span data-ttu-id="350e1-797">878</span><span class="sxs-lookup"><span data-stu-id="350e1-797">878</span></span>       | <span data-ttu-id="350e1-798">47554560</span><span class="sxs-lookup"><span data-stu-id="350e1-798">47554560</span></span> |
| <span data-ttu-id="350e1-799">EF6</span><span class="sxs-lookup"><span data-stu-id="350e1-799">EF6</span></span> | <span data-ttu-id="350e1-800">ObjectContext Linq Query</span><span class="sxs-lookup"><span data-stu-id="350e1-800">ObjectContext Linq Query</span></span>                    | <span data-ttu-id="350e1-801">953</span><span class="sxs-lookup"><span data-stu-id="350e1-801">953</span></span>       | <span data-ttu-id="350e1-802">47632384</span><span class="sxs-lookup"><span data-stu-id="350e1-802">47632384</span></span> |
| <span data-ttu-id="350e1-803">EF6</span><span class="sxs-lookup"><span data-stu-id="350e1-803">EF6</span></span> | <span data-ttu-id="350e1-804">Query sql DbContext su DbSet</span><span class="sxs-lookup"><span data-stu-id="350e1-804">DbContext Sql Query on DbSet</span></span>                | <span data-ttu-id="350e1-805">1023</span><span class="sxs-lookup"><span data-stu-id="350e1-805">1023</span></span>      | <span data-ttu-id="350e1-806">41992192</span><span class="sxs-lookup"><span data-stu-id="350e1-806">41992192</span></span> |
| <span data-ttu-id="350e1-807">EF6</span><span class="sxs-lookup"><span data-stu-id="350e1-807">EF6</span></span> | <span data-ttu-id="350e1-808">DbContext Linq Query</span><span class="sxs-lookup"><span data-stu-id="350e1-808">DbContext Linq Query</span></span>                        | <span data-ttu-id="350e1-809">1290</span><span class="sxs-lookup"><span data-stu-id="350e1-809">1290</span></span>      | <span data-ttu-id="350e1-810">47529984</span><span class="sxs-lookup"><span data-stu-id="350e1-810">47529984</span></span> |


![Query a caldo di EF5 1000 iterazioni](~/ef6/media/ef5warmquery1000.png)

![Query a caldo EF6 1000 iterazioni](~/ef6/media/ef6warmquery1000.png)

> [!NOTE]
> <span data-ttu-id="350e1-813">Per completezza, è stata inclusa una variante in cui viene eseguita una query Entity SQL su un EntityCommand.For completeness, we included a variation where we execute an Entity SQL query on an EntityCommand.</span><span class="sxs-lookup"><span data-stu-id="350e1-813">For completeness, we included a variation where we execute an Entity SQL query on an EntityCommand.</span></span> <span data-ttu-id="350e1-814">Tuttavia, poiché i risultati non sono materializzati per tali query, il confronto non è necessariamente mele a mele.</span><span class="sxs-lookup"><span data-stu-id="350e1-814">However, because results are not materialized for such queries, the comparison isn't necessarily apples-to-apples.</span></span> <span data-ttu-id="350e1-815">Il test include una stretta approssimazione alla materializzazione per cercare di rendere il confronto più equo.</span><span class="sxs-lookup"><span data-stu-id="350e1-815">The test includes a close approximation to materializing to try making the comparison fairer.</span></span>

<span data-ttu-id="350e1-816">In questo caso end-to-end, Entity Framework 6 supera Entity Framework 5 a causa di miglioramenti delle prestazioni apportati in diverse parti dello stack, tra cui un'inizializzazione DbContext molto più leggero e più veloci ricerche di MetadataCollection&lt;T.&gt;</span><span class="sxs-lookup"><span data-stu-id="350e1-816">In this end-to-end case, Entity Framework 6 outperforms Entity Framework 5 due to performance improvements made on several parts of the stack, including a much lighter DbContext initialization and faster MetadataCollection&lt;T&gt; lookups.</span></span>

## <a name="7-design-time-performance-considerations"></a><span data-ttu-id="350e1-817">7 Considerazioni sulle prestazioni del tempo di progettazione</span><span class="sxs-lookup"><span data-stu-id="350e1-817">7 Design time performance considerations</span></span>

### <a name="71-inheritance-strategies"></a><span data-ttu-id="350e1-818">7.1 Strategie di ereditarietà</span><span class="sxs-lookup"><span data-stu-id="350e1-818">7.1       Inheritance Strategies</span></span>

<span data-ttu-id="350e1-819">Un'altra considerazione sulle prestazioni quando si utilizza Entity Framework è la strategia di ereditarietà utilizzata.</span><span class="sxs-lookup"><span data-stu-id="350e1-819">Another performance consideration when using Entity Framework is the inheritance strategy you use.</span></span> <span data-ttu-id="350e1-820">Entity Framework supporta 3 tipi di ereditarietà di base e le relative combinazioni:</span><span class="sxs-lookup"><span data-stu-id="350e1-820">Entity Framework supports 3 basic types of inheritance and their combinations:</span></span>

-   <span data-ttu-id="350e1-821">Tabella per gerarchia (TPH): in cui ogni set di ereditarietà viene mappato a una tabella con una colonna discriminatore per indicare quale particolare tipo nella gerarchia viene rappresentato nella riga.</span><span class="sxs-lookup"><span data-stu-id="350e1-821">Table per Hierarchy (TPH) – where each inheritance set maps to a table with a discriminator column to indicate which particular type in the hierarchy is being represented in the row.</span></span>
-   <span data-ttu-id="350e1-822">Tabella per tipo (TPT), in cui ogni tipo dispone di una propria tabella nel database. le tabelle figlio definiscono solo le colonne che la tabella padre non contiene.</span><span class="sxs-lookup"><span data-stu-id="350e1-822">Table per Type (TPT) – where each type has its own table in the database; the child tables only define the columns that the parent table doesn’t contain.</span></span>
-   <span data-ttu-id="350e1-823">Tabella per classe (TPC), in cui ogni tipo dispone di una tabella completa nel database. le tabelle figlio definiscono tutti i relativi campi, inclusi quelli definiti nei tipi padre.</span><span class="sxs-lookup"><span data-stu-id="350e1-823">Table per Class (TPC) – where each type has its own full table in the database; the child tables define all their fields, including those defined in parent types.</span></span>

<span data-ttu-id="350e1-824">Se il modello utilizza l'ereditarietà TPT, le query generate saranno più complesse di quelle generate con le altre strategie di ereditarietà, che possono comportare tempi di esecuzione più lunghi nell'archivio.</span><span class="sxs-lookup"><span data-stu-id="350e1-824">If your model uses TPT inheritance, the queries which are generated will be more complex than those that are generated with the other inheritance strategies, which may result on longer execution times on the store.</span></span><span data-ttu-id="350e1-825">In genere, la generazione di query su un modello TPT e la materializzare gli oggetti risultanti richiede più tempo.</span><span class="sxs-lookup"><span data-stu-id="350e1-825">  It will generally take longer to generate queries over a TPT model, and to materialize the resulting objects.</span></span>

<span data-ttu-id="350e1-826">Vedere il post di blog MSDN "Considerazioni sulle prestazioni quando si \< https://docs.microsoft.com/archive/blogs/adonet/performance-considerations-when-using-tpt-table-per-type-inheritance-in-the-entity-framework>utilizza l'ereditarietà TPT (tabella per tipo) in Entity Framework: .</span><span class="sxs-lookup"><span data-stu-id="350e1-826">See the "Performance Considerations when using TPT (Table per Type) Inheritance in the Entity Framework" MSDN blog post: \<https://docs.microsoft.com/archive/blogs/adonet/performance-considerations-when-using-tpt-table-per-type-inheritance-in-the-entity-framework>.</span></span>

#### <a name="711-avoiding-tpt-in-model-first-or-code-first-applications"></a><span data-ttu-id="350e1-827">7.1.1 Evitare il TPT nelle applicazioni Model First o Code First</span><span class="sxs-lookup"><span data-stu-id="350e1-827">7.1.1       Avoiding TPT in Model First or Code First applications</span></span>

<span data-ttu-id="350e1-828">Quando si crea un modello su un database esistente che dispone di uno schema TPT, non sono disponibili molte opzioni.</span><span class="sxs-lookup"><span data-stu-id="350e1-828">When you create a model over an existing database that has a TPT schema, you don't have many options.</span></span> <span data-ttu-id="350e1-829">Tuttavia, quando si crea un'applicazione utilizzando Model First o Code First, è consigliabile evitare l'ereditarietà TPT per problemi di prestazioni.</span><span class="sxs-lookup"><span data-stu-id="350e1-829">But when creating an application using Model First or Code First, you should avoid TPT inheritance for performance concerns.</span></span>

<span data-ttu-id="350e1-830">Quando si utilizza Model First nella procedura guidata Entity Designer, si otterrà TPT per qualsiasi ereditarietà nel modello.</span><span class="sxs-lookup"><span data-stu-id="350e1-830">When you use Model First in the Entity Designer Wizard, you will get TPT for any inheritance in your model.</span></span> <span data-ttu-id="350e1-831">Se si desidera passare a una strategia di ereditarietà TPH con Model First, è possibile \< http://visualstudiogallery.msdn.microsoft.com/df3541c3-d833-4b65-b942-989e7ec74c87/>)utilizzare il "Entity Designer Database Generation Power Pack" disponibile in Visual Studio Gallery ( .</span><span class="sxs-lookup"><span data-stu-id="350e1-831">If you want to switch to a TPH inheritance strategy with Model First, you can use the "Entity Designer Database Generation Power Pack" available from the Visual Studio Gallery ( \<http://visualstudiogallery.msdn.microsoft.com/df3541c3-d833-4b65-b942-989e7ec74c87/>).</span></span>

<span data-ttu-id="350e1-832">Quando si usa Code First per configurare il mapping di un modello con ereditarietà, EF utilizzerà TPH per impostazione predefinita, pertanto tutte le entità nella gerarchia di ereditarietà verranno mappate alla stessa tabella.</span><span class="sxs-lookup"><span data-stu-id="350e1-832">When using Code First to configure the mapping of a model with inheritance, EF will use TPH by default, therefore all entities in the inheritance hierarchy will be mapped to the same table.</span></span> <span data-ttu-id="350e1-833">Vedere la sezione "Mapping con l'API Fluent" dell'articolo "Code First [http://msdn.microsoft.com/magazine/hh126815.aspx](https://msdn.microsoft.com/magazine/hh126815.aspx)in Entity Framework4.1" in MSDN Magazine ( ) per ulteriori dettagli.</span><span class="sxs-lookup"><span data-stu-id="350e1-833">See the "Mapping with the Fluent API" section of the "Code First in Entity Framework4.1" article in MSDN Magazine ( [http://msdn.microsoft.com/magazine/hh126815.aspx](https://msdn.microsoft.com/magazine/hh126815.aspx)) for more details.</span></span>

### <a name="72-upgrading-from-ef4-to-improve-model-generation-time"></a><span data-ttu-id="350e1-834">7.2 Aggiornamento da EF4 per migliorare i tempi di generazione del modello</span><span class="sxs-lookup"><span data-stu-id="350e1-834">7.2       Upgrading from EF4 to improve model generation time</span></span>

<span data-ttu-id="350e1-835">Un miglioramento specifico di SQL Server per l'algoritmo che genera il livello di archivio (SSDL) del modello è disponibile in Entity Framework 5 e 6 e come aggiornamento di Entity Framework 4 quando è installato Visual Studio 2010 SP1.</span><span class="sxs-lookup"><span data-stu-id="350e1-835">A SQL Server-specific improvement to the algorithm that generates the store-layer (SSDL) of the model is available in Entity Framework 5 and 6, and as an update to Entity Framework 4 when Visual Studio 2010 SP1 is installed.</span></span> <span data-ttu-id="350e1-836">I seguenti risultati dei test dimostrano il miglioramento durante la generazione di un modello molto grande, in questo caso il modello Navision.</span><span class="sxs-lookup"><span data-stu-id="350e1-836">The following test results demonstrate the improvement when generating a very big model, in this case the Navision model.</span></span> <span data-ttu-id="350e1-837">Per ulteriori informazioni, vedere l'Appendice C.</span><span class="sxs-lookup"><span data-stu-id="350e1-837">See Appendix C for more details about it.</span></span>

<span data-ttu-id="350e1-838">Il modello contiene 1005 set di entità e 4227 set di associazioni.</span><span class="sxs-lookup"><span data-stu-id="350e1-838">The model contains 1005 entity sets and 4227 association sets.</span></span>

| <span data-ttu-id="350e1-839">Configurazione</span><span class="sxs-lookup"><span data-stu-id="350e1-839">Configuration</span></span>                              | <span data-ttu-id="350e1-840">Suddivisione del tempo consumato</span><span class="sxs-lookup"><span data-stu-id="350e1-840">Breakdown of time consumed</span></span>                                                                                                                                               |
|:-------------------------------------------|:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| <span data-ttu-id="350e1-841">Visual Studio 2010, Entity Framework 4</span><span class="sxs-lookup"><span data-stu-id="350e1-841">Visual Studio 2010, Entity Framework 4</span></span>     | <span data-ttu-id="350e1-842">Generazione SSDL: 2 ore 27 min</span><span class="sxs-lookup"><span data-stu-id="350e1-842">SSDL Generation: 2 hr 27 min</span></span> <br/> <span data-ttu-id="350e1-843">Generazione mappatura: 1 secondo</span><span class="sxs-lookup"><span data-stu-id="350e1-843">Mapping Generation: 1 second</span></span> <br/> <span data-ttu-id="350e1-844">Generazione CSDL: 1 secondo</span><span class="sxs-lookup"><span data-stu-id="350e1-844">CSDL Generation: 1 second</span></span> <br/> <span data-ttu-id="350e1-845">Generazione ObjectLayer: 1 secondo</span><span class="sxs-lookup"><span data-stu-id="350e1-845">ObjectLayer Generation: 1 second</span></span> <br/> <span data-ttu-id="350e1-846">Generazione vista: 2 h 14 min</span><span class="sxs-lookup"><span data-stu-id="350e1-846">View Generation: 2 h 14 min</span></span> |
| <span data-ttu-id="350e1-847">Visual Studio 2010 SP1, Entity Framework 4</span><span class="sxs-lookup"><span data-stu-id="350e1-847">Visual Studio 2010 SP1, Entity Framework 4</span></span> | <span data-ttu-id="350e1-848">Generazione SSDL: 1 secondo</span><span class="sxs-lookup"><span data-stu-id="350e1-848">SSDL Generation: 1 second</span></span> <br/> <span data-ttu-id="350e1-849">Generazione mappatura: 1 secondo</span><span class="sxs-lookup"><span data-stu-id="350e1-849">Mapping Generation: 1 second</span></span> <br/> <span data-ttu-id="350e1-850">Generazione CSDL: 1 secondo</span><span class="sxs-lookup"><span data-stu-id="350e1-850">CSDL Generation: 1 second</span></span> <br/> <span data-ttu-id="350e1-851">Generazione ObjectLayer: 1 secondo</span><span class="sxs-lookup"><span data-stu-id="350e1-851">ObjectLayer Generation: 1 second</span></span> <br/> <span data-ttu-id="350e1-852">Generazione vista: 1 ora 53 min</span><span class="sxs-lookup"><span data-stu-id="350e1-852">View Generation: 1 hr 53 min</span></span>   |
| <span data-ttu-id="350e1-853">Visual Studio 2013, Entity Framework 5</span><span class="sxs-lookup"><span data-stu-id="350e1-853">Visual Studio 2013, Entity Framework 5</span></span>     | <span data-ttu-id="350e1-854">Generazione SSDL: 1 secondo</span><span class="sxs-lookup"><span data-stu-id="350e1-854">SSDL Generation: 1 second</span></span> <br/> <span data-ttu-id="350e1-855">Generazione mappatura: 1 secondo</span><span class="sxs-lookup"><span data-stu-id="350e1-855">Mapping Generation: 1 second</span></span> <br/> <span data-ttu-id="350e1-856">Generazione CSDL: 1 secondo</span><span class="sxs-lookup"><span data-stu-id="350e1-856">CSDL Generation: 1 second</span></span> <br/> <span data-ttu-id="350e1-857">Generazione ObjectLayer: 1 secondo</span><span class="sxs-lookup"><span data-stu-id="350e1-857">ObjectLayer Generation: 1 second</span></span> <br/> <span data-ttu-id="350e1-858">Generazione vista: 65 minuti</span><span class="sxs-lookup"><span data-stu-id="350e1-858">View Generation: 65 minutes</span></span>    |
| <span data-ttu-id="350e1-859">Visual Studio 2013, Entity Framework 6</span><span class="sxs-lookup"><span data-stu-id="350e1-859">Visual Studio 2013, Entity Framework 6</span></span>     | <span data-ttu-id="350e1-860">Generazione SSDL: 1 secondo</span><span class="sxs-lookup"><span data-stu-id="350e1-860">SSDL Generation: 1 second</span></span> <br/> <span data-ttu-id="350e1-861">Generazione mappatura: 1 secondo</span><span class="sxs-lookup"><span data-stu-id="350e1-861">Mapping Generation: 1 second</span></span> <br/> <span data-ttu-id="350e1-862">Generazione CSDL: 1 secondo</span><span class="sxs-lookup"><span data-stu-id="350e1-862">CSDL Generation: 1 second</span></span> <br/> <span data-ttu-id="350e1-863">Generazione ObjectLayer: 1 secondo</span><span class="sxs-lookup"><span data-stu-id="350e1-863">ObjectLayer Generation: 1 second</span></span> <br/> <span data-ttu-id="350e1-864">Generazione vista: 28 secondi.</span><span class="sxs-lookup"><span data-stu-id="350e1-864">View Generation: 28 seconds.</span></span>   |


<span data-ttu-id="350e1-865">Vale la pena notare che durante la generazione di SSDL, il carico viene quasi interamente speso su SQL Server, mentre il computer di sviluppo client è in attesa di inattività per i risultati a tornare dal server.</span><span class="sxs-lookup"><span data-stu-id="350e1-865">It's worth noting that when generating the SSDL, the load is almost entirely spent on the SQL Server, while the client development machine is waiting idle for results to come back from the server.</span></span> <span data-ttu-id="350e1-866">Gli amministratori di database dovrebbero apprezzare in modo particolare questo miglioramento.</span><span class="sxs-lookup"><span data-stu-id="350e1-866">DBAs should particularly appreciate this improvement.</span></span> <span data-ttu-id="350e1-867">Vale anche la pena notare che essenzialmente l'intero costo della generazione del modello avviene ora in Generazione vista.</span><span class="sxs-lookup"><span data-stu-id="350e1-867">It's also worth noting that essentially the entire cost of model generation takes place in View Generation now.</span></span>

### <a name="73-splitting-large-models-with-database-first-and-model-first"></a><span data-ttu-id="350e1-868">7.3 Suddivisione di modelli di grandi dimensioni con Database First e Model First</span><span class="sxs-lookup"><span data-stu-id="350e1-868">7.3       Splitting Large Models with Database First and Model First</span></span>

<span data-ttu-id="350e1-869">Con l'aumentare delle dimensioni del modello, l'area di progettazione diventa ingombra e difficile da usare.</span><span class="sxs-lookup"><span data-stu-id="350e1-869">As model size increases, the designer surface becomes cluttered and difficult to use.</span></span> <span data-ttu-id="350e1-870">In genere si considera un modello con più di 300 entità troppo grande per poter usare in modo efficace la finestra di progettazione.</span><span class="sxs-lookup"><span data-stu-id="350e1-870">We typically consider a model with more than 300 entities to be too large to effectively use the designer.</span></span> <span data-ttu-id="350e1-871">Nel post di blog seguente vengono descritte \< https://docs.microsoft.com/archive/blogs/adonet/working-with-large-models-in-entity-framework-part-2>diverse opzioni per la suddivisione di modelli di grandi dimensioni: .</span><span class="sxs-lookup"><span data-stu-id="350e1-871">The following blog post describes several options for splitting large models: \<https://docs.microsoft.com/archive/blogs/adonet/working-with-large-models-in-entity-framework-part-2>.</span></span>

<span data-ttu-id="350e1-872">Il post è stato scritto per la prima versione di Entity Framework, ma i passaggi sono ancora validi.</span><span class="sxs-lookup"><span data-stu-id="350e1-872">The post was written for the first version of Entity Framework, but the steps still apply.</span></span>

### <a name="74-performance-considerations-with-the-entity-data-source-control"></a><span data-ttu-id="350e1-873">7.4 Considerazioni sulle prestazioni con il controllo origine dati entità</span><span class="sxs-lookup"><span data-stu-id="350e1-873">7.4       Performance considerations with the Entity Data Source Control</span></span>

<span data-ttu-id="350e1-874">Sono stati riscontrati casi in test di prestazioni e stress multithreading in cui le prestazioni di un'applicazione Web che utilizza il controllo EntityDataSource si deteriorano in modo significativo.</span><span class="sxs-lookup"><span data-stu-id="350e1-874">We've seen cases in multi-threaded performance and stress tests where the performance of a web application using the EntityDataSource Control deteriorates significantly.</span></span> <span data-ttu-id="350e1-875">La causa sottostante è che EntityDataSource chiama ripetutamente MetadataWorkspace.LoadFromAssembly sugli assembly a cui fa riferimento l'applicazione Web per individuare i tipi da utilizzare come entità.</span><span class="sxs-lookup"><span data-stu-id="350e1-875">The underlying cause is that the EntityDataSource repeatedly calls MetadataWorkspace.LoadFromAssembly on the assemblies referenced by the Web application to discover the types to be used as entities.</span></span>

<span data-ttu-id="350e1-876">La soluzione consiste nell'impostare il ContextTypeName di EntityDataSource sul nome del tipo della classe ObjectContext derivata.</span><span class="sxs-lookup"><span data-stu-id="350e1-876">The solution is to set the ContextTypeName of the EntityDataSource to the type name of your derived ObjectContext class.</span></span> <span data-ttu-id="350e1-877">In questo modo viene disattivato il meccanismo che analizza tutti gli assembly a cui si fa riferimento per i tipi di entità.</span><span class="sxs-lookup"><span data-stu-id="350e1-877">This turns off the mechanism that scans all referenced assemblies for entity types.</span></span>

<span data-ttu-id="350e1-878">L'impostazione del campo ContextTypeName impedisce inoltre un problema funzionale in cui EntityDataSource in .NET 4.0 genera un'eccezione ReflectionTypeLoadException quando non è possibile caricare un tipo da un assembly tramite reflection.</span><span class="sxs-lookup"><span data-stu-id="350e1-878">Setting the ContextTypeName field also prevents a functional problem where the EntityDataSource in .NET 4.0 throws a ReflectionTypeLoadException when it can't load a type from an assembly via reflection.</span></span> <span data-ttu-id="350e1-879">Questo problema è stato risolto in .NET 4.5.</span><span class="sxs-lookup"><span data-stu-id="350e1-879">This issue has been fixed in .NET 4.5.</span></span>

### <a name="75-poco-entities-and-change-tracking-proxies"></a><span data-ttu-id="350e1-880">7.5 Entità POCO e proxy di rilevamento delle modifiche</span><span class="sxs-lookup"><span data-stu-id="350e1-880">7.5       POCO entities and change tracking proxies</span></span>

<span data-ttu-id="350e1-881">Entity Framework consente di utilizzare classi di dati personalizzate con il modello di dati senza apportare modifiche alle classi di dati stesse.</span><span class="sxs-lookup"><span data-stu-id="350e1-881">Entity Framework enables you to use custom data classes together with your data model without making any modifications to the data classes themselves.</span></span> <span data-ttu-id="350e1-882">Pertanto è possibile pertanto utilizzare oggetti POCO (Plain-Old CLR Object), ad esempio gli oggetti di dominio esistenti, con il modello di dati.</span><span class="sxs-lookup"><span data-stu-id="350e1-882">This means that you can use "plain-old" CLR objects (POCO), such as existing domain objects, with your data model.</span></span> <span data-ttu-id="350e1-883">Queste classi di dati POCO (note anche come oggetti ignora di persistenza), mappate a entità definite in un modello di dati, supportano la maggior parte delle stesse query, inserimento, aggiornamento ed eliminazione dei comportamenti generati dagli strumenti Entity Data Model.</span><span class="sxs-lookup"><span data-stu-id="350e1-883">These POCO data classes (also known as persistence-ignorant objects), which are mapped to entities that are defined in a data model, support most of the same query, insert, update, and delete behaviors as entity types that are generated by the Entity Data Model tools.</span></span>

<span data-ttu-id="350e1-884">Entity Framework può anche creare classi proxy derivate dai tipi POCO, che vengono utilizzate quando si desidera abilitare funzionalità quali il caricamento lazy e il rilevamento automatico delle modifiche nelle entità POCO.</span><span class="sxs-lookup"><span data-stu-id="350e1-884">Entity Framework can also create proxy classes derived from your POCO types, which are used when you want to enable features such as lazy loading and automatic change tracking on POCO entities.</span></span> <span data-ttu-id="350e1-885">Le classi POCO devono soddisfare determinati requisiti per consentire a Entity [http://msdn.microsoft.com/library/dd468057.aspx](https://msdn.microsoft.com/library/dd468057.aspx)Framework di utilizzare i proxy, come descritto di seguito: .</span><span class="sxs-lookup"><span data-stu-id="350e1-885">Your POCO classes must meet certain requirements to allow Entity Framework to use proxies, as described here: [http://msdn.microsoft.com/library/dd468057.aspx](https://msdn.microsoft.com/library/dd468057.aspx).</span></span>

<span data-ttu-id="350e1-886">I proxy di rilevamento delle probabilità invieranno una notifica al gestore dello stato degli oggetti ogni volta che il valore di una delle proprietà delle entità viene modificato, pertanto Entity Framework conosce sempre lo stato effettivo delle entità.</span><span class="sxs-lookup"><span data-stu-id="350e1-886">Chance tracking proxies will notify the object state manager each time any of the properties of your entities has its value changed, so Entity Framework knows the actual state of your entities all the time.</span></span> <span data-ttu-id="350e1-887">Questa operazione viene eseguita aggiungendo eventi di notifica al corpo dei metodi setter delle proprietà e facendo in modo che il gestore dello stato degli oggetti eserisse tali eventi.</span><span class="sxs-lookup"><span data-stu-id="350e1-887">This is done by adding notification events to the body of the setter methods of your properties, and having the object state manager processing such events.</span></span> <span data-ttu-id="350e1-888">Si noti che la creazione di un'entità proxy sarà in genere più costosa rispetto alla creazione di un'entità POCO non proxy a causa dell'aggiunta del set di eventi creato da Entity Framework.</span><span class="sxs-lookup"><span data-stu-id="350e1-888">Note that creating a proxy entity will typically be more expensive than creating a non-proxy POCO entity due to the added set of events created by Entity Framework.</span></span>

<span data-ttu-id="350e1-889">Quando un'entità POCO non dispone di un proxy di rilevamento delle modifiche, le modifiche vengono rilevate confrontando il contenuto delle entità con una copia di uno stato salvato precedente.</span><span class="sxs-lookup"><span data-stu-id="350e1-889">When a POCO entity does not have a change tracking proxy, changes are found by comparing the contents of your entities against a copy of a previous saved state.</span></span> <span data-ttu-id="350e1-890">Questo confronto completo diventerà un processo lungo quando si dispone di molte entità nel contesto o quando le entità hanno una grande quantità di proprietà, anche se nessuna di esse è stata modificata dall'ultimo confronto.</span><span class="sxs-lookup"><span data-stu-id="350e1-890">This deep comparison will become a lengthy process when you have many entities in your context, or when your entities have a very large amount of properties, even if none of them changed since the last comparison took place.</span></span>

<span data-ttu-id="350e1-891">In sintesi: al momento della creazione del proxy di rilevamento delle modifiche pagherai un calo delle prestazioni, ma il rilevamento delle modifiche ti aiuterà ad accelerare il processo di rilevamento delle modifiche quando le entità hanno molte proprietà o quando hai molte entità nel modello.</span><span class="sxs-lookup"><span data-stu-id="350e1-891">In summary: you’ll pay a performance hit when creating the change tracking proxy, but change tracking will help you speed up the change detection process when your entities have many properties or when you have many entities in your model.</span></span> <span data-ttu-id="350e1-892">Per le entità con un numero ridotto di proprietà in cui la quantità di entità non aumenta troppo, la presenza di proxy di rilevamento delle modifiche potrebbe non essere molto vantaggiosa.</span><span class="sxs-lookup"><span data-stu-id="350e1-892">For entities with a small number of properties where the amount of entities doesn’t grow too much, having change tracking proxies may not be of much benefit.</span></span>

## <a name="8-loading-related-entities"></a><span data-ttu-id="350e1-893">8 Caricamento di entità correlate</span><span class="sxs-lookup"><span data-stu-id="350e1-893">8 Loading Related Entities</span></span>

### <a name="81-lazy-loading-vs-eager-loading"></a><span data-ttu-id="350e1-894">8.1 Caricamento lazy e caricamento eager</span><span class="sxs-lookup"><span data-stu-id="350e1-894">8.1 Lazy Loading vs. Eager Loading</span></span>

<span data-ttu-id="350e1-895">Entity Framework offre diversi modi per caricare le entità correlate all'entità di destinazione.</span><span class="sxs-lookup"><span data-stu-id="350e1-895">Entity Framework offers several different ways to load the entities that are related to your target entity.</span></span> <span data-ttu-id="350e1-896">Ad esempio, quando si esegue una query per prodotti, esistono diversi modi in cui gli ordini correlati verranno caricati in Gestione stato oggetti.</span><span class="sxs-lookup"><span data-stu-id="350e1-896">For example, when you query for Products, there are different ways that the related Orders will be loaded into the Object State Manager.</span></span> <span data-ttu-id="350e1-897">Dal punto di vista delle prestazioni, la domanda più importante da considerare quando si caricano entità correlate sarà se usare Il caricamento lazy o il caricamento eager.</span><span class="sxs-lookup"><span data-stu-id="350e1-897">From a performance standpoint, the biggest question to consider when loading related entities will be whether to use Lazy Loading or Eager Loading.</span></span>

<span data-ttu-id="350e1-898">Quando si usa Caricamento eager, le entità correlate vengono caricate insieme al set di entità di destinazione.</span><span class="sxs-lookup"><span data-stu-id="350e1-898">When using Eager Loading, the related entities are loaded along with your target entity set.</span></span> <span data-ttu-id="350e1-899">Utilizzare un'istruzione Include nella query per indicare quali entità correlate si desidera importare.</span><span class="sxs-lookup"><span data-stu-id="350e1-899">You use an Include statement in your query to indicate which related entities you want to bring in.</span></span>

<span data-ttu-id="350e1-900">Quando si usa Il caricamento lazy, la query iniziale include solo il set di entità di destinazione.</span><span class="sxs-lookup"><span data-stu-id="350e1-900">When using Lazy Loading, your initial query only brings in the target entity set.</span></span> <span data-ttu-id="350e1-901">Ma ogni volta che si accede a una proprietà di navigazione, viene eseguita un'altra query sull'archivio per caricare l'entità correlata.</span><span class="sxs-lookup"><span data-stu-id="350e1-901">But whenever you access a navigation property, another query is issued against the store to load the related entity.</span></span>

<span data-ttu-id="350e1-902">Una volta caricata un'entità, tutte le ulteriori query per l'entità la caricheranno direttamente da Gestione stato oggetti, sia che si utilizzi il caricamento lazy o il caricamento eager.</span><span class="sxs-lookup"><span data-stu-id="350e1-902">Once an entity has been loaded, any further queries for the entity will load it directly from the Object State Manager, whether you are using lazy loading or eager loading.</span></span>

### <a name="82-how-to-choose-between-lazy-loading-and-eager-loading"></a><span data-ttu-id="350e1-903">8.2 Come scegliere tra Caricamento lazy e Caricamento Eager</span><span class="sxs-lookup"><span data-stu-id="350e1-903">8.2 How to choose between Lazy Loading and Eager Loading</span></span>

<span data-ttu-id="350e1-904">L'importante è comprendere la differenza tra Caricamento lazy e Caricamento eager in modo da poter fare la scelta corretta per l'applicazione.</span><span class="sxs-lookup"><span data-stu-id="350e1-904">The important thing is that you understand the difference between Lazy Loading and Eager Loading so that you can make the correct choice for your application.</span></span> <span data-ttu-id="350e1-905">In questo modo sarà possibile valutare il compromesso tra più richieste rispetto al database rispetto a una singola richiesta che può contenere un payload di grandi dimensioni.</span><span class="sxs-lookup"><span data-stu-id="350e1-905">This will help you evaluate the tradeoff between multiple requests against the database versus a single request that may contain a large payload.</span></span> <span data-ttu-id="350e1-906">Potrebbe essere appropriato usare il caricamento eager in alcune parti dell'applicazione e il caricamento lazy in altre parti.</span><span class="sxs-lookup"><span data-stu-id="350e1-906">It may be appropriate to use eager loading in some parts of your application and lazy loading in other parts.</span></span>

<span data-ttu-id="350e1-907">Come esempio di ciò che sta accadendo sotto il cofano, supponiamo di voler interrogare per i clienti che vivono nel Regno Unito e il loro conteggio degli ordini.</span><span class="sxs-lookup"><span data-stu-id="350e1-907">As an example of what's happening under the hood, suppose you want to query for the customers who live in the UK and their order count.</span></span>

<span data-ttu-id="350e1-908">**Utilizzo del caricamento eagerUsing Eager Loading**</span><span class="sxs-lookup"><span data-stu-id="350e1-908">**Using Eager Loading**</span></span>

``` csharp
using (NorthwindEntities context = new NorthwindEntities())
{
    var ukCustomers = context.Customers.Include(c => c.Orders).Where(c => c.Address.Country == "UK");
    var chosenCustomer = AskUserToPickCustomer(ukCustomers);
    Console.WriteLine("Customer Id: {0} has {1} orders", customer.CustomerID, customer.Orders.Count);
}
```

<span data-ttu-id="350e1-909">**Utilizzo del caricamento lazyUsing Lazy Loading**</span><span class="sxs-lookup"><span data-stu-id="350e1-909">**Using Lazy Loading**</span></span>

``` csharp
using (NorthwindEntities context = new NorthwindEntities())
{
    context.ContextOptions.LazyLoadingEnabled = true;

    //Notice that the Include method call is missing in the query
    var ukCustomers = context.Customers.Where(c => c.Address.Country == "UK");

    var chosenCustomer = AskUserToPickCustomer(ukCustomers);
    Console.WriteLine("Customer Id: {0} has {1} orders", customer.CustomerID, customer.Orders.Count);
}
```

<span data-ttu-id="350e1-910">Quando si utilizza il caricamento eager, si eseguirà una singola query che restituisce tutti i clienti e tutti gli ordini.</span><span class="sxs-lookup"><span data-stu-id="350e1-910">When using eager loading, you'll issue a single query that returns all customers and all orders.</span></span> <span data-ttu-id="350e1-911">Il comando store ha il seguente aspetto:</span><span class="sxs-lookup"><span data-stu-id="350e1-911">The store command looks like:</span></span>

``` SQL
SELECT
[Project1].[C1] AS [C1],
[Project1].[CustomerID] AS [CustomerID],
[Project1].[CompanyName] AS [CompanyName],
[Project1].[ContactName] AS [ContactName],
[Project1].[ContactTitle] AS [ContactTitle],
[Project1].[Address] AS [Address],
[Project1].[City] AS [City],
[Project1].[Region] AS [Region],
[Project1].[PostalCode] AS [PostalCode],
[Project1].[Country] AS [Country],
[Project1].[Phone] AS [Phone],
[Project1].[Fax] AS [Fax],
[Project1].[C2] AS [C2],
[Project1].[OrderID] AS [OrderID],
[Project1].[CustomerID1] AS [CustomerID1],
[Project1].[EmployeeID] AS [EmployeeID],
[Project1].[OrderDate] AS [OrderDate],
[Project1].[RequiredDate] AS [RequiredDate],
[Project1].[ShippedDate] AS [ShippedDate],
[Project1].[ShipVia] AS [ShipVia],
[Project1].[Freight] AS [Freight],
[Project1].[ShipName] AS [ShipName],
[Project1].[ShipAddress] AS [ShipAddress],
[Project1].[ShipCity] AS [ShipCity],
[Project1].[ShipRegion] AS [ShipRegion],
[Project1].[ShipPostalCode] AS [ShipPostalCode],
[Project1].[ShipCountry] AS [ShipCountry]
FROM ( SELECT
      [Extent1].[CustomerID] AS [CustomerID],
       [Extent1].[CompanyName] AS [CompanyName],
       [Extent1].[ContactName] AS [ContactName],
       [Extent1].[ContactTitle] AS [ContactTitle],
       [Extent1].[Address] AS [Address],
       [Extent1].[City] AS [City],
       [Extent1].[Region] AS [Region],
       [Extent1].[PostalCode] AS [PostalCode],
       [Extent1].[Country] AS [Country],
       [Extent1].[Phone] AS [Phone],
       [Extent1].[Fax] AS [Fax],
      1 AS [C1],
       [Extent2].[OrderID] AS [OrderID],
       [Extent2].[CustomerID] AS [CustomerID1],
       [Extent2].[EmployeeID] AS [EmployeeID],
       [Extent2].[OrderDate] AS [OrderDate],
       [Extent2].[RequiredDate] AS [RequiredDate],
       [Extent2].[ShippedDate] AS [ShippedDate],
       [Extent2].[ShipVia] AS [ShipVia],
       [Extent2].[Freight] AS [Freight],
       [Extent2].[ShipName] AS [ShipName],
       [Extent2].[ShipAddress] AS [ShipAddress],
       [Extent2].[ShipCity] AS [ShipCity],
       [Extent2].[ShipRegion] AS [ShipRegion],
       [Extent2].[ShipPostalCode] AS [ShipPostalCode],
       [Extent2].[ShipCountry] AS [ShipCountry],
      CASE WHEN ([Extent2].[OrderID] IS NULL) THEN CAST(NULL AS int) ELSE 1 END AS [C2]
      FROM  [dbo].[Customers] AS [Extent1]
      LEFT OUTER JOIN [dbo].[Orders] AS [Extent2] ON [Extent1].[CustomerID] = [Extent2].[CustomerID]
      WHERE N'UK' = [Extent1].[Country]
)  AS [Project1]
ORDER BY [Project1].[CustomerID] ASC, [Project1].[C2] ASC
```

<span data-ttu-id="350e1-912">Quando si utilizza il caricamento lazy, si eseguirà inizialmente la query seguente:</span><span class="sxs-lookup"><span data-stu-id="350e1-912">When using lazy loading, you'll issue the following query initially:</span></span>

``` SQL
SELECT
[Extent1].[CustomerID] AS [CustomerID],
[Extent1].[CompanyName] AS [CompanyName],
[Extent1].[ContactName] AS [ContactName],
[Extent1].[ContactTitle] AS [ContactTitle],
[Extent1].[Address] AS [Address],
[Extent1].[City] AS [City],
[Extent1].[Region] AS [Region],
[Extent1].[PostalCode] AS [PostalCode],
[Extent1].[Country] AS [Country],
[Extent1].[Phone] AS [Phone],
[Extent1].[Fax] AS [Fax]
FROM [dbo].[Customers] AS [Extent1]
WHERE N'UK' = [Extent1].[Country]
```

<span data-ttu-id="350e1-913">E ogni volta che si accede alla proprietà di navigazione Orders di un cliente viene eseguita un'altra query simile alla seguente sul negozio:</span><span class="sxs-lookup"><span data-stu-id="350e1-913">And each time you access the Orders navigation property of a customer another query like the following is issued against the store:</span></span>

``` SQL
exec sp_executesql N'SELECT
[Extent1].[OrderID] AS [OrderID],
[Extent1].[CustomerID] AS [CustomerID],
[Extent1].[EmployeeID] AS [EmployeeID],
[Extent1].[OrderDate] AS [OrderDate],
[Extent1].[RequiredDate] AS [RequiredDate],
[Extent1].[ShippedDate] AS [ShippedDate],
[Extent1].[ShipVia] AS [ShipVia],
[Extent1].[Freight] AS [Freight],
[Extent1].[ShipName] AS [ShipName],
[Extent1].[ShipAddress] AS [ShipAddress],
[Extent1].[ShipCity] AS [ShipCity],
[Extent1].[ShipRegion] AS [ShipRegion],
[Extent1].[ShipPostalCode] AS [ShipPostalCode],
[Extent1].[ShipCountry] AS [ShipCountry]
FROM [dbo].[Orders] AS [Extent1]
WHERE [Extent1].[CustomerID] = @EntityKeyValue1',N'@EntityKeyValue1 nchar(5)',@EntityKeyValue1=N'AROUT'
```

<span data-ttu-id="350e1-914">Per ulteriori informazioni, vedere [Caricamento di oggetti correlati](https://msdn.microsoft.com/library/bb896272.aspx).</span><span class="sxs-lookup"><span data-stu-id="350e1-914">For more information, see the [Loading Related Objects](https://msdn.microsoft.com/library/bb896272.aspx).</span></span>

#### <a name="821-lazy-loading-versus-eager-loading-cheat-sheet"></a><span data-ttu-id="350e1-915">8.2.1 Caricamento pigro contro foglio trucco caricamento Eager</span><span class="sxs-lookup"><span data-stu-id="350e1-915">8.2.1 Lazy Loading versus Eager Loading cheat sheet</span></span>

<span data-ttu-id="350e1-916">Non esiste una cosa adatta a tutti a scegliere il caricamento eager rispetto al caricamento pigro.</span><span class="sxs-lookup"><span data-stu-id="350e1-916">There’s no such thing as a one-size-fits-all to choosing eager loading versus lazy loading.</span></span> <span data-ttu-id="350e1-917">Cercate prima di tutto di capire le differenze tra entrambe le strategie in modo da poter fare una decisione ben informata; Inoltre, considerare se il codice si adatta a uno dei seguenti scenari:</span><span class="sxs-lookup"><span data-stu-id="350e1-917">Try first to understand the differences between both strategies so you can do a well informed decision; also, consider if your code fits to any of the following scenarios:</span></span>

| <span data-ttu-id="350e1-918">Scenario</span><span class="sxs-lookup"><span data-stu-id="350e1-918">Scenario</span></span>                                                                    | <span data-ttu-id="350e1-919">Il nostro suggerimento</span><span class="sxs-lookup"><span data-stu-id="350e1-919">Our Suggestion</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
|:----------------------------------------------------------------------------|:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| <span data-ttu-id="350e1-920">È necessario accedere a molte proprietà di navigazione dalle entità recuperate?</span><span class="sxs-lookup"><span data-stu-id="350e1-920">Do you need to access many navigation properties from the fetched entities?</span></span> | <span data-ttu-id="350e1-921">**No** - Probabilmente funzioneranno entrambe le opzioni.</span><span class="sxs-lookup"><span data-stu-id="350e1-921">**No** - Both options will probably do.</span></span> <span data-ttu-id="350e1-922">Tuttavia, se il payload che la query sta portando non è troppo grande, è possibile che si verifichino vantaggi in termini di prestazioni utilizzando il caricamento eager in quanto richiederà meno round trip di rete per materializzare gli oggetti.</span><span class="sxs-lookup"><span data-stu-id="350e1-922">However, if the payload your query is bringing is not too big, you may experience performance benefits by using Eager loading as it’ll require less network round trips to materialize your objects.</span></span> <br/> <br/> <span data-ttu-id="350e1-923">**Sì:** se è necessario accedere a molte proprietà di navigazione dalle entità, è possibile farlo usando più istruzioni di inclusione nella query con caricamento eager.</span><span class="sxs-lookup"><span data-stu-id="350e1-923">**Yes** -  If you need to access many navigation properties from the entities, you’d do that by using multiple include statements in your query with Eager loading.</span></span> <span data-ttu-id="350e1-924">Più entità includi, maggiore è il payload restituito dalla query.</span><span class="sxs-lookup"><span data-stu-id="350e1-924">The more entities you include, the bigger the payload your query will return.</span></span> <span data-ttu-id="350e1-925">Dopo aver incluso tre o più entità nella query, è consigliabile passare al caricamento lazy.</span><span class="sxs-lookup"><span data-stu-id="350e1-925">Once you include three or more entities into your query, consider switching to Lazy loading.</span></span> |
| <span data-ttu-id="350e1-926">Sai esattamente quali dati saranno necessari in fase di esecuzione?</span><span class="sxs-lookup"><span data-stu-id="350e1-926">Do you know exactly what data will be needed at run time?</span></span>                   | <span data-ttu-id="350e1-927">**No** - Il caricamento pigro sarà meglio per te.</span><span class="sxs-lookup"><span data-stu-id="350e1-927">**No** - Lazy loading will be better for you.</span></span> <span data-ttu-id="350e1-928">In caso contrario, potresti finire per eseguire query per i dati che non ti serviranno.</span><span class="sxs-lookup"><span data-stu-id="350e1-928">Otherwise, you may end up querying for data that you will not need.</span></span> <br/> <br/> <span data-ttu-id="350e1-929">**Sì** - Il caricamento eager è probabilmente la soluzione migliore; aiuterà a caricare interi set più velocemente.</span><span class="sxs-lookup"><span data-stu-id="350e1-929">**Yes** - Eager loading is probably your best bet; it will help loading entire sets faster.</span></span> <span data-ttu-id="350e1-930">Se la query richiede il recupero di una grande quantità di dati e questo diventa troppo lento, provare invece a caricare lazy.</span><span class="sxs-lookup"><span data-stu-id="350e1-930">If your query requires fetching a very large amount of data, and this becomes too slow, then try Lazy loading instead.</span></span>                                                                                                                                                                                                                                                       |
| <span data-ttu-id="350e1-931">Il codice è in esecuzione lontano dal database?</span><span class="sxs-lookup"><span data-stu-id="350e1-931">Is your code executing far from your database?</span></span> <span data-ttu-id="350e1-932">(aumento della latenza di rete)</span><span class="sxs-lookup"><span data-stu-id="350e1-932">(increased network latency)</span></span>  | <span data-ttu-id="350e1-933">**No:** quando la latenza di rete non è un problema, l'uso del caricamento differito può semplificare il codice.</span><span class="sxs-lookup"><span data-stu-id="350e1-933">**No** - When the network latency is not an issue, using Lazy loading may simplify your code.</span></span> <span data-ttu-id="350e1-934">Tenere presente che la topologia dell'applicazione può cambiare, pertanto non dare per scontata la prossimità del database.</span><span class="sxs-lookup"><span data-stu-id="350e1-934">Remember that the topology of your application may change, so don’t take database proximity for granted.</span></span> <br/> <br/> <span data-ttu-id="350e1-935">**Sì** - Quando la rete è un problema, solo tu puoi decidere cosa si adatta meglio al tuo scenario.</span><span class="sxs-lookup"><span data-stu-id="350e1-935">**Yes** - When the network is a problem, only you can decide what fits better for your scenario.</span></span> <span data-ttu-id="350e1-936">In genere il caricamento eager sarà migliore perché richiede meno round trip.</span><span class="sxs-lookup"><span data-stu-id="350e1-936">Typically Eager loading will be better because it requires fewer round trips.</span></span>                                                                                                                                                                                                      |


#### <a name="822-performance-concerns-with-multiple-includes"></a><span data-ttu-id="350e1-937">8.2.2 Problemi di prestazioni con più inclusioni</span><span class="sxs-lookup"><span data-stu-id="350e1-937">8.2.2       Performance concerns with multiple Includes</span></span>

<span data-ttu-id="350e1-938">Quando si sentono domande di prestazioni che coinvolgono problemi di tempo di risposta del server, l'origine del problema è spesso query con più istruzione Include.</span><span class="sxs-lookup"><span data-stu-id="350e1-938">When we hear performance questions that involve server response time problems, the source of the issue is frequently queries with multiple Include statements.</span></span> <span data-ttu-id="350e1-939">Anche se l'inclusione di entità correlate in una query è potente, è importante comprendere cosa sta succedendo sotto le coperte.</span><span class="sxs-lookup"><span data-stu-id="350e1-939">While including related entities in a query is powerful, it's important to understand what's happening under the covers.</span></span>

<span data-ttu-id="350e1-940">Richiede un tempo relativamente lungo per una query con più Include istruzioni in esso per passare attraverso il compilatore piano interno per produrre il comando di archivio.</span><span class="sxs-lookup"><span data-stu-id="350e1-940">It takes a relatively long time for a query with multiple Include statements in it to go through our internal plan compiler to produce the store command.</span></span> <span data-ttu-id="350e1-941">La maggior parte di questo tempo viene impiegato cercando di ottimizzare la query risultante.</span><span class="sxs-lookup"><span data-stu-id="350e1-941">The majority of this time is spent trying to optimize the resulting query.</span></span> <span data-ttu-id="350e1-942">Il comando di archivio generato conterrà un Outer Join o un'unione per ogni include, a seconda del mapping.</span><span class="sxs-lookup"><span data-stu-id="350e1-942">The generated store command will contain an Outer Join or Union for each Include, depending on your mapping.</span></span> <span data-ttu-id="350e1-943">Query come questa porteranno in grandi grafici connessi dal database in un singolo payload, che si acerbate eventuali problemi di larghezza di banda, soprattutto quando c'è un sacco di ridondanza nel payload (ad esempio, quando più livelli di Include vengono utilizzati per attraversare le associazioni nella direzione uno-a-molti).</span><span class="sxs-lookup"><span data-stu-id="350e1-943">Queries like this will bring in large connected graphs from your database in a single payload, which will acerbate any bandwidth issues, especially when there is a lot of redundancy in the payload (for example, when multiple levels of Include are used to traverse associations in the one-to-many direction).</span></span>

<span data-ttu-id="350e1-944">È possibile verificare la presenza di casi in cui le query restituiscono payload eccessivamente grandi accedendo al TSQL sottostante per la query utilizzando ToTraceString ed eseguendo il comando store in SQL Server Management StudioSQL Server Management Studio per visualizzare le dimensioni del payload.</span><span class="sxs-lookup"><span data-stu-id="350e1-944">You can check for cases where your queries are returning excessively large payloads by accessing the underlying TSQL for the query by using ToTraceString and executing the store command in SQL Server Management Studio to see the payload size.</span></span> <span data-ttu-id="350e1-945">In questi casi è possibile provare a ridurre il numero di istruzioni Include nella query per inserire solo i dati necessari.</span><span class="sxs-lookup"><span data-stu-id="350e1-945">In such cases you can try to reduce the number of Include statements in your query to just bring in the data you need.</span></span> <span data-ttu-id="350e1-946">In alternativa, è possibile suddividere la query in una sequenza più piccola di sottoquery, ad esempio:</span><span class="sxs-lookup"><span data-stu-id="350e1-946">Or you may be able to break your query into a smaller sequence of subqueries, for example:</span></span>

<span data-ttu-id="350e1-947">**Prima di interrompere la query:**</span><span class="sxs-lookup"><span data-stu-id="350e1-947">**Before breaking the query:**</span></span>

``` csharp
using (NorthwindEntities context = new NorthwindEntities())
{
    var customers = from c in context.Customers.Include(c => c.Orders)
                    where c.LastName.StartsWith(lastNameParameter)
                    select c;

    foreach (Customer customer in customers)
    {
        ...
    }
}
```

<span data-ttu-id="350e1-948">**Dopo aver violato la query:**</span><span class="sxs-lookup"><span data-stu-id="350e1-948">**After breaking the query:**</span></span>

``` csharp
using (NorthwindEntities context = new NorthwindEntities())
{
    var orders = from o in context.Orders
                 where o.Customer.LastName.StartsWith(lastNameParameter)
                 select o;

    orders.Load();

    var customers = from c in context.Customers
                    where c.LastName.StartsWith(lastNameParameter)
                    select c;

    foreach (Customer customer in customers)
    {
        ...
    }
}
```

<span data-ttu-id="350e1-949">Questo funzionerà solo sulle query monitorate, come stiamo facendo uso della capacità del contesto ha di eseguire la risoluzione dell'identità e la correzione di associazione automaticamente.</span><span class="sxs-lookup"><span data-stu-id="350e1-949">This will work only on tracked queries, as we are making use of the ability the context has to perform identity resolution and association fixup automatically.</span></span>

<span data-ttu-id="350e1-950">Come per il caricamento lazy, il compromesso sarà più query per payload più piccoli.</span><span class="sxs-lookup"><span data-stu-id="350e1-950">As with lazy loading, the tradeoff will be more queries for smaller payloads.</span></span> <span data-ttu-id="350e1-951">È anche possibile usare proiezioni di singole proprietà per selezionare in modo esplicito solo i dati necessari da ogni entità, ma in questo caso non verranno caricate entità e gli aggiornamenti non saranno supportati.</span><span class="sxs-lookup"><span data-stu-id="350e1-951">You can also use projections of individual properties to explicitly select only the data you need from each entity, but you will not be loading entities in this case, and updates will not be supported.</span></span>

#### <a name="823-workaround-to-get-lazy-loading-of-properties"></a><span data-ttu-id="350e1-952">8.2.3 Soluzione alternativa per ottenere il caricamento lazy delle proprietà</span><span class="sxs-lookup"><span data-stu-id="350e1-952">8.2.3 Workaround to get lazy loading of properties</span></span>

<span data-ttu-id="350e1-953">Entity Framework attualmente non supporta il caricamento lazy di proprietà scalari o complesse.</span><span class="sxs-lookup"><span data-stu-id="350e1-953">Entity Framework currently doesn’t support lazy loading of scalar or complex properties.</span></span> <span data-ttu-id="350e1-954">Tuttavia, nei casi in cui si dispone di una tabella che include un oggetto di grandi dimensioni, ad esempio un BLOB, è possibile utilizzare la suddivisione delle tabelle per separare le proprietà di grandi dimensioni in un'entità separata.</span><span class="sxs-lookup"><span data-stu-id="350e1-954">However, in cases where you have a table that includes a large object such as a BLOB, you can use table splitting to separate the large properties into a separate entity.</span></span> <span data-ttu-id="350e1-955">Si supponga, ad esempio, di disporre di una tabella Product che include una colonna di foto varbinary.</span><span class="sxs-lookup"><span data-stu-id="350e1-955">For example, suppose you have a Product table that includes a varbinary photo column.</span></span> <span data-ttu-id="350e1-956">Se non è spesso necessario accedere a questa proprietà nelle query, è possibile usare la suddivisione delle tabelle per importare solo le parti dell'entità normalmente necessarie.</span><span class="sxs-lookup"><span data-stu-id="350e1-956">If you don't frequently need to access this property in your queries, you can use table splitting to bring in only the parts of the entity that you normally need.</span></span> <span data-ttu-id="350e1-957">L'entità che rappresenta la foto del prodotto verrà caricata solo quando ne hai esplicitamente bisogno.</span><span class="sxs-lookup"><span data-stu-id="350e1-957">The entity representing the product photo will only be loaded when you explicitly need it.</span></span>

<span data-ttu-id="350e1-958">Una buona risorsa che mostra come abilitare la suddivisione delle tabelle è il post \< http://blogs.microsoft.co.il/blogs/gilf/archive/2009/10/13/table-splitting-in-entity-framework.aspx>di blog "Table Splitting in Entity Framework" di Gil Fink: .</span><span class="sxs-lookup"><span data-stu-id="350e1-958">A good resource that shows how to enable table splitting is Gil Fink's "Table Splitting in Entity Framework" blog post: \<http://blogs.microsoft.co.il/blogs/gilf/archive/2009/10/13/table-splitting-in-entity-framework.aspx>.</span></span>

## <a name="9-other-considerations"></a><span data-ttu-id="350e1-959">9 Altre considerazioni</span><span class="sxs-lookup"><span data-stu-id="350e1-959">9 Other considerations</span></span>

### <a name="91-server-garbage-collection"></a><span data-ttu-id="350e1-960">9.1 Garbage Collection per server</span><span class="sxs-lookup"><span data-stu-id="350e1-960">9.1      Server Garbage Collection</span></span>

<span data-ttu-id="350e1-961">Alcuni utenti potrebbero riscontrare conflitti di risorse che limitano il parallelismo che si aspettano quando il Garbage Collector non è configurato correttamente.</span><span class="sxs-lookup"><span data-stu-id="350e1-961">Some users might experience resource contention that limits the parallelism they are expecting when the Garbage Collector is not properly configured.</span></span> <span data-ttu-id="350e1-962">Ogni volta che EF viene utilizzato in uno scenario multithreading o in qualsiasi applicazione simile a un sistema lato server, assicurarsi di abilitare Garbage Collection Server.</span><span class="sxs-lookup"><span data-stu-id="350e1-962">Whenever EF is used in a multithreaded scenario, or in any application that resembles a server-side system, make sure to enable Server Garbage Collection.</span></span> <span data-ttu-id="350e1-963">Questa operazione viene eseguita tramite una semplice impostazione nel file di configurazione dell'applicazione:This is done via a simple setting in your application config file:</span><span class="sxs-lookup"><span data-stu-id="350e1-963">This is done via a simple setting in your application config file:</span></span>

``` xml
<?xmlversion="1.0" encoding="utf-8" ?>
<configuration>
        <runtime>
               <gcServer enabled="true" />
        </runtime>
</configuration>
```

<span data-ttu-id="350e1-964">Questo dovrebbe ridurre la contesa dei thread e aumentare la velocità effettiva fino al 30% in scenari saturi di CPU.</span><span class="sxs-lookup"><span data-stu-id="350e1-964">This should decrease your thread contention and increase your throughput by up to 30% in CPU saturated scenarios.</span></span> <span data-ttu-id="350e1-965">In general terms, you should always test how your application behaves using the classic Garbage Collection (which is better tuned for UI and client side scenarios) as well as the Server Garbage Collection.</span><span class="sxs-lookup"><span data-stu-id="350e1-965">In general terms, you should always test how your application behaves using the classic Garbage Collection (which is better tuned for UI and client side scenarios) as well as the Server Garbage Collection.</span></span>

### <a name="92-autodetectchanges"></a><span data-ttu-id="350e1-966">9.2 Rilevamento automaticoModifiche</span><span class="sxs-lookup"><span data-stu-id="350e1-966">9.2      AutoDetectChanges</span></span>

<span data-ttu-id="350e1-967">Come accennato in precedenza, Entity Framework potrebbe mostrare problemi di prestazioni quando la cache degli oggetti ha molte entità.</span><span class="sxs-lookup"><span data-stu-id="350e1-967">As mentioned earlier, Entity Framework might show performance issues when the object cache has many entities.</span></span> <span data-ttu-id="350e1-968">Alcune operazioni, ad esempio Add, Remove, Find, Entry e SaveChanges, attivano le chiamate a DetectChanges che potrebbero utilizzare una grande quantità di CPU in base alle dimensioni della cache degli oggetti.</span><span class="sxs-lookup"><span data-stu-id="350e1-968">Certain operations, such as Add, Remove, Find, Entry and SaveChanges, trigger calls to DetectChanges which might consume a large amount of CPU based on how large the object cache has become.</span></span> <span data-ttu-id="350e1-969">Il motivo è che la cache degli oggetti e il gestore dello stato degli oggetti tentano di rimanere il più sincronizzati possibile in ogni operazione eseguita in un contesto in modo che i dati prodotti siano corretti in un'ampia gamma di scenari.</span><span class="sxs-lookup"><span data-stu-id="350e1-969">The reason for this is that the object cache and the object state manager try to stay as synchronized as possible on each operation performed to a context so that the produced data is guaranteed to be correct under a wide array of scenarios.</span></span>

<span data-ttu-id="350e1-970">È in genere consigliabile lasciare abilitato il rilevamento automatico delle modifiche di Entity Framework per l'intera durata dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="350e1-970">It is generally a good practice to leave Entity Framework’s automatic change detection enabled for the entire life of your application.</span></span> <span data-ttu-id="350e1-971">Se lo scenario è influenzato negativamente dall'utilizzo elevato della CPU e i profili indicano che il colpevole è la chiamata a DetectChanges, è consigliabile disattivare temporaneamente AutoDetectChanges nella parte sensibile del codice:</span><span class="sxs-lookup"><span data-stu-id="350e1-971">If your scenario is being negatively affected by high CPU usage and your profiles indicate that the culprit is the call to DetectChanges, consider temporarily turning off AutoDetectChanges in the sensitive portion of your code:</span></span>

``` csharp
try
{
    context.Configuration.AutoDetectChangesEnabled = false;
    var product = context.Products.Find(productId);
    ...
}
finally
{
    context.Configuration.AutoDetectChangesEnabled = true;
}
```

<span data-ttu-id="350e1-972">Prima di disattivare AutoDetectChanges, è bene comprendere che ciò potrebbe causare Entity Framework perdere la capacità di tenere traccia di alcune informazioni sulle modifiche che si stanno svolgendo sulle entità.</span><span class="sxs-lookup"><span data-stu-id="350e1-972">Before turning off AutoDetectChanges, it’s good to understand that this might cause Entity Framework to lose its ability to track certain information about the changes that are taking place on the entities.</span></span> <span data-ttu-id="350e1-973">Se gestito in modo non corretto, ciò potrebbe causare l'incoerenza dei dati nell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="350e1-973">If handled incorrectly, this might cause data inconsistency on your application.</span></span> <span data-ttu-id="350e1-974">Per ulteriori informazioni sulla disattivazione \< http://blog.oneunicorn.com/2012/03/12/secrets-of-detectchanges-part-3-switching-off-automatic-detectchanges/>di AutoDetectChanges, leggere .</span><span class="sxs-lookup"><span data-stu-id="350e1-974">For more information on turning off AutoDetectChanges, read \<http://blog.oneunicorn.com/2012/03/12/secrets-of-detectchanges-part-3-switching-off-automatic-detectchanges/>.</span></span>

### <a name="93-context-per-request"></a><span data-ttu-id="350e1-975">9.3 Contesto per richiesta</span><span class="sxs-lookup"><span data-stu-id="350e1-975">9.3      Context per request</span></span>

<span data-ttu-id="350e1-976">I contesti di Entity Framework sono pensati per essere utilizzati come istanze di breve durata per fornire l'esperienza di prestazioni ottimale.</span><span class="sxs-lookup"><span data-stu-id="350e1-976">Entity Framework’s contexts are meant to be used as short-lived instances in order to provide the most optimal performance experience.</span></span> <span data-ttu-id="350e1-977">Si prevede che i contesti siano di breve durata ed eliminati e, come tali, sono stati implementati per essere molto leggeri e riutilizzare i metadati quando possibile.</span><span class="sxs-lookup"><span data-stu-id="350e1-977">Contexts are expected to be short lived and discarded, and as such have been implemented to be very lightweight and reutilize metadata whenever possible.</span></span> <span data-ttu-id="350e1-978">Negli scenari Web è importante tenere presente questo aspetto e non disporre di un contesto per più della durata di una singola richiesta.</span><span class="sxs-lookup"><span data-stu-id="350e1-978">In web scenarios it’s important to keep this in mind and not have a context for more than the duration of a single request.</span></span> <span data-ttu-id="350e1-979">Analogamente, negli scenari non Web, il contesto deve essere eliminato in base alla comprensione dei diversi livelli di memorizzazione nella cache in Entity Framework.</span><span class="sxs-lookup"><span data-stu-id="350e1-979">Similarly, in non-web scenarios, context should be discarded based on your understanding of the different levels of caching in the Entity Framework.</span></span> <span data-ttu-id="350e1-980">In generale, è consigliabile evitare di avere un'istanza di contesto per tutta la durata dell'applicazione, nonché contesti per thread e contesti statici.</span><span class="sxs-lookup"><span data-stu-id="350e1-980">Generally speaking, one should avoid having a context instance throughout the life of the application, as well as contexts per thread and static contexts.</span></span>

### <a name="94-database-null-semantics"></a><span data-ttu-id="350e1-981">9.4 Semantica null del database</span><span class="sxs-lookup"><span data-stu-id="350e1-981">9.4      Database null semantics</span></span>

<span data-ttu-id="350e1-982">Entity Framework per impostazione predefinita\# genererà codice SQL con semantica di confronto null C.</span><span class="sxs-lookup"><span data-stu-id="350e1-982">Entity Framework by default will generate SQL code that has C\# null comparison semantics.</span></span> <span data-ttu-id="350e1-983">Si consideri la query di esempio seguente:</span><span class="sxs-lookup"><span data-stu-id="350e1-983">Consider the following example query:</span></span>

``` csharp
            int? categoryId = 7;
            int? supplierId = 8;
            decimal? unitPrice = 0;
            short? unitsInStock = 100;
            short? unitsOnOrder = 20;
            short? reorderLevel = null;

            var q = from p incontext.Products
                    wherep.Category.CategoryName == "Beverages"
                          || (p.CategoryID == categoryId
                                || p.SupplierID == supplierId
                                || p.UnitPrice == unitPrice
                                || p.UnitsInStock == unitsInStock
                                || p.UnitsOnOrder == unitsOnOrder
                                || p.ReorderLevel == reorderLevel)
                    select p;

            var r = q.ToList();
```

<span data-ttu-id="350e1-984">In this example, we're comparing a number of nullable variables against nullable properties on the entity, such as SupplierID and UnitPrice.</span><span class="sxs-lookup"><span data-stu-id="350e1-984">In this example, we’re comparing a number of nullable variables against nullable properties on the entity, such as SupplierID and UnitPrice.</span></span> <span data-ttu-id="350e1-985">Il codice SQL generato per questa query chiederà se il valore del parametro è uguale al valore della colonna o se entrambi i valori di parametro e colonna sono null.</span><span class="sxs-lookup"><span data-stu-id="350e1-985">The generated SQL for this query will ask if the parameter value is the same as the column value, or if both the parameter and the column values are null.</span></span> <span data-ttu-id="350e1-986">In questo modo si nasconderà il modo in\# cui il server di database gestisce i valori Null e fornirà un'esperienza null C coerente tra diversi fornitori di database.</span><span class="sxs-lookup"><span data-stu-id="350e1-986">This will hide the way the database server handles nulls and will provide a consistent C\# null experience across different database vendors.</span></span> <span data-ttu-id="350e1-987">D'altra parte, il codice generato è un po ' contorto e potrebbe non funzionare bene quando la quantità di confronti nell'istruzione where della query aumenta fino a un numero elevato.</span><span class="sxs-lookup"><span data-stu-id="350e1-987">On the other hand, the generated code is a bit convoluted and may not perform well when the amount of comparisons in the where statement of the query grows to a large number.</span></span>

<span data-ttu-id="350e1-988">Un modo per gestire questa situazione consiste nell'utilizzare la semantica null del database.</span><span class="sxs-lookup"><span data-stu-id="350e1-988">One way to deal with this situation is by using database null semantics.</span></span> <span data-ttu-id="350e1-989">Si noti che questo potrebbe potenzialmente\# comportarsi in modo diverso per la semantica null C dal momento che ora Entity Framework genererà SQL più semplice che espone il modo in cui il motore di database gestisce i valori null.</span><span class="sxs-lookup"><span data-stu-id="350e1-989">Note that this might potentially behave differently to the C\# null semantics since now Entity Framework will generate simpler SQL that exposes the way the database engine handles null values.</span></span> <span data-ttu-id="350e1-990">La semantica null del database può essere attivata per ogni contesto con una singola riga di configurazione per la configurazione del contesto:Database null semantics can be activated per-context with one single configuration line against the context configuration:</span><span class="sxs-lookup"><span data-stu-id="350e1-990">Database null semantics can be activated per-context with one single configuration line against the context configuration:</span></span>

``` csharp
                context.Configuration.UseDatabaseNullSemantics = true;
```

<span data-ttu-id="350e1-991">Le query di piccole e medie dimensioni non visualizzeranno un miglioramento delle prestazioni percepibile quando si usa la semantica null del database, ma la differenza diventerà più evidente nelle query con un numero elevato di potenziali confronti null.</span><span class="sxs-lookup"><span data-stu-id="350e1-991">Small to medium sized queries will not display a perceptible performance improvement when using database null semantics, but the difference will become more noticeable on queries with a large number of potential null comparisons.</span></span>

<span data-ttu-id="350e1-992">Nella query di esempio precedente, la differenza di prestazioni era inferiore al 2% in un microbenchmark in esecuzione in un ambiente controllato.</span><span class="sxs-lookup"><span data-stu-id="350e1-992">In the example query above, the performance difference was less than 2% in a microbenchmark running in a controlled environment.</span></span>

### <a name="95-async"></a><span data-ttu-id="350e1-993">9.5 Asincrono</span><span class="sxs-lookup"><span data-stu-id="350e1-993">9.5      Async</span></span>

<span data-ttu-id="350e1-994">Entity Framework 6 ha introdotto il supporto delle operazioni asincrone durante l'esecuzione in .NET 4.5 o versioni successive.</span><span class="sxs-lookup"><span data-stu-id="350e1-994">Entity Framework 6 introduced support of async operations when running on .NET 4.5 or later.</span></span> <span data-ttu-id="350e1-995">Per la maggior parte, le applicazioni con conflitti correlati all'I/O trarranno il massimo vantaggio dall'utilizzo di operazioni di query e salvataggio asincrone.</span><span class="sxs-lookup"><span data-stu-id="350e1-995">For the most part, applications that have IO related contention will benefit the most from using asynchronous query and save operations.</span></span> <span data-ttu-id="350e1-996">Se l'applicazione non soffre di conflitti di I/O, l'uso di async, nei casi migliori, verrà eseguito in modo sincrono e restituirà il risultato nello stesso periodo di tempo di una chiamata sincrona o, nel peggiore dei casi, semplicemente rinviare l'esecuzione a un'attività asincrona e aggiungere più tempo al completamento dello scenario.</span><span class="sxs-lookup"><span data-stu-id="350e1-996">If your application does not suffer from IO contention, the use of async will, in the best cases, run synchronously and return the result in the same amount of time as a synchronous call, or in the worst case, simply defer execution to an asynchronous task and add extra time to the completion of your scenario.</span></span>

<span data-ttu-id="350e1-997">Per informazioni sul funzionamento della programmazione asincrona che consente di decidere [http://msdn.microsoft.com/library/hh191443.aspx](https://msdn.microsoft.com/library/hh191443.aspx)se async migliorerà le prestazioni dell'applicazione visita .</span><span class="sxs-lookup"><span data-stu-id="350e1-997">For information on how asynchronous programming work that will help you deciding if async will improve the performance of your application visit [http://msdn.microsoft.com/library/hh191443.aspx](https://msdn.microsoft.com/library/hh191443.aspx).</span></span> <span data-ttu-id="350e1-998">Per ulteriori informazioni sull'utilizzo delle operazioni asincrone in Entity Framework, vedere [Query asincrona e salvataggio](~/ef6/fundamentals/async.md
).</span><span class="sxs-lookup"><span data-stu-id="350e1-998">For more information on the use of async operations on Entity Framework, see [Async Query and Save](~/ef6/fundamentals/async.md
).</span></span>

### <a name="96-ngen"></a><span data-ttu-id="350e1-999">9.6 NGEN (Gen)</span><span class="sxs-lookup"><span data-stu-id="350e1-999">9.6      NGEN</span></span>

<span data-ttu-id="350e1-1000">Entity Framework 6 non viene fornito nell'installazione predefinita di .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="350e1-1000">Entity Framework 6 does not come in the default installation of .NET framework.</span></span> <span data-ttu-id="350e1-1001">Di conseguenza, gli assembly di Entity Framework non sono NGEN'd per impostazione predefinita, il che significa che tutto il codice Entity Framework è soggetto agli stessi costi JIT'ing di qualsiasi altro assembly MSIL.</span><span class="sxs-lookup"><span data-stu-id="350e1-1001">As such, the Entity Framework assemblies are not NGEN’d by default which means that all the Entity Framework code is subject to the same JIT’ing costs as any other MSIL assembly.</span></span> <span data-ttu-id="350e1-1002">Ciò potrebbe ridurre l'esperienza F5 durante lo sviluppo e anche l'avvio a freddo dell'applicazione negli ambienti di produzione.</span><span class="sxs-lookup"><span data-stu-id="350e1-1002">This might degrade the F5 experience while developing and also the cold startup of your application in the production environments.</span></span> <span data-ttu-id="350e1-1003">Al fine di ridurre i costi di CPU e memoria di JIT'ing è consigliabile NGEN le immagini di Entity Framework a seconda dei casi.</span><span class="sxs-lookup"><span data-stu-id="350e1-1003">In order to reduce the CPU and memory costs of JIT’ing it is advisable to NGEN the Entity Framework images as appropriate.</span></span> <span data-ttu-id="350e1-1004">Per ulteriori informazioni su come migliorare le prestazioni di avvio di Entity Framework 6 con NGEN, vedere Miglioramento delle prestazioni di [avvio con NGen](~/ef6/fundamentals/performance/ngen.md).</span><span class="sxs-lookup"><span data-stu-id="350e1-1004">For more information on how to improve the startup performance of Entity Framework 6 with NGEN, see [Improving Startup Performance with NGen](~/ef6/fundamentals/performance/ngen.md).</span></span>

### <a name="97-code-first-versus-edmx"></a><span data-ttu-id="350e1-1005">9.7 Code First rispetto a EDMX</span><span class="sxs-lookup"><span data-stu-id="350e1-1005">9.7      Code First versus EDMX</span></span>

<span data-ttu-id="350e1-1006">Entity Framework motivi circa il problema di mancata corrispondenza impediti tra la programmazione orientata agli oggetti e database relazionali con una rappresentazione in memoria del modello concettuale (gli oggetti), lo schema di archiviazione (il database) e un mapping tra i due.</span><span class="sxs-lookup"><span data-stu-id="350e1-1006">Entity Framework reasons about the impedance mismatch problem between object oriented programming and relational databases by having an in-memory representation of the conceptual model (the objects), the storage schema (the database) and a mapping between the two.</span></span> <span data-ttu-id="350e1-1007">Questi metadati sono denominati Entity Data Model o EDM in breve.</span><span class="sxs-lookup"><span data-stu-id="350e1-1007">This metadata is called an Entity Data Model, or EDM for short.</span></span> <span data-ttu-id="350e1-1008">Da questo EDM, Entity Framework deriverà le viste ai dati di andata e ritorno dagli oggetti in memoria al database e viceversa.</span><span class="sxs-lookup"><span data-stu-id="350e1-1008">From this EDM, Entity Framework will derive the views to roundtrip data from the objects in memory to the database and back.</span></span>

<span data-ttu-id="350e1-1009">Quando Entity Framework viene utilizzato con un file EDMX che specifica formalmente il modello concettuale, lo schema di archiviazione e il mapping, la fase di caricamento del modello deve solo verificare che l'EDM sia corretto (ad esempio, assicurarsi che non manchino mapping), quindi generare le visualizzazioni, quindi convalidare le visualizzazioni e avere questi metadati pronti per l'uso.</span><span class="sxs-lookup"><span data-stu-id="350e1-1009">When Entity Framework is used with an EDMX file that formally specifies the conceptual model, the storage schema, and the mapping, then the model loading stage only has to validate that the EDM is correct (for example, make sure that no mappings are missing), then generate the views, then validate the views and have this metadata ready for use.</span></span> <span data-ttu-id="350e1-1010">Solo allora è possibile eseguire una query o salvare nuovi dati nell'archivio dati.</span><span class="sxs-lookup"><span data-stu-id="350e1-1010">Only then can a query be executed or new data be saved to the data store.</span></span>

<span data-ttu-id="350e1-1011">L'approccio Code First è, a suo centro, un sofisticato generatore Entity Data Model.</span><span class="sxs-lookup"><span data-stu-id="350e1-1011">The Code First approach is, at its heart, a sophisticated Entity Data Model generator.</span></span> <span data-ttu-id="350e1-1012">Entity Framework deve produrre un EDM dal codice fornito; lo fa analizzando le classi coinvolte nel modello, applicando le convenzioni e configurando il modello tramite l'API Fluent.</span><span class="sxs-lookup"><span data-stu-id="350e1-1012">The Entity Framework has to produce an EDM from the provided code; it does so by analyzing the classes involved in the model, applying conventions and configuring the model via the Fluent API.</span></span> <span data-ttu-id="350e1-1013">Dopo la compilazione dell'EDM, Entity Framework si comporta essenzialmente nello stesso modo in cui presenterebbe un file EDMX nel progetto.</span><span class="sxs-lookup"><span data-stu-id="350e1-1013">After the EDM is built, the Entity Framework essentially behaves the same way as it would had an EDMX file been present in the project.</span></span> <span data-ttu-id="350e1-1014">Pertanto, la compilazione del modello da Code First aggiunge ulteriore complessità che si traduce in un tempo di avvio più lento per Entity Framework rispetto alla presenza di un EDMX.</span><span class="sxs-lookup"><span data-stu-id="350e1-1014">Thus, building the model from Code First adds extra complexity that translates into a slower startup time for the Entity Framework when compared to having an EDMX.</span></span> <span data-ttu-id="350e1-1015">Il costo dipende completamente dalle dimensioni e dalla complessità del modello in fase di compilazione.</span><span class="sxs-lookup"><span data-stu-id="350e1-1015">The cost is completely dependent on the size and complexity of the model that’s being built.</span></span>

<span data-ttu-id="350e1-1016">Quando si sceglie di utilizzare EDMX rispetto a Code First, è importante sapere che la flessibilità introdotta da Code First aumenta il costo di compilazione del modello per la prima volta.</span><span class="sxs-lookup"><span data-stu-id="350e1-1016">When choosing to use EDMX versus Code First, it’s important to know that the flexibility introduced by Code First increases the cost of building the model for the first time.</span></span> <span data-ttu-id="350e1-1017">Se l'applicazione è in grado di sopportare il costo di questo primo caricamento, in genere Code First sarà la strada preferita da percorrere.</span><span class="sxs-lookup"><span data-stu-id="350e1-1017">If your application can withstand the cost of this first-time load then typically Code First will be the preferred way to go.</span></span>

## <a name="10-investigating-performance"></a><span data-ttu-id="350e1-1018">10 Indagine sulle prestazioni</span><span class="sxs-lookup"><span data-stu-id="350e1-1018">10 Investigating Performance</span></span>

### <a name="101-using-the-visual-studio-profiler"></a><span data-ttu-id="350e1-1019">10.1 Utilizzo di Visual Studio Profiler</span><span class="sxs-lookup"><span data-stu-id="350e1-1019">10.1 Using the Visual Studio Profiler</span></span>

<span data-ttu-id="350e1-1020">Se si verificano problemi di prestazioni con Entity Framework, è possibile usare un profiler simile a quello incorporato in Visual Studio per vedere dove l'applicazione sta trascorrendo il proprio tempo.</span><span class="sxs-lookup"><span data-stu-id="350e1-1020">If you are having performance issues with the Entity Framework, you can use a profiler like the one built into Visual Studio to see where your application is spending its time.</span></span> <span data-ttu-id="350e1-1021">Questo è lo strumento che abbiamo usato per generare i grafici a torta nel \< https://docs.microsoft.com/archive/blogs/adonet/exploring-the-performance-of-the-ado-net-entity-framework-part-1>) post di blog "Esplorazione delle prestazioni del ADO.NET Entity Framework - Parte 1" (che mostrano dove Entity Framework trascorre il suo tempo durante le query fredde e calde.</span><span class="sxs-lookup"><span data-stu-id="350e1-1021">This is the tool we used to generate the pie charts in the “Exploring the Performance of the ADO.NET Entity Framework - Part 1” blog post ( \<https://docs.microsoft.com/archive/blogs/adonet/exploring-the-performance-of-the-ado-net-entity-framework-part-1>) that show where Entity Framework spends its time during cold and warm queries.</span></span>

<span data-ttu-id="350e1-1022">Il post di blog "Profiling Entity Framework using the Visual Studio 2010 Profiler" scritto dal team di consulenza clienti Data e modellazione mostra un esempio reale di come hanno utilizzato il profiler per analizzare un problema di prestazioni.</span><span class="sxs-lookup"><span data-stu-id="350e1-1022">The "Profiling Entity Framework using the Visual Studio 2010 Profiler" blog post written by the Data and Modeling Customer Advisory Team shows a real-world example of how they used the profiler to investigate a performance problem.</span></span><span data-ttu-id="350e1-1023">\<https://docs.microsoft.com/archive/blogs/dmcat/profiling-entity-framework-using-the-visual-studio-2010-profiler>.</span><span class="sxs-lookup"><span data-stu-id="350e1-1023">  \<https://docs.microsoft.com/archive/blogs/dmcat/profiling-entity-framework-using-the-visual-studio-2010-profiler>.</span></span> <span data-ttu-id="350e1-1024">Questo post è stato scritto per un'applicazione Windows.</span><span class="sxs-lookup"><span data-stu-id="350e1-1024">This post was written for a windows application.</span></span> <span data-ttu-id="350e1-1025">Se è necessario profilare un'applicazione Web gli strumenti Windows Performance Recorder (WPR) e Windows Performance Analyzer (WPA) potrebbero funzionare meglio che funzionare da Visual Studio.</span><span class="sxs-lookup"><span data-stu-id="350e1-1025">If you need to profile a web application the Windows Performance Recorder (WPR) and Windows Performance Analyzer (WPA) tools may work better than working from Visual Studio.</span></span> <span data-ttu-id="350e1-1026">WPR e WPA fanno parte di Windows Performance Toolkit incluso [http://www.microsoft.com/download/details.aspx?id=39982](https://www.microsoft.com/download/details.aspx?id=39982)in Windows Assessment and Deployment Kit ( ).</span><span class="sxs-lookup"><span data-stu-id="350e1-1026">WPR and WPA are part of the Windows Performance Toolkit which is included with the Windows Assessment and Deployment Kit ( [http://www.microsoft.com/download/details.aspx?id=39982](https://www.microsoft.com/download/details.aspx?id=39982)).</span></span>

### <a name="102-applicationdatabase-profiling"></a><span data-ttu-id="350e1-1027">10.2 Profilazione di applicazioni/database</span><span class="sxs-lookup"><span data-stu-id="350e1-1027">10.2 Application/Database profiling</span></span>

<span data-ttu-id="350e1-1028">Strumenti come il profiler integrato in Visual Studio indicano dove l'applicazione sta trascorrendo tempo.</span><span class="sxs-lookup"><span data-stu-id="350e1-1028">Tools like the profiler built into Visual Studio tell you where your application is spending time.</span></span><span data-ttu-id="350e1-1029">È disponibile un altro tipo di profiler che esegue l'analisi dinamica dell'applicazione in esecuzione, in produzione o in pre-produzione a seconda delle esigenze, e cerca le insidie comuni e gli anti-modelli di accesso al database.</span><span class="sxs-lookup"><span data-stu-id="350e1-1029">  Another type of profiler is available that performs dynamic analysis of your running application, either in production or pre-production depending on needs, and looks for common pitfalls and anti-patterns of database access.</span></span>

<span data-ttu-id="350e1-1030">Due profiler disponibili in commercio sono \< http://efprof.com>) Entity Framework \< http://ormprofiler.com>)Profiler ( e ORMProfiler ( .</span><span class="sxs-lookup"><span data-stu-id="350e1-1030">Two commercially available profilers are the Entity Framework Profiler ( \<http://efprof.com>) and ORMProfiler ( \<http://ormprofiler.com>).</span></span>

<span data-ttu-id="350e1-1031">Se l'applicazione è un'applicazione MVC che utilizza Code First, è possibile utilizzare MiniProfiler di StackExchange.</span><span class="sxs-lookup"><span data-stu-id="350e1-1031">If your application is an MVC application using Code First, you can use StackExchange's MiniProfiler.</span></span> <span data-ttu-id="350e1-1032">Scott Hanselman descrive questo strumento nel \< http://www.hanselman.com/blog/NuGetPackageOfTheWeek9ASPNETMiniProfilerFromStackExchangeRocksYourWorld.aspx>suo blog all'indirizzo: .</span><span class="sxs-lookup"><span data-stu-id="350e1-1032">Scott Hanselman describes this tool in his blog at: \<http://www.hanselman.com/blog/NuGetPackageOfTheWeek9ASPNETMiniProfilerFromStackExchangeRocksYourWorld.aspx>.</span></span>

<span data-ttu-id="350e1-1033">Per ulteriori informazioni sulla profilatura dell'attività del database dell'applicazione, vedere l'articolo MSDN Magazine di Julie Lerman intitolato [Profiling Database Activity in The Framework](https://msdn.microsoft.com/magazine/gg490349.aspx).</span><span class="sxs-lookup"><span data-stu-id="350e1-1033">For more information on profiling your application's database activity, see Julie Lerman's MSDN Magazine article titled [Profiling Database Activity in the Entity Framework](https://msdn.microsoft.com/magazine/gg490349.aspx).</span></span>

### <a name="103-database-logger"></a><span data-ttu-id="350e1-1034">10.3 Logger di database</span><span class="sxs-lookup"><span data-stu-id="350e1-1034">10.3 Database logger</span></span>

<span data-ttu-id="350e1-1035">Se si utilizza Entity Framework 6 è anche prendere in considerazione l'utilizzo della funzionalità di registrazione incorporata.</span><span class="sxs-lookup"><span data-stu-id="350e1-1035">If you are using Entity Framework 6 also consider using the built-in logging functionality.</span></span> <span data-ttu-id="350e1-1036">Il Database proprietà del contesto può essere istruito per registrare la propria attività tramite una semplice configurazione di una riga:</span><span class="sxs-lookup"><span data-stu-id="350e1-1036">The Database property of the context can be instructed to log its activity via a simple one-line configuration:</span></span>

``` csharp
    using (var context = newQueryComparison.DbC.NorthwindEntities())
    {
        context.Database.Log = Console.WriteLine;
        var q = context.Products.Where(p => p.Category.CategoryName == "Beverages");
        q.ToList();
    }
```

<span data-ttu-id="350e1-1037">In questo esempio l'attività del database verrà registrata nella console, ma&lt;&gt; la proprietà Log può essere configurata per chiamare qualsiasi delegato della stringa Di azione.</span><span class="sxs-lookup"><span data-stu-id="350e1-1037">In this example the database activity will be logged to the console, but the Log property can be configured to call any Action&lt;string&gt; delegate.</span></span>

<span data-ttu-id="350e1-1038">Se si desidera abilitare la registrazione del database senza ricompilare e si utilizza Entity Framework 6.1 o versione successiva, è possibile farlo aggiungendo un intercettore nel file web.config o app.config dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="350e1-1038">If you want to enable database logging without recompiling, and you are using Entity Framework 6.1 or later, you can do so by adding an interceptor in the web.config or app.config file of your application.</span></span>

``` xml
  <interceptors>
    <interceptor type="System.Data.Entity.Infrastructure.Interception.DatabaseLogger, EntityFramework">
      <parameters>
        <parameter value="C:\Path\To\My\LogOutput.txt"/>
      </parameters>
    </interceptor>
  </interceptors>
```

<span data-ttu-id="350e1-1039">Per ulteriori informazioni su come aggiungere la registrazione \< http://blog.oneunicorn.com/2014/02/09/ef-6-1-turning-on-logging-without-recompiling/>senza ricompilare, visitare .</span><span class="sxs-lookup"><span data-stu-id="350e1-1039">For more information on how to add logging without recompiling go to \<http://blog.oneunicorn.com/2014/02/09/ef-6-1-turning-on-logging-without-recompiling/>.</span></span>

## <a name="11-appendix"></a><span data-ttu-id="350e1-1040">11 Appendice</span><span class="sxs-lookup"><span data-stu-id="350e1-1040">11 Appendix</span></span>

### <a name="111-a-test-environment"></a><span data-ttu-id="350e1-1041">11.1 A. Ambiente di prova</span><span class="sxs-lookup"><span data-stu-id="350e1-1041">11.1 A. Test Environment</span></span>

<span data-ttu-id="350e1-1042">Questo ambiente utilizza un'installazione su due computer con il database in un computer separato dall'applicazione client.</span><span class="sxs-lookup"><span data-stu-id="350e1-1042">This environment uses a 2-machine setup with the database on a separate machine from the client application.</span></span> <span data-ttu-id="350e1-1043">Le macchine si trovano nello stesso rack, quindi la latenza di rete è relativamente bassa, ma più realistica di un ambiente a computer singolo.</span><span class="sxs-lookup"><span data-stu-id="350e1-1043">Machines are in the same rack, so network latency is relatively low, but more realistic than a single-machine environment.</span></span>

#### <a name="1111-app-server"></a><span data-ttu-id="350e1-1044">11.1.1 Server applicazioni</span><span class="sxs-lookup"><span data-stu-id="350e1-1044">11.1.1       App Server</span></span>

##### <a name="11111-software-environment"></a><span data-ttu-id="350e1-1045">11.1.1.1 Ambiente software</span><span class="sxs-lookup"><span data-stu-id="350e1-1045">11.1.1.1      Software Environment</span></span>

-   <span data-ttu-id="350e1-1046">Ambiente software Entity Framework 4</span><span class="sxs-lookup"><span data-stu-id="350e1-1046">Entity Framework 4 Software Environment</span></span>
    -   <span data-ttu-id="350e1-1047">Nome del sistema operativo: Windows Server 2008 R2 Enterprise SP1.</span><span class="sxs-lookup"><span data-stu-id="350e1-1047">OS Name: Windows Server 2008 R2 Enterprise SP1.</span></span>
    -   <span data-ttu-id="350e1-1048">Visual Studio 2010 – Ultimate.</span><span class="sxs-lookup"><span data-stu-id="350e1-1048">Visual Studio 2010 – Ultimate.</span></span>
    -   <span data-ttu-id="350e1-1049">Visual Studio 2010 SP1 (solo per alcuni confronti).</span><span class="sxs-lookup"><span data-stu-id="350e1-1049">Visual Studio 2010 SP1 (only for some comparisons).</span></span>
-   <span data-ttu-id="350e1-1050">Ambiente software Entity Framework 5 e 6</span><span class="sxs-lookup"><span data-stu-id="350e1-1050">Entity Framework 5 and 6 Software Environment</span></span>
    -   <span data-ttu-id="350e1-1051">Nome del sistema operativo: Windows 8.1 Enterprise</span><span class="sxs-lookup"><span data-stu-id="350e1-1051">OS Name: Windows 8.1 Enterprise</span></span>
    -   <span data-ttu-id="350e1-1052">Visual Studio 2013 – Ultimate.</span><span class="sxs-lookup"><span data-stu-id="350e1-1052">Visual Studio 2013 – Ultimate.</span></span>

##### <a name="11112-hardware-environment"></a><span data-ttu-id="350e1-1053">11.1.1.2 Ambiente hardware</span><span class="sxs-lookup"><span data-stu-id="350e1-1053">11.1.1.2      Hardware Environment</span></span>

-   <span data-ttu-id="350e1-1054">Processore doppio: CPU Intel(R) Xeon(R) L5520 W3530 - 2,27 GHz, 2261 Mhz8 GHz, 4 Core,84 Processori Logici.</span><span class="sxs-lookup"><span data-stu-id="350e1-1054">Dual Processor:     Intel(R) Xeon(R) CPU L5520 W3530 @ 2.27GHz, 2261 Mhz8 GHz, 4 Core(s), 84 Logical Processor(s).</span></span>
-   <span data-ttu-id="350e1-1055">2412 GB di RamRAM.</span><span class="sxs-lookup"><span data-stu-id="350e1-1055">2412 GB RamRAM.</span></span>
-   <span data-ttu-id="350e1-1056">Unità SAtA 7200 rpm da 3 GB/s da 136 GB suddivisa in 4 partizioni.</span><span class="sxs-lookup"><span data-stu-id="350e1-1056">136 GB SCSI250GB SATA 7200 rpm 3GB/s drive split into 4 partitions.</span></span>

#### <a name="1112-db-server"></a><span data-ttu-id="350e1-1057">11.1.2 Server DB</span><span class="sxs-lookup"><span data-stu-id="350e1-1057">11.1.2       DB server</span></span>

##### <a name="11121-software-environment"></a><span data-ttu-id="350e1-1058">11.1.2.1 Ambiente software</span><span class="sxs-lookup"><span data-stu-id="350e1-1058">11.1.2.1      Software Environment</span></span>

-   <span data-ttu-id="350e1-1059">Nome del sistema operativo: Windows Server 2008 R28.1 Enterprise SP1.</span><span class="sxs-lookup"><span data-stu-id="350e1-1059">OS Name: Windows Server 2008 R28.1 Enterprise SP1.</span></span>
-   <span data-ttu-id="350e1-1060">SQL Server 2008 R22012.</span><span class="sxs-lookup"><span data-stu-id="350e1-1060">SQL Server 2008 R22012.</span></span>

##### <a name="11122-hardware-environment"></a><span data-ttu-id="350e1-1061">11.1.2.2 Ambiente hardware</span><span class="sxs-lookup"><span data-stu-id="350e1-1061">11.1.2.2      Hardware Environment</span></span>

-   <span data-ttu-id="350e1-1062">Processore singolo: CPU Intel(R) Xeon(R) L5520 - 2,27 GHz, 2261 MhzES-1620 0 - 3,60 GHz, 4 Core(s), 8 Processori Logici.</span><span class="sxs-lookup"><span data-stu-id="350e1-1062">Single Processor: Intel(R) Xeon(R) CPU L5520  @ 2.27GHz, 2261 MhzES-1620 0 @ 3.60GHz, 4 Core(s), 8 Logical Processor(s).</span></span>
-   <span data-ttu-id="350e1-1063">824 GB di RamRAM.</span><span class="sxs-lookup"><span data-stu-id="350e1-1063">824 GB RamRAM.</span></span>
-   <span data-ttu-id="350e1-1064">Unità DA 465 GB ATA500 GB SATA 7200 rpm 6GB/s suddivisa in 4 partizioni.</span><span class="sxs-lookup"><span data-stu-id="350e1-1064">465 GB ATA500GB SATA 7200 rpm 6GB/s drive split into 4 partitions.</span></span>

### <a name="112-b-query-performance-comparison-tests"></a><span data-ttu-id="350e1-1065">11.2 B. Test di confronto delle prestazioni delle query</span><span class="sxs-lookup"><span data-stu-id="350e1-1065">11.2      B. Query performance comparison tests</span></span>

<span data-ttu-id="350e1-1066">Il modello Northwind è stato utilizzato per eseguire questi test.</span><span class="sxs-lookup"><span data-stu-id="350e1-1066">The Northwind model was used to execute these tests.</span></span> <span data-ttu-id="350e1-1067">È stato generato dal database utilizzando la finestra di progettazione Entity Framework.</span><span class="sxs-lookup"><span data-stu-id="350e1-1067">It was generated from the database using the Entity Framework designer.</span></span> <span data-ttu-id="350e1-1068">Quindi, è stato utilizzato il codice seguente per confrontare le prestazioni delle opzioni di esecuzione della query:</span><span class="sxs-lookup"><span data-stu-id="350e1-1068">Then, the following code was used to compare the performance of the query execution options:</span></span>

``` csharp
using System;
using System.Collections.Generic;
using System.Data;
using System.Data.Common;
using System.Data.Entity.Infrastructure;
using System.Data.EntityClient;
using System.Data.Objects;
using System.Linq;

namespace QueryComparison
{
    public partial class NorthwindEntities : ObjectContext
    {
        private static readonly Func<NorthwindEntities, string, IQueryable<Product>> productsForCategoryCQ = CompiledQuery.Compile(
            (NorthwindEntities context, string categoryName) =>
                context.Products.Where(p => p.Category.CategoryName == categoryName)
                );

        public IQueryable<Product> InvokeProductsForCategoryCQ(string categoryName)
        {
            return productsForCategoryCQ(this, categoryName);
        }
    }

    public class QueryTypePerfComparison
    {
        private static string entityConnectionStr = @"metadata=res://*/Northwind.csdl|res://*/Northwind.ssdl|res://*/Northwind.msl;provider=System.Data.SqlClient;provider connection string='data source=.;initial catalog=Northwind;integrated security=True;multipleactiveresultsets=True;App=EntityFramework'";

        public void LINQIncludingContextCreation()
        {
            using (NorthwindEntities context = new NorthwindEntities())
            {                 
                var q = context.Products.Where(p => p.Category.CategoryName == "Beverages");
                q.ToList();
            }
        }

        public void LINQNoTracking()
        {
            using (NorthwindEntities context = new NorthwindEntities())
            {
                context.Products.MergeOption = MergeOption.NoTracking;

                var q = context.Products.Where(p => p.Category.CategoryName == "Beverages");
                q.ToList();
            }
        }

        public void CompiledQuery()
        {
            using (NorthwindEntities context = new NorthwindEntities())
            {
                var q = context.InvokeProductsForCategoryCQ("Beverages");
                q.ToList();
            }
        }

        public void ObjectQuery()
        {
            using (NorthwindEntities context = new NorthwindEntities())
            {
                ObjectQuery<Product> products = context.Products.Where("it.Category.CategoryName = 'Beverages'");
                products.ToList();
            }
        }

        public void EntityCommand()
        {
            using (EntityConnection eConn = new EntityConnection(entityConnectionStr))
            {
                eConn.Open();
                EntityCommand cmd = eConn.CreateCommand();
                cmd.CommandText = "Select p From NorthwindEntities.Products As p Where p.Category.CategoryName = 'Beverages'";

                using (EntityDataReader reader = cmd.ExecuteReader(CommandBehavior.SequentialAccess))
                {
                    List<Product> productsList = new List<Product>();
                    while (reader.Read())
                    {
                        DbDataRecord record = (DbDataRecord)reader.GetValue(0);

                        // 'materialize' the product by accessing each field and value. Because we are materializing products, we won't have any nested data readers or records.
                        int fieldCount = record.FieldCount;

                        // Treat all products as Product, even if they are the subtype DiscontinuedProduct.
                        Product product = new Product();  

                        product.ProductID = record.GetInt32(0);
                        product.ProductName = record.GetString(1);
                        product.SupplierID = record.GetInt32(2);
                        product.CategoryID = record.GetInt32(3);
                        product.QuantityPerUnit = record.GetString(4);
                        product.UnitPrice = record.GetDecimal(5);
                        product.UnitsInStock = record.GetInt16(6);
                        product.UnitsOnOrder = record.GetInt16(7);
                        product.ReorderLevel = record.GetInt16(8);
                        product.Discontinued = record.GetBoolean(9);

                        productsList.Add(product);
                    }
                }
            }
        }

        public void ExecuteStoreQuery()
        {
            using (NorthwindEntities context = new NorthwindEntities())
            {
                ObjectResult<Product> beverages = context.ExecuteStoreQuery<Product>(
@"    SELECT        P.ProductID, P.ProductName, P.SupplierID, P.CategoryID, P.QuantityPerUnit, P.UnitPrice, P.UnitsInStock, P.UnitsOnOrder, P.ReorderLevel, P.Discontinued
    FROM            Products AS P INNER JOIN Categories AS C ON P.CategoryID = C.CategoryID
    WHERE        (C.CategoryName = 'Beverages')"
);
                beverages.ToList();
            }
        }

        public void ExecuteStoreQueryDbContext()
        {
            using (var context = new QueryComparison.DbC.NorthwindEntities())
            {
                var beverages = context.Database.SqlQuery\<QueryComparison.DbC.Product>(
@"    SELECT        P.ProductID, P.ProductName, P.SupplierID, P.CategoryID, P.QuantityPerUnit, P.UnitPrice, P.UnitsInStock, P.UnitsOnOrder, P.ReorderLevel, P.Discontinued
    FROM            Products AS P INNER JOIN Categories AS C ON P.CategoryID = C.CategoryID
    WHERE        (C.CategoryName = 'Beverages')"
);
                beverages.ToList();
            }
        }

        public void ExecuteStoreQueryDbSet()
        {
            using (var context = new QueryComparison.DbC.NorthwindEntities())
            {
                var beverages = context.Products.SqlQuery(
@"    SELECT        P.ProductID, P.ProductName, P.SupplierID, P.CategoryID, P.QuantityPerUnit, P.UnitPrice, P.UnitsInStock, P.UnitsOnOrder, P.ReorderLevel, P.Discontinued
    FROM            Products AS P INNER JOIN Categories AS C ON P.CategoryID = C.CategoryID
    WHERE        (C.CategoryName = 'Beverages')"
);
                beverages.ToList();
            }
        }

        public void LINQIncludingContextCreationDbContext()
        {
            using (var context = new QueryComparison.DbC.NorthwindEntities())
            {                 
                var q = context.Products.Where(p => p.Category.CategoryName == "Beverages");
                q.ToList();
            }
        }

        public void LINQNoTrackingDbContext()
        {
            using (var context = new QueryComparison.DbC.NorthwindEntities())
            {
                var q = context.Products.AsNoTracking().Where(p => p.Category.CategoryName == "Beverages");
                q.ToList();
            }
        }
    }
}
```

### <a name="113-c-navision-model"></a><span data-ttu-id="350e1-1069">11.3 C. Navision Modello</span><span class="sxs-lookup"><span data-stu-id="350e1-1069">11.3 C. Navision Model</span></span>

<span data-ttu-id="350e1-1070">Il database di Navision è un database di grandi dimensioni utilizzato per la dimostrazione di Microsoft Dynamics – NAV.</span><span class="sxs-lookup"><span data-stu-id="350e1-1070">The Navision database is a large database used to demo Microsoft Dynamics – NAV.</span></span> <span data-ttu-id="350e1-1071">Il modello concettuale generato contiene 1005 set di entità e 4227 set di associazioni.</span><span class="sxs-lookup"><span data-stu-id="350e1-1071">The generated conceptual model contains 1005 entity sets and 4227 association sets.</span></span> <span data-ttu-id="350e1-1072">Il modello utilizzato nel test è "flat" - non è stata aggiunta alcuna ereditarietà.</span><span class="sxs-lookup"><span data-stu-id="350e1-1072">The model used in the test is “flat” – no inheritance has been added to it.</span></span>

#### <a name="1131-queries-used-for-navision-tests"></a><span data-ttu-id="350e1-1073">11.3.1 Query utilizzate per i test di Navision</span><span class="sxs-lookup"><span data-stu-id="350e1-1073">11.3.1 Queries used for Navision tests</span></span>

<span data-ttu-id="350e1-1074">L'elenco di query utilizzato con il modello Navision contiene 3 categorie di query Entity SQL:</span><span class="sxs-lookup"><span data-stu-id="350e1-1074">The queries list used with the Navision model contains 3 categories of Entity SQL queries:</span></span>

##### <a name="11311-lookup"></a><span data-ttu-id="350e1-1075">11.3.1.1 Ricerca</span><span class="sxs-lookup"><span data-stu-id="350e1-1075">11.3.1.1 Lookup</span></span>

<span data-ttu-id="350e1-1076">Una query di ricerca semplice senza aggregazioni</span><span class="sxs-lookup"><span data-stu-id="350e1-1076">A simple lookup query with no aggregations</span></span>

-   <span data-ttu-id="350e1-1077">Conteggio: 16232Count: 16232</span><span class="sxs-lookup"><span data-stu-id="350e1-1077">Count: 16232</span></span>
-   <span data-ttu-id="350e1-1078">Esempio:</span><span class="sxs-lookup"><span data-stu-id="350e1-1078">Example:</span></span>

``` xml
  <Query complexity="Lookup">
    <CommandText>Select value distinct top(4) e.Idle_Time From NavisionFKContext.Session as e</CommandText>
  </Query>
```

##### <a name="11312singleaggregating"></a><span data-ttu-id="350e1-1079">11.3.1.2 SingleAggregating</span><span class="sxs-lookup"><span data-stu-id="350e1-1079">11.3.1.2 SingleAggregating</span></span>

<span data-ttu-id="350e1-1080">Una normale query BI con più aggregazioni, ma senza subtotali (query singola)</span><span class="sxs-lookup"><span data-stu-id="350e1-1080">A normal BI query with multiple aggregations, but no subtotals (single query)</span></span>

-   <span data-ttu-id="350e1-1081">Conteggio: 2313Count: 2313</span><span class="sxs-lookup"><span data-stu-id="350e1-1081">Count: 2313</span></span>
-   <span data-ttu-id="350e1-1082">Esempio:</span><span class="sxs-lookup"><span data-stu-id="350e1-1082">Example:</span></span>

``` xml
  <Query complexity="SingleAggregating">
    <CommandText>NavisionFK.MDF_SessionLogin_Time_Max()</CommandText>
  </Query>
```

<span data-ttu-id="350e1-1083">Dove MDF\_\_SessionLogin Time\_Max() è definito nel modello come:</span><span class="sxs-lookup"><span data-stu-id="350e1-1083">Where MDF\_SessionLogin\_Time\_Max() is defined in the model as:</span></span>

``` xml
  <Function Name="MDF_SessionLogin_Time_Max" ReturnType="Collection(DateTime)">
    <DefiningExpression>SELECT VALUE Edm.Min(E.Login_Time) FROM NavisionFKContext.Session as E</DefiningExpression>
  </Function>
```

##### <a name="11313aggregatingsubtotals"></a><span data-ttu-id="350e1-1084">11.3.1.3 AggregazioneSubtotali</span><span class="sxs-lookup"><span data-stu-id="350e1-1084">11.3.1.3 AggregatingSubtotals</span></span>

<span data-ttu-id="350e1-1085">Una query BI con aggregazioni e subtotali (tramite Unione tutti)</span><span class="sxs-lookup"><span data-stu-id="350e1-1085">A BI query with aggregations and subtotals (via union all)</span></span>

-   <span data-ttu-id="350e1-1086">Conteggio: 178Count: 178</span><span class="sxs-lookup"><span data-stu-id="350e1-1086">Count: 178</span></span>
-   <span data-ttu-id="350e1-1087">Esempio:</span><span class="sxs-lookup"><span data-stu-id="350e1-1087">Example:</span></span>

``` xml
  <Query complexity="AggregatingSubtotals">
    <CommandText>
using NavisionFK;
function AmountConsumed(entities Collection([CRONUS_International_Ltd__Zone])) as
(
    Edm.Sum(select value N.Block_Movement FROM entities as E, E.CRONUS_International_Ltd__Bin as N)
)
function AmountConsumed(P1 Edm.Int32) as
(
    AmountConsumed(select value e from NavisionFKContext.CRONUS_International_Ltd__Zone as e where e.Zone_Ranking = P1)
)
----------------------------------------------------------------------------------------------------------------------
(
    select top(10) Zone_Ranking, Cross_Dock_Bin_Zone, AmountConsumed(GroupPartition(E))
    from NavisionFKContext.CRONUS_International_Ltd__Zone as E
    where AmountConsumed(E.Zone_Ranking) > @MinAmountConsumed
    group by E.Zone_Ranking, E.Cross_Dock_Bin_Zone
)
union all
(
    select top(10) Zone_Ranking, Cast(null as Edm.Byte) as P2, AmountConsumed(GroupPartition(E))
    from NavisionFKContext.CRONUS_International_Ltd__Zone as E
    where AmountConsumed(E.Zone_Ranking) > @MinAmountConsumed
    group by E.Zone_Ranking
)
union all
{
    Row(Cast(null as Edm.Int32) as P1, Cast(null as Edm.Byte) as P2, AmountConsumed(select value E
                                                                         from NavisionFKContext.CRONUS_International_Ltd__Zone as E
                                                                         where AmountConsumed(E.Zone_Ranking) > @MinAmountConsumed))
}</CommandText>
    <Parameters>
      <Parameter Name="MinAmountConsumed" DbType="Int32" Value="10000" />
    </Parameters>
  </Query>
```
